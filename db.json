{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/img/ltree98.png","path":"assets/img/ltree98.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1522253631000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1522253631000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1522253631000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1522253631000},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1522253631000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1522253631000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1522253535000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1522253631000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1522253631000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1522253631000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1522253631000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1522253631000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1522253631000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1522253631000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1522253631000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1522253631000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1522253631000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1522253631000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1522253631000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1522253631000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1522253631000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1522253631000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1522253631000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522253631000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522253631000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1522253631000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1522253631000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1522253631000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1522253631000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1522253631000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1522253631000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1522253631000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1522253631000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1522253631000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1522253631000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1522253631000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1522253631000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1522253631000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1522253631000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1522253631000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1522253631000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1522253631000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522253631000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1522253631000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1522253631000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1522253631000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1522253631000},{"_id":"public/2018/03/29/hello-world/index.html","hash":"1a30abe8bf883c762300d44e0595428a8d83ec74","modified":1522254870458},{"_id":"public/archives/index.html","hash":"2c65a087ef289b52aa59fe14cf446bc8ff5cbbf2","modified":1522603519982},{"_id":"public/archives/2018/index.html","hash":"257fbf8a31f1b918621078e82da7b7647bbccc1e","modified":1522254870459},{"_id":"public/archives/2018/03/index.html","hash":"887f958891e18750d450dc7b297a3afe2f9e5866","modified":1522254870459},{"_id":"public/index.html","hash":"c88267b2d9f759b7cb72d76e6a6c3cc45f746419","modified":1522603519987},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522253985993},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522253985993},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522253985993},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522253985993},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522253985993},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522253985993},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1522253985994},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1522253985994},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1522253985994},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522253985994},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1522253986772},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1522253986786},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1522253986786},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522253986786},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1522253986786},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1522253986787},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522253986790},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1522253986792},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1522253986792},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1522253986792},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1522253986792},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1522253986797},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1522253986797},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1522254780000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1522254780000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1522254780000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1522254780000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1522254780000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1522254780000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1522254780000},{"_id":"themes/yilia/_config.yml","hash":"28540ff9c50aaaba4de121682ce521dee240b751","modified":1522603301000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1522254780000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1522254780000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1522254780000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1522254780000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1522254684000},{"_id":"themes/yilia/.git/index","hash":"1cbe626bf7a71a055fc12485f16341f7c9135216","modified":1522598690000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1522254780000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1522254780000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1522254780000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1522254780000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1522254780000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1522254780000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1522254780000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1522254780000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1522254780000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1522254780000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1522254780000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1522254780000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522254780000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522254780000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1522254780000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1522254780000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1522254780000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1522254780000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522254780000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1522254780000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1522254780000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1522254684000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1522254684000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1522254684000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"643ee567c73b9bad21f53562371169f61f826a3a","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1522254780000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1522254780000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1522254780000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1522254780000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1522254780000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1522254780000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1522254780000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1522254780000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1522254780000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1522254780000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1522254780000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1522254780000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1522254780000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1522254780000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1522254780000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1522254780000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1522254780000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1522254780000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1522254780000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1522254780000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1522254780000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1522254780000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1522254780000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1522254780000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1522254780000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1522254780000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1522254780000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1522254780000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1522254780000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1522254780000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1522254780000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1522254780000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1522254780000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1522254780000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1522254780000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1522254780000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1522254780000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1522254780000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1522254780000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1522254780000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1522254780000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1522254780000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1522254780000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1522254780000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1522254780000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1522254780000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1522254780000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1522254780000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1522254780000},{"_id":"themes/yilia/.git/objects/pack/pack-a4a024724a50ae1e8ea0e0deab1aba91916d1344.idx","hash":"66fb8f29773daff89e17aceb7d91f5e53c6b8d47","modified":1522254780000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1522254780000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1522254780000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1522254780000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1522254780000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1522254780000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1522254780000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1522254780000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1522254780000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1522254780000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1522254780000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1522254780000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1522254780000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1522254780000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1522254780000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"643ee567c73b9bad21f53562371169f61f826a3a","modified":1522254780000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1522254780000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"643ee567c73b9bad21f53562371169f61f826a3a","modified":1522254780000},{"_id":"themes/yilia/.git/objects/pack/pack-a4a024724a50ae1e8ea0e0deab1aba91916d1344.pack","hash":"ad13c03f734dc6b2649043501fed63bd1714bfc3","modified":1522254780000},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1522254870467},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1522254870467},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1522254870467},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1522254870467},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1522254870467},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1522254870467},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1522254870467},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1522254870468},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1522254870468},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1522254870476},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1522254870476},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1522254870477},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1522254870477},{"_id":"source/_posts/2016，没走偏.md","hash":"e5d87f6bdfc51f9b55a5d10e41d3c788c2e2c3e3","modified":1522602501000},{"_id":"source/_posts/Go环境搭建小记.md","hash":"8ad5466ead38ebf2074ebf64f93e6e1138fb1040","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_1  Two Sum.md","hash":"0242567be9357515fd44eed2ee7e44054a27fcd7","modified":1496790740000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1522254932000},{"_id":"source/_posts/[Leetcode]_10  Regular Expression Matching.md","hash":"57c9af320787b0eae621a5c2bcef9f9c9a93d254","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_11  Container With Most Water.md","hash":"bc264e30363b70e77993aa64564dfce2fd5acf3a","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_12  Integer to Roman.md","hash":"d97432fa3a4516e49515a7c1af5c95c203f0c1c0","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_13  Roman to Integer.md","hash":"0dae0ea2458a87d8ab100ddab5f212f1bc17afac","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_14  Longest Common Prefix.md","hash":"c50d9be1ea32cf5963e60a5387832dde3ea27b12","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_15  3Sum.md","hash":"a57bd673575b54331e4795fbdec66f337e16deb3","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_16  3Sum Closest.md","hash":"8e5cbba573bc76158c44705832deaa6a84db1f50","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_17  Letter Combinations of a Phone Number.md","hash":"334d26ca4fa7daa8c881a514b0fe63ff7afd1ab1","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_18  4Sum.md","hash":"426e0516d8ba9d737d27bc347e0b7e02963b68da","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_19  Remove Nth Node From End of List.md","hash":"e89877bb79341a18612aff8497267b83d308fed1","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_2  Add Two Numbers.md","hash":"bab2e67d065ef0856f36a22bbd36dff8de88d50e","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_20  Valid Parentheses.md","hash":"bf5b9ef914cfa727c8e9b054770c40bd845e6b72","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_21  Merge Two Sorted Lists.md","hash":"c388bd26c29d1792b639d6c07cca1abb58bfc77c","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_22  Generate Parentheses.md","hash":"22923de43ce37df5fac9677bae29eb30937ebad4","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_23  Merge k Sorted Lists.md","hash":"03484516c6c1866cb708e73b5b90c16879790790","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_24  Swap Nodes in Pairs.md","hash":"6c4e96b829363b0e36bb6443599c03fa808e53de","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_25  Reverse Nodes in k-Group.md","hash":"6776655b98cc98ecbb58cf05b8a9ee14ad2c4bf2","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_26  Remove Duplicates from Sorted Array.md","hash":"533cb18351173b573681532c106424f4f93c2ee9","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_27  Remove Element.md","hash":"337374967991c2e26e0b6b3590b722b26860ec84","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_28  Implement strStr().md","hash":"2a868996da7a81d8066af2cee0a8698bcf005afd","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_29  Divide Two Integers.md","hash":"dcab74060afe86f8d8e0101a4ca6bb73e77e2332","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_3  Longest Substring Without Repeating Characters.md","hash":"0fbc349e1c5856ccc83e2e3b3ded99b927ccd434","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_30  Substring with Concatenation of All Words.md","hash":"6ac590e0c4012ecf055d3748d755c36764ab9234","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_4  Median of Two Sorted Arrays.md","hash":"8c994b43e8e1a943c836fd98078736f8f109126c","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_31  Next Permutation.md","hash":"78b42fdc538108a6dfd57f8032118da91098faf4","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_5  Longest Palindromic Substring.md","hash":"2dc1ca78e15265adf72ab4f829d65eb0072fc03d","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_6  ZigZag Conversion.md","hash":"9273a90b6956c6d86b2bb719af82407b1995222a","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_7  Reverse Integer.md","hash":"f3875dc30efc1b7f8bd3a6871181d2acc1b61da1","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_8  String to Integer(atoi).md","hash":"fadd9c18fc1e5883a5551626191bdb15185e9048","modified":1496790740000},{"_id":"source/_posts/[Leetcode]_9  Palindrome Number.md","hash":"371da45317dfaddb427b6cc4f4720efdbac813b9","modified":1496790740000},{"_id":"source/_posts/cocos2d-x 接入 GameCenter 排行榜与成就.md","hash":"df3a4875f6a3ff27e6c3e4d75868162d0ade9884","modified":1522602774000},{"_id":"source/_posts/python学习笔记.md","hash":"eb6d7d8794c31c2d3cb2969270a0d5c7aef6a1e8","modified":1496790740000},{"_id":"source/_posts/《REWORK》读记.md","hash":"c92a66a668304ed189d408c802bf6f3d5d96f1d1","modified":1496790740000},{"_id":"source/_posts/《三体》读感.md","hash":"8b661ba1935fec8e0d1678f49396a2baa5493a2b","modified":1522602531000},{"_id":"source/_posts/《代码的整洁之道》读记.md","hash":"0d80c37367496fd940f2bf83bf6c717724d423de","modified":1496790740000},{"_id":"source/_posts/《我们仨》读记.md","hash":"3eeeddb3b1c3c447b1de89228fa3d4eccdd867ee","modified":1496790740000},{"_id":"source/_posts/《时间简史》读感.md","hash":"55ea26968de60c6dd8ebc6acaeef189da3c7c993","modified":1522602522000},{"_id":"source/_posts/《生死疲劳》读感.md","hash":"fe10f1659dbbbbdbd7bc9bfc35b50964c57f5a6a","modified":1522602527000},{"_id":"source/_posts/为什么要搞这个？.md","hash":"06a0757ffd413294705fd2136993c11fd46dcd68","modified":1496790740000},{"_id":"source/_posts/删除文件名中的空格.md","hash":"6775e3cf39c59e1ccd97538cf17b0a10f99e6af1","modified":1496790740000},{"_id":"source/_posts/用python发邮件.md","hash":"f478a726c2826bcc0e2addc02aa697fca07acf5e","modified":1496790740000},{"_id":"public/2017/06/04/[Leetcode]_31  Next Permutation/index.html","hash":"44e8be8b5fbbd4e9263bbb74a95f86522d5c71bf","modified":1522603519972},{"_id":"public/2017/05/30/[Leetcode]_30  Substring with Concatenation of All Words/index.html","hash":"99a47e9a1b44fec533193131e50dc45387c1b89c","modified":1522603519972},{"_id":"public/2017/05/30/[Leetcode]_29  Divide Two Integers/index.html","hash":"b15bcdf84cd96cf4ba16c712ed4bb2397980b7c7","modified":1522603519973},{"_id":"public/2017/05/30/[Leetcode]_28  Implement strStr()/index.html","hash":"bb4f42245c5da7f206aa6a3ffa6215aa290fad66","modified":1522603519974},{"_id":"public/2017/05/30/《我们仨》读记/index.html","hash":"b189f263e2f6921a2246134476d2bb50a69b2af9","modified":1522603519974},{"_id":"public/2017/05/15/[Leetcode]_27  Remove Element/index.html","hash":"7f7aa33e4df60a400336475b4efd4fb5e7cb2bc0","modified":1522603519974},{"_id":"public/2017/05/13/[Leetcode]_26  Remove Duplicates from Sorted Array/index.html","hash":"6ae42476cdeefede39bdcf9e1c05595a2ad1708e","modified":1522603519974},{"_id":"public/2017/05/10/[Leetcode]_25  Reverse Nodes in k-Group/index.html","hash":"361974b3d8d58570352a947e71b9e450f66aa05a","modified":1522603519974},{"_id":"public/2017/05/08/[Leetcode]_24  Swap Nodes in Pairs/index.html","hash":"9937fc4a47e831253926de7ecfc67264f427ebce","modified":1522603519974},{"_id":"public/2017/05/07/[Leetcode]_23  Merge k Sorted Lists/index.html","hash":"fb6028ac9a788188373f74a75eb69fe692033533","modified":1522603519974},{"_id":"public/2017/05/04/[Leetcode]_22  Generate Parentheses/index.html","hash":"86ab3de5d8bbc88e448171a80089438c19935383","modified":1522603519975},{"_id":"public/2017/04/30/[Leetcode]_21  Merge Two Sorted Lists/index.html","hash":"9376f548f3e344db398bc7d396cbc7f99159bb4d","modified":1522603519975},{"_id":"public/2017/04/29/cocos2d-x 接入 GameCenter 排行榜与成就/index.html","hash":"5827084a163c80ee199ae552f1b3896d9a374265","modified":1522603519976},{"_id":"public/2017/04/26/[Leetcode]_20  Valid Parentheses/index.html","hash":"f9a20715c223ddb2de1a2bbc891c8f03b50d83f7","modified":1522603519976},{"_id":"public/2017/04/24/[Leetcode]_19  Remove Nth Node From End of List/index.html","hash":"2cf497bcff0bf295c6df90cb0bed7231cd1c5a78","modified":1522603519976},{"_id":"public/2017/04/24/[Leetcode]_18  4Sum/index.html","hash":"50736e11b44294b05e89eac24c411ee22977ecea","modified":1522603519976},{"_id":"public/2017/04/20/[Leetcode]_17  Letter Combinations of a Phone Number/index.html","hash":"9f231be79f2a6adb69c511791e0a7d134c982d5e","modified":1522603519976},{"_id":"public/2017/04/17/[Leetcode]_16  3Sum Closest/index.html","hash":"5794ee9a994d791886433305645f7fb13e9f7664","modified":1522603519976},{"_id":"public/2017/04/17/[Leetcode]_15  3Sum/index.html","hash":"b64d3188836d2dd5882e46eee029ad9b9c6e321b","modified":1522603519977},{"_id":"public/2017/04/12/[Leetcode]_14  Longest Common Prefix/index.html","hash":"0b0eb7650da75f965d8023c9739620e20828afbd","modified":1522603519977},{"_id":"public/2017/04/10/[Leetcode]_13  Roman to Integer/index.html","hash":"a3f02fb53584259d0f4dfe19fc40c4f01cb764cf","modified":1522603519977},{"_id":"public/2017/04/05/[Leetcode]_12  Integer to Roman/index.html","hash":"4d19f394f2571de86331779a7631fbfa90df8250","modified":1522603519978},{"_id":"public/2017/04/05/[Leetcode]_11  Container With Most Water/index.html","hash":"4a1446df7132aa8b2eee4dc44a59f0a4fe97d77d","modified":1522603519978},{"_id":"public/2017/04/01/[Leetcode]_10  Regular Expression Matching/index.html","hash":"b46081229ff002704784e94909dad2b4cf5c829d","modified":1522603519979},{"_id":"public/2017/03/30/[Leetcode]_9  Palindrome Number/index.html","hash":"73b8576b5b10fa80ef04ce485176bd3edf302f0c","modified":1522603519979},{"_id":"public/2017/03/28/[Leetcode]_8  String to Integer(atoi)/index.html","hash":"bfdf32926a87524c8b12376c29b77c56804c37e0","modified":1522603519979},{"_id":"public/2017/03/27/[Leetcode]_6  ZigZag Conversion/index.html","hash":"1ad1504ce44be3c31444dbe53a52b8c8488ffede","modified":1522603519979},{"_id":"public/2017/03/23/[Leetcode]_7  Reverse Integer/index.html","hash":"2aace080366fe8a2dfd4e070651735e903590bd1","modified":1522603519979},{"_id":"public/2017/03/23/Go环境搭建小记/index.html","hash":"e36fd027be0e9ec820e25a53a7a84258dd0ebbd0","modified":1522603519980},{"_id":"public/2017/03/21/[Leetcode]_5  Longest Palindromic Substring/index.html","hash":"3069ed0de25142ad58604dec6092e4c5137ba9ae","modified":1522603519980},{"_id":"public/2017/03/20/[Leetcode]_4  Median of Two Sorted Arrays/index.html","hash":"aa28470d9826f241a8871ad1f46a3739b6f2fd6d","modified":1522603519980},{"_id":"public/2017/03/16/[Leetcode]_3  Longest Substring Without Repeating Characters/index.html","hash":"e06c0de07c38eb412270af04d43df462a5f49f5c","modified":1522603519980},{"_id":"public/2017/03/15/[Leetcode]_2  Add Two Numbers/index.html","hash":"a48baed1aa8ed6af2da675a6cdeb8810c71f0337","modified":1522603519981},{"_id":"public/2017/03/14/[Leetcode]_1  Two Sum/index.html","hash":"f317fcdb0d6cd8bc21f54302c08afc96737ac4e1","modified":1522603519981},{"_id":"public/2017/03/14/《时间简史》读感/index.html","hash":"babddd576d4171a7532d39bff31300156ce71c68","modified":1522603519981},{"_id":"public/2017/02/13/《三体》读感/index.html","hash":"1bd510b9c30314cca316a1373dfd4fe4095b4e0c","modified":1522603519981},{"_id":"public/2017/01/23/2016，没走偏/index.html","hash":"7ff80e47bbaac9b0f2e36ef683eb471c5004cb47","modified":1522603519981},{"_id":"public/2016/11/22/python学习笔记/index.html","hash":"bc61601d9f05f539a2f8fc4e4f41ed11b840bbb1","modified":1522603519981},{"_id":"public/2016/11/20/《REWORK》读记/index.html","hash":"1474b890cf53b89a9e85fb71a357d065f5bd910a","modified":1522603519981},{"_id":"public/2016/11/04/用python发邮件/index.html","hash":"7577adc1b0a9f6ae19d4f9711cc599d4ab1b6faa","modified":1522603519982},{"_id":"public/2016/11/02/删除文件名中的空格/index.html","hash":"ef3f732b07eebe29b2ebf508d4ed5d0e29a478d2","modified":1522603519982},{"_id":"public/2016/10/13/《代码的整洁之道》读记/index.html","hash":"ae01ed79e0bfa34ec2bb59182f17b6e95295c05c","modified":1522603519982},{"_id":"public/2016/07/25/《生死疲劳》读感/index.html","hash":"e9327010bcee19027efe734576c220bee18f22c4","modified":1522603519982},{"_id":"public/2016/07/20/为什么要搞这个？/index.html","hash":"32c60a8c980f4a940d09007ade1ccab8ef47c302","modified":1522603519982},{"_id":"public/archives/page/2/index.html","hash":"80669f69ae9e363bb3df0f892c3c42d07ecef235","modified":1522603519982},{"_id":"public/archives/page/3/index.html","hash":"cf53513704f73ecd44d243817eaff6c897a5e3f5","modified":1522603519982},{"_id":"public/archives/page/4/index.html","hash":"3c9d5704841b289b44c8cd41292910b1236b96f5","modified":1522603519983},{"_id":"public/archives/page/5/index.html","hash":"c4a5811c19d165ee0eab774e5a95c7a4e35f224e","modified":1522603519983},{"_id":"public/archives/2016/index.html","hash":"bcc307881575d8388a9cfcd050fcf62c0495eeb5","modified":1522603519983},{"_id":"public/archives/2016/07/index.html","hash":"39af426021793f60fa82b53cdfcb0b9d35aa0849","modified":1522603519983},{"_id":"public/archives/2016/10/index.html","hash":"ba35fa8b3f98bcfef1bca5143b189196ef4b11b1","modified":1522603519984},{"_id":"public/archives/2016/11/index.html","hash":"ecfb316e43a021707e97b86a124910117409c11f","modified":1522603519984},{"_id":"public/archives/2017/index.html","hash":"3a091694aed2efc4e6537a9ddc752321f315366a","modified":1522603519985},{"_id":"public/archives/2017/page/2/index.html","hash":"3bd744969f1753b5e67564bec3f834510f51db20","modified":1522603519985},{"_id":"public/archives/2017/page/3/index.html","hash":"cc3985d5d3f7cac352132da7b07002d375dfbb52","modified":1522603519985},{"_id":"public/archives/2017/page/4/index.html","hash":"1e403917291a5a19f7ebd2d234c16a5eb563be76","modified":1522603519985},{"_id":"public/archives/2017/01/index.html","hash":"a2e53ae130d23d3bd360a6f3d908547c092a179c","modified":1522603519986},{"_id":"public/archives/2017/02/index.html","hash":"df29e0d73598c087607e9d4a129c3d41bc7e72f1","modified":1522603519986},{"_id":"public/archives/2017/03/index.html","hash":"be272c26a21a51b73eb832b376b728c1ea34c9e7","modified":1522603519986},{"_id":"public/archives/2017/03/page/2/index.html","hash":"22a32957a7cf28d6daf417b8fef4ed07ceadad74","modified":1522603519986},{"_id":"public/archives/2017/04/index.html","hash":"df57172edfbda0c60afea0949eb0dabaa0f5fbf7","modified":1522603519986},{"_id":"public/archives/2017/04/page/2/index.html","hash":"976f629390dbb9aa735e68c08e933910a6a437cf","modified":1522603519986},{"_id":"public/archives/2017/05/index.html","hash":"943a0d179d9a4be3333f69853eb18394173b3e15","modified":1522603519987},{"_id":"public/archives/2017/06/index.html","hash":"88541bed7ceb4cf6842d00616a91c93182e58359","modified":1522603519987},{"_id":"public/page/2/index.html","hash":"7e50f9a2fcf88765354e97008edd58984ab495c1","modified":1522603519987},{"_id":"public/page/3/index.html","hash":"0c461d8699e6fdac11655d76d1f076f85680a511","modified":1522603519987},{"_id":"public/page/4/index.html","hash":"b96258616ac555ae9ab7f79eb2743a8785737a55","modified":1522603519987},{"_id":"public/page/5/index.html","hash":"47515e2b2b8084c64eab5421e7b15ece90596217","modified":1522603519987},{"_id":"public/tags/生活/index.html","hash":"0e555fbaa588a25f3d981d6e16ac61d060a17975","modified":1522600911171},{"_id":"public/tags/环境搭建/index.html","hash":"c9e4cbd950fd365e7dd55039f3629055bb38d660","modified":1522603519987},{"_id":"public/tags/Go/index.html","hash":"389e24397a5eff71bebda83346d665e233cb7c03","modified":1522603519988},{"_id":"public/tags/Leetcode/index.html","hash":"21ce393b6ad061de672de35148ae6d51e5eef6bb","modified":1522603519988},{"_id":"public/tags/Leetcode/page/2/index.html","hash":"0fd302d1fa9ad538c6b614aac24cb311fee53928","modified":1522603519988},{"_id":"public/tags/Leetcode/page/3/index.html","hash":"52ddd7234b0bdb395fe3cc2a599150f20efba4b5","modified":1522603519988},{"_id":"public/tags/Leetcode/page/4/index.html","hash":"3109286c7b9d6e4f0d2a16db4cc313f4a1423a93","modified":1522603519988},{"_id":"public/tags/算法/index.html","hash":"f4c00bfbc3dd8d8e96079eb7bf6e7af364416c03","modified":1522603519989},{"_id":"public/tags/算法/page/2/index.html","hash":"03736fb121d1b2b04e788686b7a4634180570ef8","modified":1522603519989},{"_id":"public/tags/算法/page/3/index.html","hash":"6737095288a3d5dde06b3e6a023bd9b696169b6a","modified":1522603519989},{"_id":"public/tags/算法/page/4/index.html","hash":"d5da700b1567e07d607fbb8ad06ff33fa21ae963","modified":1522603519989},{"_id":"public/tags/cocos2d-x/index.html","hash":"8960d4858d6707b287785be8530847fe337ded62","modified":1522603519989},{"_id":"public/tags/GameCenter/index.html","hash":"88f935fffc1c429ab17502e76541a0619096663f","modified":1522602637211},{"_id":"public/tags/学习笔记/index.html","hash":"b8b644ed28660184a96346e8feb614847fcb716a","modified":1522603519989},{"_id":"public/tags/读书笔记/index.html","hash":"d213d863c47428b7c2ba7541938b245a66a71506","modified":1522603519989},{"_id":"public/tags/随笔/index.html","hash":"d61cb8570b73feea2360cb6a1582003754e805aa","modified":1522603519989},{"_id":"public/tags/脚本/index.html","hash":"c5de7673ab4c1bb2767a0a171aedc9dcb95a1d71","modified":1522603519989},{"_id":"public/tags/小技巧/index.html","hash":"b4e5765664d430bfefd0ebd64c537312cb42219e","modified":1522603519989},{"_id":"source/.DS_Store","hash":"2cbf7f042411337b15fe994dd578fcb750146137","modified":1522603036000},{"_id":"source/assets/.DS_Store","hash":"80daa01c8651407bcc32bda269dcd08755d2f4b2","modified":1522603045000},{"_id":"source/assets/img/ltree98.png","hash":"3a4a56f24cd563a01a57e65e2c2ad2d0a79fd1df","modified":1522603615000},{"_id":"public/assets/img/ltree98.png","hash":"b59f867d40c3d4ee9aad82ce21e37375580e6a5a","modified":1522603219746},{"_id":"source/assets/img/ltree98.png.sb-e34b0478-0oC2ZW","hash":"b59f867d40c3d4ee9aad82ce21e37375580e6a5a","modified":1522603192000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"2016,没走偏","date":"2017-01-23T14:41:35.000Z","_content":"\n2016回顾：毕业与就业\n\n<!-- more -->\n\n\n\n<br/>\n<br/>\n2016年结束有好一阵子了，\n但没有过年，总感觉2016还没有过去。。\n这次的总结，与之前的不大一样；\n有着人生的一个重要的节点，毕业与就业。\n\n---\n<br/>\n<br/>\n\n###  **简单又充实的大学生涯**\n\n四年的大学生涯，圆满结束。\n准确的来说应该是三年吧，最后一年基本就在北京实习了。\n回首，整个大学生涯，还算可以吧，\n虽然没有挂过科，没有做过弊，没有跳进三元湖里游个泳，没有裸过奔...\n但是，也这么平平安安的过来了。\n![这里写图片描述](http://img.blog.csdn.net/20170123230955916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n我投入游戏开发这行，是我高考完就定下的，\n当时找有没有相关的专业，\n挨，中国传媒大学新开了一个相关的，\n但是，高考失利，没上了（本来正常发挥分也够呛能够到）；\n只好选了个计算机方向的，怎么说，也是沾亲带故的嘛。\n刚开始是 软件工程专业，后来通过卓越工程师计划转到了计算机科学与技术。\n（这个计划，选拔时候又笔试又面试，结果，就是假期的时候多上了几个培训课，毕竟第一批，没经验呀，可怜的小白鼠）\n\n没太大关系，\n毕竟，我的目标是游戏开发。\n在完成正常课程情况下，去自学游戏开发。\n于是，大一拉了几个人一起去参加齐鲁软件大赛。\n上大学是我第一次接触编程，\n而且在大一，也没学什么，一堆基础课 加上 谭老师的《C++ 程序设计》。\n就想做一个游戏出来...\n那年夏天，暑假，一个屋子里有6，7个团队，都是准备参加大赛的；\n身为队长加带头人，当然要对这个团队负责；\n用什么方式开发，如何制定进度，每个人的分工，每个人工作的时间，事无巨细。\n中间那些苦难的时光，就不多叙述了。\n记忆最深刻的，就是五个人团结一致，找的小伙伴都很靠谱，记得当时应该是朝八晚八，中午有一个小时午休。\n每个人都很自觉，不需要督促，不需要烦忧。\n大概是一个月左右（五人合作时间），大体雏形已经出来了，\n到最后，整个屋子没剩几个人了，但我们依旧坚持了下来。\n最终，我大学期间第一个项目 —— 《残月夜》 出炉。\n\n![这里写图片描述](http://img.blog.csdn.net/20131009215534656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n[关于残月夜](http://blog.csdn.net/lttree/article/details/12525775)\n\n大二这一年，主要应该是ACM吧。\n本来大一暑假那段时间就应该去集训，但是因为齐鲁软件赛，就放下了ACM。\n然后，大二就比较吃力了。ACM在我们学校也算刚开始起步，方向什么都靠着摸索，也不是很轻松。\n结果，省赛失利，黯然退出。（因为不准备考研，所以大三要搞一搞就业相关的东西了，就没有在ACM再拼一年）\n但是，蓝桥杯的成绩还可以，起码有个奖了...\n\n![这里写图片描述](http://img.blog.csdn.net/20140624195413781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20140624195453375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n[关于我的ACM](http://blog.csdn.net/lttree/article/details/32321653)\n\n\n然后，到了大三。\n大三，就开始为就业做准备了，\n首先是，重新拿起cocos2d引擎，模仿着做了很多当下流行的游戏，有些发了教程博文，有些就自己做着玩了玩：HelloKitty2048、万圣大作战，别踩白块、flappy bird、消灭星星。\n然后，开始看一些书籍，因为我要做一个\"有思想\"的游戏开发者，多学多看一些游戏设计，可能更偏向于策划的东西。\n最后，因为大三了，开始到达专业课的最终章了，就开始各种课设，大作业；再加上卓越计划的培训班，\n学了一堆杂七杂八的，貌似现在已经忘了不少的东西：HTML，MFC，Android，iOS等等\n然后，参加了cocos官方举办的游戏开发大赛，这个要好好说道说道了:\n当时，我记得反转盛行，记得很火的捕鱼达人，然后就想了反过来，来个捕人达鱼，但是名字被美术同学嘲讽了，就改了个非常洋气的名字：人鱼塞壬。\n时间不是很充裕，\n看到比赛的时候就不是很早，\n前期忙于最后期末考试及各种大课设，\n中期，因为卓越班，暑假要到北京千锋培训十天，\n但是，我的美术君是在学校进行甲骨文培训。\n在千锋培训，也要交大作业呀，于是，一边学iOS开发，做大作业；一边再去忙活比赛作品。\n事实证明，三心二意是不好的，尤其是当你两边都想做好的时候，最后iOS作品很一般，比赛作品也没实现多少。\n还好回到学校，还有一段时间，马力全开的赶工，\n先完成了大体的东西，然后慢慢往上加各种功能，到最后功能也没有加多少。\n当初，游戏设定最初所想的都没有加上，\n后来，作品交上去以后，也没有动力去完善它。\n\n![这里写图片描述](http://img.blog.csdn.net/20140928175809265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![这里写图片描述](http://img.blog.csdn.net/20141031230507078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20150818075936616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n[2048系列教程](http://blog.csdn.net/lx417147512/article/category/2602825)\n[别踩白块系列教程](http://blog.csdn.net/lx417147512/article/category/2889567)\n[消灭星星系列教程](http://blog.csdn.net/lx417147512/article/category/3258131)\n[万圣大作战系列教程](http://blog.csdn.net/lx417147512/article/category/2677429)\n[关于人鱼塞壬](http://blog.csdn.net/lttree/article/details/47729343)\n\n大四的时间，基本就是在北京实习了，至今也在这家公司，后面也会谈到。\n\n短暂的大学生涯，印象最深刻的就是启蒙我CSDN的 贺利坚老师，ACM三大巨头 卢云宏老师、周世平老师、封玮老师。\n然后，就是我那些奇葩可爱行为怪诞的室友与同学们，一起拼搏ACM、蓝桥杯的队友们，一起奋战齐鲁赛的组员们。\n\n噢，\n大学最亏欠的还有我那女友，\n看上面那些忙忙碌碌的东西，就知道，\n我很少有时间能陪她，不是在实验室就是在外面比赛。\n感谢她在背后一直默默支持我鼓励我。\n（这段话，绝对不是她在旁边逼迫我写的，键盘什么的跪着也不疼）\n\n<br/>\n<br/>\n\n### **奋斗的工作团队**\n\n话说，\n那应该是2015年十月还是十一月份的，\n一人一包一行李箱闯北京，\n面试了三家，就落户于现在这个铭匠公司，\n以前都是我自己在学校做，自己负责全部。\n第一次接触，真正的游戏公司是如何运作的。\n\n其实，在小公司干活，是一件非常累而且难的事情。\n你会负责很多东西，你需要取舍，\n哪些技术知识，浅尝辄止即可，无须深入；\n哪些技术知识，需要好好研究探寻；\n庄子中也谈论过：\n吾生也有涯，而知也无涯。以有涯随无涯，殆已。\n所以，把有限的精力投入到刀刃上是很重要的。\n\n在 铭匠 呆了也有一年多了，\n期间参与了3.2个游戏制作。\n继续坚持在这里，还是因为做游戏的态度与氛围。\n毕竟，还年轻，工作的原因不是单纯的铁饭碗或者高回报。\n个人的发展与心情占据更高的位置。\n更加重要的是，\n我相信自己的眼光，\n我相信我们团队。\n\n马上游戏就要上线了，\n史诗级大作:   诛神记！\n\n![这里写图片描述](http://img.blog.csdn.net/20170123154953588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n<br/>\n<br/>\n\n### **一些杂事**\n#### > 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\n\n- 《活着》\n- 《REWORK》\n- 《从0到1》\n- 《生死疲劳》\n- 《人类简史》\n- 《卓有成效的程序员》\n- 《代码的整洁之道》\n\n#### > 学python\n初衷是因为感觉python这个脚本语言很强大，可以做各种辅助自己的工具。\n最后，也实践了一些，发工作日报，删文件名空格，火车票查询，感觉也不错，\n为什么有种大炮打苍蝇的感觉。。。\n接下来，还要做一些更多好玩的东西。。。\n\n\n#### > 个人博客  [www.lt-tree.com](http://www.lt-tree.com/)\n用 hexo+Github 搭建了自己的个人博客。\n现在，还没有腾出手好好研究，只是套了别人的模板。\n\n\n#### > Unity\n学了一些Unity的东西。\n简单的学习，起码如果换引擎，也不会手足无措。\n以后，也可能转Unity了。。。\n有点准备。\n\n\n<br/>\n<br/>\n\n### **接下来**\n2017年，\n第一件想做的事就是 —— 减肥。\n曾经不怎么重视体重，\n晚上学习，嘴巴闲不下来，\n结果现在越来越严重了。\n是时候该重视一下了，\n健康，是革命的本钱嘛！\n\n第二件事，读更多的书。\n技术书籍可能不会读很多吧，\n毕竟，有些东西等到出书，可能都被淘汰了。\n主要想读更多的非专业技术书籍，\n比如去年读的《活着》、《生死疲劳》等，\n当然，还要扩展其他类别的。\n你不知道下一款游戏是什么类型的，多扩充一下自己知识体系还是很好的。\n\n最后一件事，老生常谈的 —— 学习。\n互联网这个行业，原地踏步就是退步。\n还是要一直学下去，\n学还要有选择的学，不能瞎学。\n\n<br/>\n\n---\n\n<br/>\n\n最后，\n大学四年，没走偏。\n毕业以后，没走偏。\n2017，继续掌舵前行，\n目标，6点钟方向，出发！\n\n\n###### 等等，为什么是6点钟？  提示：卯时\n\n","source":"_posts/2016，没走偏.md","raw":"---\ntitle: 2016,没走偏\ndate: 2017-01-23 22:41:35\ntags: [随笔]\n---\n\n2016回顾：毕业与就业\n\n<!-- more -->\n\n\n\n<br/>\n<br/>\n2016年结束有好一阵子了，\n但没有过年，总感觉2016还没有过去。。\n这次的总结，与之前的不大一样；\n有着人生的一个重要的节点，毕业与就业。\n\n---\n<br/>\n<br/>\n\n###  **简单又充实的大学生涯**\n\n四年的大学生涯，圆满结束。\n准确的来说应该是三年吧，最后一年基本就在北京实习了。\n回首，整个大学生涯，还算可以吧，\n虽然没有挂过科，没有做过弊，没有跳进三元湖里游个泳，没有裸过奔...\n但是，也这么平平安安的过来了。\n![这里写图片描述](http://img.blog.csdn.net/20170123230955916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n我投入游戏开发这行，是我高考完就定下的，\n当时找有没有相关的专业，\n挨，中国传媒大学新开了一个相关的，\n但是，高考失利，没上了（本来正常发挥分也够呛能够到）；\n只好选了个计算机方向的，怎么说，也是沾亲带故的嘛。\n刚开始是 软件工程专业，后来通过卓越工程师计划转到了计算机科学与技术。\n（这个计划，选拔时候又笔试又面试，结果，就是假期的时候多上了几个培训课，毕竟第一批，没经验呀，可怜的小白鼠）\n\n没太大关系，\n毕竟，我的目标是游戏开发。\n在完成正常课程情况下，去自学游戏开发。\n于是，大一拉了几个人一起去参加齐鲁软件大赛。\n上大学是我第一次接触编程，\n而且在大一，也没学什么，一堆基础课 加上 谭老师的《C++ 程序设计》。\n就想做一个游戏出来...\n那年夏天，暑假，一个屋子里有6，7个团队，都是准备参加大赛的；\n身为队长加带头人，当然要对这个团队负责；\n用什么方式开发，如何制定进度，每个人的分工，每个人工作的时间，事无巨细。\n中间那些苦难的时光，就不多叙述了。\n记忆最深刻的，就是五个人团结一致，找的小伙伴都很靠谱，记得当时应该是朝八晚八，中午有一个小时午休。\n每个人都很自觉，不需要督促，不需要烦忧。\n大概是一个月左右（五人合作时间），大体雏形已经出来了，\n到最后，整个屋子没剩几个人了，但我们依旧坚持了下来。\n最终，我大学期间第一个项目 —— 《残月夜》 出炉。\n\n![这里写图片描述](http://img.blog.csdn.net/20131009215534656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n[关于残月夜](http://blog.csdn.net/lttree/article/details/12525775)\n\n大二这一年，主要应该是ACM吧。\n本来大一暑假那段时间就应该去集训，但是因为齐鲁软件赛，就放下了ACM。\n然后，大二就比较吃力了。ACM在我们学校也算刚开始起步，方向什么都靠着摸索，也不是很轻松。\n结果，省赛失利，黯然退出。（因为不准备考研，所以大三要搞一搞就业相关的东西了，就没有在ACM再拼一年）\n但是，蓝桥杯的成绩还可以，起码有个奖了...\n\n![这里写图片描述](http://img.blog.csdn.net/20140624195413781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20140624195453375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n[关于我的ACM](http://blog.csdn.net/lttree/article/details/32321653)\n\n\n然后，到了大三。\n大三，就开始为就业做准备了，\n首先是，重新拿起cocos2d引擎，模仿着做了很多当下流行的游戏，有些发了教程博文，有些就自己做着玩了玩：HelloKitty2048、万圣大作战，别踩白块、flappy bird、消灭星星。\n然后，开始看一些书籍，因为我要做一个\"有思想\"的游戏开发者，多学多看一些游戏设计，可能更偏向于策划的东西。\n最后，因为大三了，开始到达专业课的最终章了，就开始各种课设，大作业；再加上卓越计划的培训班，\n学了一堆杂七杂八的，貌似现在已经忘了不少的东西：HTML，MFC，Android，iOS等等\n然后，参加了cocos官方举办的游戏开发大赛，这个要好好说道说道了:\n当时，我记得反转盛行，记得很火的捕鱼达人，然后就想了反过来，来个捕人达鱼，但是名字被美术同学嘲讽了，就改了个非常洋气的名字：人鱼塞壬。\n时间不是很充裕，\n看到比赛的时候就不是很早，\n前期忙于最后期末考试及各种大课设，\n中期，因为卓越班，暑假要到北京千锋培训十天，\n但是，我的美术君是在学校进行甲骨文培训。\n在千锋培训，也要交大作业呀，于是，一边学iOS开发，做大作业；一边再去忙活比赛作品。\n事实证明，三心二意是不好的，尤其是当你两边都想做好的时候，最后iOS作品很一般，比赛作品也没实现多少。\n还好回到学校，还有一段时间，马力全开的赶工，\n先完成了大体的东西，然后慢慢往上加各种功能，到最后功能也没有加多少。\n当初，游戏设定最初所想的都没有加上，\n后来，作品交上去以后，也没有动力去完善它。\n\n![这里写图片描述](http://img.blog.csdn.net/20140928175809265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![这里写图片描述](http://img.blog.csdn.net/20141031230507078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20150818075936616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n[2048系列教程](http://blog.csdn.net/lx417147512/article/category/2602825)\n[别踩白块系列教程](http://blog.csdn.net/lx417147512/article/category/2889567)\n[消灭星星系列教程](http://blog.csdn.net/lx417147512/article/category/3258131)\n[万圣大作战系列教程](http://blog.csdn.net/lx417147512/article/category/2677429)\n[关于人鱼塞壬](http://blog.csdn.net/lttree/article/details/47729343)\n\n大四的时间，基本就是在北京实习了，至今也在这家公司，后面也会谈到。\n\n短暂的大学生涯，印象最深刻的就是启蒙我CSDN的 贺利坚老师，ACM三大巨头 卢云宏老师、周世平老师、封玮老师。\n然后，就是我那些奇葩可爱行为怪诞的室友与同学们，一起拼搏ACM、蓝桥杯的队友们，一起奋战齐鲁赛的组员们。\n\n噢，\n大学最亏欠的还有我那女友，\n看上面那些忙忙碌碌的东西，就知道，\n我很少有时间能陪她，不是在实验室就是在外面比赛。\n感谢她在背后一直默默支持我鼓励我。\n（这段话，绝对不是她在旁边逼迫我写的，键盘什么的跪着也不疼）\n\n<br/>\n<br/>\n\n### **奋斗的工作团队**\n\n话说，\n那应该是2015年十月还是十一月份的，\n一人一包一行李箱闯北京，\n面试了三家，就落户于现在这个铭匠公司，\n以前都是我自己在学校做，自己负责全部。\n第一次接触，真正的游戏公司是如何运作的。\n\n其实，在小公司干活，是一件非常累而且难的事情。\n你会负责很多东西，你需要取舍，\n哪些技术知识，浅尝辄止即可，无须深入；\n哪些技术知识，需要好好研究探寻；\n庄子中也谈论过：\n吾生也有涯，而知也无涯。以有涯随无涯，殆已。\n所以，把有限的精力投入到刀刃上是很重要的。\n\n在 铭匠 呆了也有一年多了，\n期间参与了3.2个游戏制作。\n继续坚持在这里，还是因为做游戏的态度与氛围。\n毕竟，还年轻，工作的原因不是单纯的铁饭碗或者高回报。\n个人的发展与心情占据更高的位置。\n更加重要的是，\n我相信自己的眼光，\n我相信我们团队。\n\n马上游戏就要上线了，\n史诗级大作:   诛神记！\n\n![这里写图片描述](http://img.blog.csdn.net/20170123154953588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n<br/>\n<br/>\n\n### **一些杂事**\n#### > 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\n\n- 《活着》\n- 《REWORK》\n- 《从0到1》\n- 《生死疲劳》\n- 《人类简史》\n- 《卓有成效的程序员》\n- 《代码的整洁之道》\n\n#### > 学python\n初衷是因为感觉python这个脚本语言很强大，可以做各种辅助自己的工具。\n最后，也实践了一些，发工作日报，删文件名空格，火车票查询，感觉也不错，\n为什么有种大炮打苍蝇的感觉。。。\n接下来，还要做一些更多好玩的东西。。。\n\n\n#### > 个人博客  [www.lt-tree.com](http://www.lt-tree.com/)\n用 hexo+Github 搭建了自己的个人博客。\n现在，还没有腾出手好好研究，只是套了别人的模板。\n\n\n#### > Unity\n学了一些Unity的东西。\n简单的学习，起码如果换引擎，也不会手足无措。\n以后，也可能转Unity了。。。\n有点准备。\n\n\n<br/>\n<br/>\n\n### **接下来**\n2017年，\n第一件想做的事就是 —— 减肥。\n曾经不怎么重视体重，\n晚上学习，嘴巴闲不下来，\n结果现在越来越严重了。\n是时候该重视一下了，\n健康，是革命的本钱嘛！\n\n第二件事，读更多的书。\n技术书籍可能不会读很多吧，\n毕竟，有些东西等到出书，可能都被淘汰了。\n主要想读更多的非专业技术书籍，\n比如去年读的《活着》、《生死疲劳》等，\n当然，还要扩展其他类别的。\n你不知道下一款游戏是什么类型的，多扩充一下自己知识体系还是很好的。\n\n最后一件事，老生常谈的 —— 学习。\n互联网这个行业，原地踏步就是退步。\n还是要一直学下去，\n学还要有选择的学，不能瞎学。\n\n<br/>\n\n---\n\n<br/>\n\n最后，\n大学四年，没走偏。\n毕业以后，没走偏。\n2017，继续掌舵前行，\n目标，6点钟方向，出发！\n\n\n###### 等等，为什么是6点钟？  提示：卯时\n\n","slug":"2016，没走偏","published":1,"updated":"2018-04-01T17:08:21.000Z","_id":"cjfbbabel0000veuehqqkznt6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>2016回顾：毕业与就业</p>\n<a id=\"more\"></a>\n<p><br><br><br><br>2016年结束有好一阵子了，<br>但没有过年，总感觉2016还没有过去。。<br>这次的总结，与之前的不大一样；<br>有着人生的一个重要的节点，毕业与就业。</p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"简单又充实的大学生涯\"><a href=\"#简单又充实的大学生涯\" class=\"headerlink\" title=\"简单又充实的大学生涯\"></a><strong>简单又充实的大学生涯</strong></h3><p>四年的大学生涯，圆满结束。<br>准确的来说应该是三年吧，最后一年基本就在北京实习了。<br>回首，整个大学生涯，还算可以吧，<br>虽然没有挂过科，没有做过弊，没有跳进三元湖里游个泳，没有裸过奔…<br>但是，也这么平平安安的过来了。<br><img src=\"http://img.blog.csdn.net/20170123230955916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>我投入游戏开发这行，是我高考完就定下的，<br>当时找有没有相关的专业，<br>挨，中国传媒大学新开了一个相关的，<br>但是，高考失利，没上了（本来正常发挥分也够呛能够到）；<br>只好选了个计算机方向的，怎么说，也是沾亲带故的嘛。<br>刚开始是 软件工程专业，后来通过卓越工程师计划转到了计算机科学与技术。<br>（这个计划，选拔时候又笔试又面试，结果，就是假期的时候多上了几个培训课，毕竟第一批，没经验呀，可怜的小白鼠）</p>\n<p>没太大关系，<br>毕竟，我的目标是游戏开发。<br>在完成正常课程情况下，去自学游戏开发。<br>于是，大一拉了几个人一起去参加齐鲁软件大赛。<br>上大学是我第一次接触编程，<br>而且在大一，也没学什么，一堆基础课 加上 谭老师的《C++ 程序设计》。<br>就想做一个游戏出来…<br>那年夏天，暑假，一个屋子里有6，7个团队，都是准备参加大赛的；<br>身为队长加带头人，当然要对这个团队负责；<br>用什么方式开发，如何制定进度，每个人的分工，每个人工作的时间，事无巨细。<br>中间那些苦难的时光，就不多叙述了。<br>记忆最深刻的，就是五个人团结一致，找的小伙伴都很靠谱，记得当时应该是朝八晚八，中午有一个小时午休。<br>每个人都很自觉，不需要督促，不需要烦忧。<br>大概是一个月左右（五人合作时间），大体雏形已经出来了，<br>到最后，整个屋子没剩几个人了，但我们依旧坚持了下来。<br>最终，我大学期间第一个项目 —— 《残月夜》 出炉。</p>\n<p><img src=\"http://img.blog.csdn.net/20131009215534656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lttree/article/details/12525775\" target=\"_blank\" rel=\"noopener\">关于残月夜</a></p>\n<p>大二这一年，主要应该是ACM吧。<br>本来大一暑假那段时间就应该去集训，但是因为齐鲁软件赛，就放下了ACM。<br>然后，大二就比较吃力了。ACM在我们学校也算刚开始起步，方向什么都靠着摸索，也不是很轻松。<br>结果，省赛失利，黯然退出。（因为不准备考研，所以大三要搞一搞就业相关的东西了，就没有在ACM再拼一年）<br>但是，蓝桥杯的成绩还可以，起码有个奖了…</p>\n<p><img src=\"http://img.blog.csdn.net/20140624195413781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20140624195453375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lttree/article/details/32321653\" target=\"_blank\" rel=\"noopener\">关于我的ACM</a></p>\n<p>然后，到了大三。<br>大三，就开始为就业做准备了，<br>首先是，重新拿起cocos2d引擎，模仿着做了很多当下流行的游戏，有些发了教程博文，有些就自己做着玩了玩：HelloKitty2048、万圣大作战，别踩白块、flappy bird、消灭星星。<br>然后，开始看一些书籍，因为我要做一个”有思想”的游戏开发者，多学多看一些游戏设计，可能更偏向于策划的东西。<br>最后，因为大三了，开始到达专业课的最终章了，就开始各种课设，大作业；再加上卓越计划的培训班，<br>学了一堆杂七杂八的，貌似现在已经忘了不少的东西：HTML，MFC，Android，iOS等等<br>然后，参加了cocos官方举办的游戏开发大赛，这个要好好说道说道了:<br>当时，我记得反转盛行，记得很火的捕鱼达人，然后就想了反过来，来个捕人达鱼，但是名字被美术同学嘲讽了，就改了个非常洋气的名字：人鱼塞壬。<br>时间不是很充裕，<br>看到比赛的时候就不是很早，<br>前期忙于最后期末考试及各种大课设，<br>中期，因为卓越班，暑假要到北京千锋培训十天，<br>但是，我的美术君是在学校进行甲骨文培训。<br>在千锋培训，也要交大作业呀，于是，一边学iOS开发，做大作业；一边再去忙活比赛作品。<br>事实证明，三心二意是不好的，尤其是当你两边都想做好的时候，最后iOS作品很一般，比赛作品也没实现多少。<br>还好回到学校，还有一段时间，马力全开的赶工，<br>先完成了大体的东西，然后慢慢往上加各种功能，到最后功能也没有加多少。<br>当初，游戏设定最初所想的都没有加上，<br>后来，作品交上去以后，也没有动力去完善它。</p>\n<p><img src=\"http://img.blog.csdn.net/20140928175809265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20141031230507078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20150818075936616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lx417147512/article/category/2602825\" target=\"_blank\" rel=\"noopener\">2048系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/2889567\" target=\"_blank\" rel=\"noopener\">别踩白块系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/3258131\" target=\"_blank\" rel=\"noopener\">消灭星星系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/2677429\" target=\"_blank\" rel=\"noopener\">万圣大作战系列教程</a><br><a href=\"http://blog.csdn.net/lttree/article/details/47729343\" target=\"_blank\" rel=\"noopener\">关于人鱼塞壬</a></p>\n<p>大四的时间，基本就是在北京实习了，至今也在这家公司，后面也会谈到。</p>\n<p>短暂的大学生涯，印象最深刻的就是启蒙我CSDN的 贺利坚老师，ACM三大巨头 卢云宏老师、周世平老师、封玮老师。<br>然后，就是我那些奇葩可爱行为怪诞的室友与同学们，一起拼搏ACM、蓝桥杯的队友们，一起奋战齐鲁赛的组员们。</p>\n<p>噢，<br>大学最亏欠的还有我那女友，<br>看上面那些忙忙碌碌的东西，就知道，<br>我很少有时间能陪她，不是在实验室就是在外面比赛。<br>感谢她在背后一直默默支持我鼓励我。<br>（这段话，绝对不是她在旁边逼迫我写的，键盘什么的跪着也不疼）</p>\n<p><br><br><br></p>\n<h3 id=\"奋斗的工作团队\"><a href=\"#奋斗的工作团队\" class=\"headerlink\" title=\"奋斗的工作团队\"></a><strong>奋斗的工作团队</strong></h3><p>话说，<br>那应该是2015年十月还是十一月份的，<br>一人一包一行李箱闯北京，<br>面试了三家，就落户于现在这个铭匠公司，<br>以前都是我自己在学校做，自己负责全部。<br>第一次接触，真正的游戏公司是如何运作的。</p>\n<p>其实，在小公司干活，是一件非常累而且难的事情。<br>你会负责很多东西，你需要取舍，<br>哪些技术知识，浅尝辄止即可，无须深入；<br>哪些技术知识，需要好好研究探寻；<br>庄子中也谈论过：<br>吾生也有涯，而知也无涯。以有涯随无涯，殆已。<br>所以，把有限的精力投入到刀刃上是很重要的。</p>\n<p>在 铭匠 呆了也有一年多了，<br>期间参与了3.2个游戏制作。<br>继续坚持在这里，还是因为做游戏的态度与氛围。<br>毕竟，还年轻，工作的原因不是单纯的铁饭碗或者高回报。<br>个人的发展与心情占据更高的位置。<br>更加重要的是，<br>我相信自己的眼光，<br>我相信我们团队。</p>\n<p>马上游戏就要上线了，<br>史诗级大作:   诛神记！</p>\n<p><img src=\"http://img.blog.csdn.net/20170123154953588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><br><br><br></p>\n<h3 id=\"一些杂事\"><a href=\"#一些杂事\" class=\"headerlink\" title=\"一些杂事\"></a><strong>一些杂事</strong></h3><h4 id=\"gt-今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\"><a href=\"#gt-今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\" class=\"headerlink\" title=\"&gt; 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\"></a>&gt; 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。</h4><ul>\n<li>《活着》</li>\n<li>《REWORK》</li>\n<li>《从0到1》</li>\n<li>《生死疲劳》</li>\n<li>《人类简史》</li>\n<li>《卓有成效的程序员》</li>\n<li>《代码的整洁之道》</li>\n</ul>\n<h4 id=\"gt-学python\"><a href=\"#gt-学python\" class=\"headerlink\" title=\"&gt; 学python\"></a>&gt; 学python</h4><p>初衷是因为感觉python这个脚本语言很强大，可以做各种辅助自己的工具。<br>最后，也实践了一些，发工作日报，删文件名空格，火车票查询，感觉也不错，<br>为什么有种大炮打苍蝇的感觉。。。<br>接下来，还要做一些更多好玩的东西。。。</p>\n<h4 id=\"gt-个人博客-www-lt-tree-com\"><a href=\"#gt-个人博客-www-lt-tree-com\" class=\"headerlink\" title=\"&gt; 个人博客  www.lt-tree.com\"></a>&gt; 个人博客  <a href=\"http://www.lt-tree.com/\" target=\"_blank\" rel=\"noopener\">www.lt-tree.com</a></h4><p>用 hexo+Github 搭建了自己的个人博客。<br>现在，还没有腾出手好好研究，只是套了别人的模板。</p>\n<h4 id=\"gt-Unity\"><a href=\"#gt-Unity\" class=\"headerlink\" title=\"&gt; Unity\"></a>&gt; Unity</h4><p>学了一些Unity的东西。<br>简单的学习，起码如果换引擎，也不会手足无措。<br>以后，也可能转Unity了。。。<br>有点准备。</p>\n<p><br><br><br></p>\n<h3 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a><strong>接下来</strong></h3><p>2017年，<br>第一件想做的事就是 —— 减肥。<br>曾经不怎么重视体重，<br>晚上学习，嘴巴闲不下来，<br>结果现在越来越严重了。<br>是时候该重视一下了，<br>健康，是革命的本钱嘛！</p>\n<p>第二件事，读更多的书。<br>技术书籍可能不会读很多吧，<br>毕竟，有些东西等到出书，可能都被淘汰了。<br>主要想读更多的非专业技术书籍，<br>比如去年读的《活着》、《生死疲劳》等，<br>当然，还要扩展其他类别的。<br>你不知道下一款游戏是什么类型的，多扩充一下自己知识体系还是很好的。</p>\n<p>最后一件事，老生常谈的 —— 学习。<br>互联网这个行业，原地踏步就是退步。<br>还是要一直学下去，<br>学还要有选择的学，不能瞎学。</p>\n<p><br></p>\n<hr>\n<p><br></p>\n<p>最后，<br>大学四年，没走偏。<br>毕业以后，没走偏。<br>2017，继续掌舵前行，<br>目标，6点钟方向，出发！</p>\n<h6 id=\"等等，为什么是6点钟？-提示：卯时\"><a href=\"#等等，为什么是6点钟？-提示：卯时\" class=\"headerlink\" title=\"等等，为什么是6点钟？  提示：卯时\"></a>等等，为什么是6点钟？  提示：卯时</h6>","site":{"data":{}},"excerpt":"<p>2016回顾：毕业与就业</p>","more":"<p><br><br><br><br>2016年结束有好一阵子了，<br>但没有过年，总感觉2016还没有过去。。<br>这次的总结，与之前的不大一样；<br>有着人生的一个重要的节点，毕业与就业。</p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"简单又充实的大学生涯\"><a href=\"#简单又充实的大学生涯\" class=\"headerlink\" title=\"简单又充实的大学生涯\"></a><strong>简单又充实的大学生涯</strong></h3><p>四年的大学生涯，圆满结束。<br>准确的来说应该是三年吧，最后一年基本就在北京实习了。<br>回首，整个大学生涯，还算可以吧，<br>虽然没有挂过科，没有做过弊，没有跳进三元湖里游个泳，没有裸过奔…<br>但是，也这么平平安安的过来了。<br><img src=\"http://img.blog.csdn.net/20170123230955916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>我投入游戏开发这行，是我高考完就定下的，<br>当时找有没有相关的专业，<br>挨，中国传媒大学新开了一个相关的，<br>但是，高考失利，没上了（本来正常发挥分也够呛能够到）；<br>只好选了个计算机方向的，怎么说，也是沾亲带故的嘛。<br>刚开始是 软件工程专业，后来通过卓越工程师计划转到了计算机科学与技术。<br>（这个计划，选拔时候又笔试又面试，结果，就是假期的时候多上了几个培训课，毕竟第一批，没经验呀，可怜的小白鼠）</p>\n<p>没太大关系，<br>毕竟，我的目标是游戏开发。<br>在完成正常课程情况下，去自学游戏开发。<br>于是，大一拉了几个人一起去参加齐鲁软件大赛。<br>上大学是我第一次接触编程，<br>而且在大一，也没学什么，一堆基础课 加上 谭老师的《C++ 程序设计》。<br>就想做一个游戏出来…<br>那年夏天，暑假，一个屋子里有6，7个团队，都是准备参加大赛的；<br>身为队长加带头人，当然要对这个团队负责；<br>用什么方式开发，如何制定进度，每个人的分工，每个人工作的时间，事无巨细。<br>中间那些苦难的时光，就不多叙述了。<br>记忆最深刻的，就是五个人团结一致，找的小伙伴都很靠谱，记得当时应该是朝八晚八，中午有一个小时午休。<br>每个人都很自觉，不需要督促，不需要烦忧。<br>大概是一个月左右（五人合作时间），大体雏形已经出来了，<br>到最后，整个屋子没剩几个人了，但我们依旧坚持了下来。<br>最终，我大学期间第一个项目 —— 《残月夜》 出炉。</p>\n<p><img src=\"http://img.blog.csdn.net/20131009215534656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lttree/article/details/12525775\" target=\"_blank\" rel=\"noopener\">关于残月夜</a></p>\n<p>大二这一年，主要应该是ACM吧。<br>本来大一暑假那段时间就应该去集训，但是因为齐鲁软件赛，就放下了ACM。<br>然后，大二就比较吃力了。ACM在我们学校也算刚开始起步，方向什么都靠着摸索，也不是很轻松。<br>结果，省赛失利，黯然退出。（因为不准备考研，所以大三要搞一搞就业相关的东西了，就没有在ACM再拼一年）<br>但是，蓝桥杯的成绩还可以，起码有个奖了…</p>\n<p><img src=\"http://img.blog.csdn.net/20140624195413781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20140624195453375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lttree/article/details/32321653\" target=\"_blank\" rel=\"noopener\">关于我的ACM</a></p>\n<p>然后，到了大三。<br>大三，就开始为就业做准备了，<br>首先是，重新拿起cocos2d引擎，模仿着做了很多当下流行的游戏，有些发了教程博文，有些就自己做着玩了玩：HelloKitty2048、万圣大作战，别踩白块、flappy bird、消灭星星。<br>然后，开始看一些书籍，因为我要做一个”有思想”的游戏开发者，多学多看一些游戏设计，可能更偏向于策划的东西。<br>最后，因为大三了，开始到达专业课的最终章了，就开始各种课设，大作业；再加上卓越计划的培训班，<br>学了一堆杂七杂八的，貌似现在已经忘了不少的东西：HTML，MFC，Android，iOS等等<br>然后，参加了cocos官方举办的游戏开发大赛，这个要好好说道说道了:<br>当时，我记得反转盛行，记得很火的捕鱼达人，然后就想了反过来，来个捕人达鱼，但是名字被美术同学嘲讽了，就改了个非常洋气的名字：人鱼塞壬。<br>时间不是很充裕，<br>看到比赛的时候就不是很早，<br>前期忙于最后期末考试及各种大课设，<br>中期，因为卓越班，暑假要到北京千锋培训十天，<br>但是，我的美术君是在学校进行甲骨文培训。<br>在千锋培训，也要交大作业呀，于是，一边学iOS开发，做大作业；一边再去忙活比赛作品。<br>事实证明，三心二意是不好的，尤其是当你两边都想做好的时候，最后iOS作品很一般，比赛作品也没实现多少。<br>还好回到学校，还有一段时间，马力全开的赶工，<br>先完成了大体的东西，然后慢慢往上加各种功能，到最后功能也没有加多少。<br>当初，游戏设定最初所想的都没有加上，<br>后来，作品交上去以后，也没有动力去完善它。</p>\n<p><img src=\"http://img.blog.csdn.net/20140928175809265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20141031230507078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20150818075936616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><a href=\"http://blog.csdn.net/lx417147512/article/category/2602825\" target=\"_blank\" rel=\"noopener\">2048系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/2889567\" target=\"_blank\" rel=\"noopener\">别踩白块系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/3258131\" target=\"_blank\" rel=\"noopener\">消灭星星系列教程</a><br><a href=\"http://blog.csdn.net/lx417147512/article/category/2677429\" target=\"_blank\" rel=\"noopener\">万圣大作战系列教程</a><br><a href=\"http://blog.csdn.net/lttree/article/details/47729343\" target=\"_blank\" rel=\"noopener\">关于人鱼塞壬</a></p>\n<p>大四的时间，基本就是在北京实习了，至今也在这家公司，后面也会谈到。</p>\n<p>短暂的大学生涯，印象最深刻的就是启蒙我CSDN的 贺利坚老师，ACM三大巨头 卢云宏老师、周世平老师、封玮老师。<br>然后，就是我那些奇葩可爱行为怪诞的室友与同学们，一起拼搏ACM、蓝桥杯的队友们，一起奋战齐鲁赛的组员们。</p>\n<p>噢，<br>大学最亏欠的还有我那女友，<br>看上面那些忙忙碌碌的东西，就知道，<br>我很少有时间能陪她，不是在实验室就是在外面比赛。<br>感谢她在背后一直默默支持我鼓励我。<br>（这段话，绝对不是她在旁边逼迫我写的，键盘什么的跪着也不疼）</p>\n<p><br><br><br></p>\n<h3 id=\"奋斗的工作团队\"><a href=\"#奋斗的工作团队\" class=\"headerlink\" title=\"奋斗的工作团队\"></a><strong>奋斗的工作团队</strong></h3><p>话说，<br>那应该是2015年十月还是十一月份的，<br>一人一包一行李箱闯北京，<br>面试了三家，就落户于现在这个铭匠公司，<br>以前都是我自己在学校做，自己负责全部。<br>第一次接触，真正的游戏公司是如何运作的。</p>\n<p>其实，在小公司干活，是一件非常累而且难的事情。<br>你会负责很多东西，你需要取舍，<br>哪些技术知识，浅尝辄止即可，无须深入；<br>哪些技术知识，需要好好研究探寻；<br>庄子中也谈论过：<br>吾生也有涯，而知也无涯。以有涯随无涯，殆已。<br>所以，把有限的精力投入到刀刃上是很重要的。</p>\n<p>在 铭匠 呆了也有一年多了，<br>期间参与了3.2个游戏制作。<br>继续坚持在这里，还是因为做游戏的态度与氛围。<br>毕竟，还年轻，工作的原因不是单纯的铁饭碗或者高回报。<br>个人的发展与心情占据更高的位置。<br>更加重要的是，<br>我相信自己的眼光，<br>我相信我们团队。</p>\n<p>马上游戏就要上线了，<br>史诗级大作:   诛神记！</p>\n<p><img src=\"http://img.blog.csdn.net/20170123154953588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHR0cmVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><br><br><br></p>\n<h3 id=\"一些杂事\"><a href=\"#一些杂事\" class=\"headerlink\" title=\"一些杂事\"></a><strong>一些杂事</strong></h3><h4 id=\"gt-今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\"><a href=\"#gt-今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\" class=\"headerlink\" title=\"&gt; 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。\"></a>&gt; 今年，也读了一些书，有些是同事推荐的，有些是自己想看的。</h4><ul>\n<li>《活着》</li>\n<li>《REWORK》</li>\n<li>《从0到1》</li>\n<li>《生死疲劳》</li>\n<li>《人类简史》</li>\n<li>《卓有成效的程序员》</li>\n<li>《代码的整洁之道》</li>\n</ul>\n<h4 id=\"gt-学python\"><a href=\"#gt-学python\" class=\"headerlink\" title=\"&gt; 学python\"></a>&gt; 学python</h4><p>初衷是因为感觉python这个脚本语言很强大，可以做各种辅助自己的工具。<br>最后，也实践了一些，发工作日报，删文件名空格，火车票查询，感觉也不错，<br>为什么有种大炮打苍蝇的感觉。。。<br>接下来，还要做一些更多好玩的东西。。。</p>\n<h4 id=\"gt-个人博客-www-lt-tree-com\"><a href=\"#gt-个人博客-www-lt-tree-com\" class=\"headerlink\" title=\"&gt; 个人博客  www.lt-tree.com\"></a>&gt; 个人博客  <a href=\"http://www.lt-tree.com/\" target=\"_blank\" rel=\"noopener\">www.lt-tree.com</a></h4><p>用 hexo+Github 搭建了自己的个人博客。<br>现在，还没有腾出手好好研究，只是套了别人的模板。</p>\n<h4 id=\"gt-Unity\"><a href=\"#gt-Unity\" class=\"headerlink\" title=\"&gt; Unity\"></a>&gt; Unity</h4><p>学了一些Unity的东西。<br>简单的学习，起码如果换引擎，也不会手足无措。<br>以后，也可能转Unity了。。。<br>有点准备。</p>\n<p><br><br><br></p>\n<h3 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a><strong>接下来</strong></h3><p>2017年，<br>第一件想做的事就是 —— 减肥。<br>曾经不怎么重视体重，<br>晚上学习，嘴巴闲不下来，<br>结果现在越来越严重了。<br>是时候该重视一下了，<br>健康，是革命的本钱嘛！</p>\n<p>第二件事，读更多的书。<br>技术书籍可能不会读很多吧，<br>毕竟，有些东西等到出书，可能都被淘汰了。<br>主要想读更多的非专业技术书籍，<br>比如去年读的《活着》、《生死疲劳》等，<br>当然，还要扩展其他类别的。<br>你不知道下一款游戏是什么类型的，多扩充一下自己知识体系还是很好的。</p>\n<p>最后一件事，老生常谈的 —— 学习。<br>互联网这个行业，原地踏步就是退步。<br>还是要一直学下去，<br>学还要有选择的学，不能瞎学。</p>\n<p><br></p>\n<hr>\n<p><br></p>\n<p>最后，<br>大学四年，没走偏。<br>毕业以后，没走偏。<br>2017，继续掌舵前行，<br>目标，6点钟方向，出发！</p>\n<h6 id=\"等等，为什么是6点钟？-提示：卯时\"><a href=\"#等等，为什么是6点钟？-提示：卯时\" class=\"headerlink\" title=\"等等，为什么是6点钟？  提示：卯时\"></a>等等，为什么是6点钟？  提示：卯时</h6>"},{"title":"Go环境搭建小记","date":"2017-03-23T14:00:00.000Z","_content":"\n----------\n\nGo环境搭建\nMac + Go1.7 + VSCode1.8\n\n\n<!-- more -->\n<br/>\n\n由于工作原因，需要学习一下Go。\n其实，我一直就对这个语言挺感兴趣的。\n虽说技多不压身，但贪多嚼不烂；本来想着嚼烂了客户端，再去学一学Go。\n没关系，先提前了解一下吧。\n<br/>\n这个语言，对新手真是不友好到极点。\n搭环境废了很大功夫。\n\n先列一下我的环境：\nMac系统 - Go 1.7 - VSCode 1.8\n（ IDE为什么选择VSCode？VSCode优点可以自行Google ）\n\n<br/>\n\n### Go的设置\n先把Go下载，然后安装到Mac。\n然后需要配置一下环境变量\n\n- GOROOT\n这个是你Go安装到的位置，一般在  /usr/local/go\n- GOPATH\n这个是你工作区路径，一般在自建的文件夹下（这个自建的文件夹下要有3个子文件夹[src、pkg、bin]）\n- GOBIN（选配）\n工作区路径下的bin文件夹（**路径唯一**）\n\n当时这块就混淆了一下。\n因为Go是支持多个工作区域的，后面我们要为Go下载一系列依赖包（就是在命令行用 go get 获得的一堆东西），如果都放在一个工作区域，就会有些混乱。\n所以，很多人就建立两个区域，一个放依赖包，一个用来放自己平时的东西。\n这时候，环境变量上就要有多个区域，Mac用 ':' 来区隔。（依赖包默认下载到第一个工作区域）\n\n在命令行下：\n\n1. 打开配置（`vim .bash_profile`） 开始搭Go环境。\n2. `export GOPATH=\"/Users/你的用户名/依赖包目录:/Users/你的用户名/工作区目录\"`\n依赖包默认下载到GOPATH的第一个目录下，所以依赖包目录要放在第一个，然后用':'分隔\n`export PATH=$PATH:${GOPATH//://bin:}/bin`\n如果设置GOBIN，GOBIN只能设置一个路径，但是你可以将每个GOPATH下的bin添加到PATH中\n`export PATH=$PATH:$GOPATH`\n路径加入到PATH\n3. 保存退出，然后重启配置（source .bash_profile)\n4. 输入 go env 看看Go的环境变量\n\n*PS: 关于GOBIN：go install编译存放路径。不允许设置多个路径。可以为空。为空时则遵循“约定优于配置”原则，可执行文件放在各自GOPATH目录的bin文件夹中（前提是：package main的main函数文件不能直接放到GOPATH的src下面。)*\n\n<br/>\n\n### VSCode的配置\n下载VSCode，然后在左侧小图标的最下面那个扩展选项中，搜索Go，进行下载(一般会搜索到两个go 和 Go，我下载的是第二个Go)。\n接下来，要下载一系列的依赖包。\n\n\n##### 1. 打开命令行，分别输入以下命令进行下载：\n\n```\ngo get -u -v github.com/nsf/gocode\ngo get -u -v github.com/rogpeppe/godef\ngo get -u -v github.com/golang/lint/golint\ngo get -u -v github.com/lukehoban/go-outline\ngo get -u -v sourcegraph.com/sqs/goreturns\ngo get -u -v golang.org/x/tools/cmd/gorename\ngo get -u -v github.com/tpng/gopkgs\ngo get -u -v golang.org/x/tools/cmd/guru\n```\n\n这一步，需要  科学上网工具  的支持，而且有时候，你有科学上网工具的支持都不顶用。\n本质上讲，以gocode为例，它将gocode相关文件下载到src，然后将它编译生成可执行文件，将可执行文件放到bin目录下。\n所以，可以直接去github上下载下来，然后自己编译一下，将生成的可执行文件放到bin目录下。\n\n##### 2. 配置VSCode相关\n主要是 settings.json 与 launch.json\n\n如果你配置了 GOPATH、GOROOT ，就不需要配置相应的setting.json。\n（进入方法是 code -> 首选项 -> 用户设置）\n\n打开VSCode，选择你的工作区域文件夹，然后在编辑配置文件。（不选文件夹不能配置）\n进入方法是 code -> 首选项 -> 工作区设置\n\n主要修改program字段: `program: \"${workspaceRoot}\"`\n如果你的文件，比如test.go 放在src下就： `program: \"${workspaceRoot}/src\"`\n\n<br/>\n\n### 让Mac 支持 VSCode调试功能\n英语原文：  [>这里<](https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md)\n\n<br/>\n简单翻译一下步骤：\n1.  创建一个自签名证书\n\t找到钥匙串访问，（ 证书助理 -> 创建证书（身份类型：自签名证书，证书类型：代码签名，勾选 覆盖这些默认值） -> 继续到最后，指定用于该证书的位置: 系统 ）\n2.  设定信任属性\n\t重启系统后，找到自己创建的证书，在 （ 显示简介 -> 信任 -> 代码签名 ） 选择 （ 始终信任 ）\n3.  重新编译dlv文件\n\t打开命令行，进入依赖包所处的工作区: `src/github.com/derekparker/delve`\n\t如果你的Go版本是1.5，则运行： `GO15VENDOREXPERIMENT=1 CERT=你创建的证书名称 make install`\n\t其他版本就直接：`CERT=你创建的证书名称 make install`\n\n\n<br/>\n\n### 总结小记。\n终于折腾完了。\n花了好久时间，看了N多教程，但还是走了不少弯路。\n在 GOPATH、GOROOT理解上，在GOBIN路径唯一上，在创建签名证书处等等。\n所以，整理了一下这篇文章，希望对他人有所帮助。","source":"_posts/Go环境搭建小记.md","raw":"---\ntitle: Go环境搭建小记\ndate: 2017-03-23 22:00:00\ntags: [环境搭建, Go]\n---\n\n----------\n\nGo环境搭建\nMac + Go1.7 + VSCode1.8\n\n\n<!-- more -->\n<br/>\n\n由于工作原因，需要学习一下Go。\n其实，我一直就对这个语言挺感兴趣的。\n虽说技多不压身，但贪多嚼不烂；本来想着嚼烂了客户端，再去学一学Go。\n没关系，先提前了解一下吧。\n<br/>\n这个语言，对新手真是不友好到极点。\n搭环境废了很大功夫。\n\n先列一下我的环境：\nMac系统 - Go 1.7 - VSCode 1.8\n（ IDE为什么选择VSCode？VSCode优点可以自行Google ）\n\n<br/>\n\n### Go的设置\n先把Go下载，然后安装到Mac。\n然后需要配置一下环境变量\n\n- GOROOT\n这个是你Go安装到的位置，一般在  /usr/local/go\n- GOPATH\n这个是你工作区路径，一般在自建的文件夹下（这个自建的文件夹下要有3个子文件夹[src、pkg、bin]）\n- GOBIN（选配）\n工作区路径下的bin文件夹（**路径唯一**）\n\n当时这块就混淆了一下。\n因为Go是支持多个工作区域的，后面我们要为Go下载一系列依赖包（就是在命令行用 go get 获得的一堆东西），如果都放在一个工作区域，就会有些混乱。\n所以，很多人就建立两个区域，一个放依赖包，一个用来放自己平时的东西。\n这时候，环境变量上就要有多个区域，Mac用 ':' 来区隔。（依赖包默认下载到第一个工作区域）\n\n在命令行下：\n\n1. 打开配置（`vim .bash_profile`） 开始搭Go环境。\n2. `export GOPATH=\"/Users/你的用户名/依赖包目录:/Users/你的用户名/工作区目录\"`\n依赖包默认下载到GOPATH的第一个目录下，所以依赖包目录要放在第一个，然后用':'分隔\n`export PATH=$PATH:${GOPATH//://bin:}/bin`\n如果设置GOBIN，GOBIN只能设置一个路径，但是你可以将每个GOPATH下的bin添加到PATH中\n`export PATH=$PATH:$GOPATH`\n路径加入到PATH\n3. 保存退出，然后重启配置（source .bash_profile)\n4. 输入 go env 看看Go的环境变量\n\n*PS: 关于GOBIN：go install编译存放路径。不允许设置多个路径。可以为空。为空时则遵循“约定优于配置”原则，可执行文件放在各自GOPATH目录的bin文件夹中（前提是：package main的main函数文件不能直接放到GOPATH的src下面。)*\n\n<br/>\n\n### VSCode的配置\n下载VSCode，然后在左侧小图标的最下面那个扩展选项中，搜索Go，进行下载(一般会搜索到两个go 和 Go，我下载的是第二个Go)。\n接下来，要下载一系列的依赖包。\n\n\n##### 1. 打开命令行，分别输入以下命令进行下载：\n\n```\ngo get -u -v github.com/nsf/gocode\ngo get -u -v github.com/rogpeppe/godef\ngo get -u -v github.com/golang/lint/golint\ngo get -u -v github.com/lukehoban/go-outline\ngo get -u -v sourcegraph.com/sqs/goreturns\ngo get -u -v golang.org/x/tools/cmd/gorename\ngo get -u -v github.com/tpng/gopkgs\ngo get -u -v golang.org/x/tools/cmd/guru\n```\n\n这一步，需要  科学上网工具  的支持，而且有时候，你有科学上网工具的支持都不顶用。\n本质上讲，以gocode为例，它将gocode相关文件下载到src，然后将它编译生成可执行文件，将可执行文件放到bin目录下。\n所以，可以直接去github上下载下来，然后自己编译一下，将生成的可执行文件放到bin目录下。\n\n##### 2. 配置VSCode相关\n主要是 settings.json 与 launch.json\n\n如果你配置了 GOPATH、GOROOT ，就不需要配置相应的setting.json。\n（进入方法是 code -> 首选项 -> 用户设置）\n\n打开VSCode，选择你的工作区域文件夹，然后在编辑配置文件。（不选文件夹不能配置）\n进入方法是 code -> 首选项 -> 工作区设置\n\n主要修改program字段: `program: \"${workspaceRoot}\"`\n如果你的文件，比如test.go 放在src下就： `program: \"${workspaceRoot}/src\"`\n\n<br/>\n\n### 让Mac 支持 VSCode调试功能\n英语原文：  [>这里<](https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md)\n\n<br/>\n简单翻译一下步骤：\n1.  创建一个自签名证书\n\t找到钥匙串访问，（ 证书助理 -> 创建证书（身份类型：自签名证书，证书类型：代码签名，勾选 覆盖这些默认值） -> 继续到最后，指定用于该证书的位置: 系统 ）\n2.  设定信任属性\n\t重启系统后，找到自己创建的证书，在 （ 显示简介 -> 信任 -> 代码签名 ） 选择 （ 始终信任 ）\n3.  重新编译dlv文件\n\t打开命令行，进入依赖包所处的工作区: `src/github.com/derekparker/delve`\n\t如果你的Go版本是1.5，则运行： `GO15VENDOREXPERIMENT=1 CERT=你创建的证书名称 make install`\n\t其他版本就直接：`CERT=你创建的证书名称 make install`\n\n\n<br/>\n\n### 总结小记。\n终于折腾完了。\n花了好久时间，看了N多教程，但还是走了不少弯路。\n在 GOPATH、GOROOT理解上，在GOBIN路径唯一上，在创建签名证书处等等。\n所以，整理了一下这篇文章，希望对他人有所帮助。","slug":"Go环境搭建小记","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabeu0001veuei4surlab","content":"<hr>\n<p>Go环境搭建<br>Mac + Go1.7 + VSCode1.8</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>由于工作原因，需要学习一下Go。<br>其实，我一直就对这个语言挺感兴趣的。<br>虽说技多不压身，但贪多嚼不烂；本来想着嚼烂了客户端，再去学一学Go。<br>没关系，先提前了解一下吧。<br><br><br>这个语言，对新手真是不友好到极点。<br>搭环境废了很大功夫。</p>\n<p>先列一下我的环境：<br>Mac系统 - Go 1.7 - VSCode 1.8<br>（ IDE为什么选择VSCode？VSCode优点可以自行Google ）</p>\n<p><br></p>\n<h3 id=\"Go的设置\"><a href=\"#Go的设置\" class=\"headerlink\" title=\"Go的设置\"></a>Go的设置</h3><p>先把Go下载，然后安装到Mac。<br>然后需要配置一下环境变量</p>\n<ul>\n<li>GOROOT<br>这个是你Go安装到的位置，一般在  /usr/local/go</li>\n<li>GOPATH<br>这个是你工作区路径，一般在自建的文件夹下（这个自建的文件夹下要有3个子文件夹[src、pkg、bin]）</li>\n<li>GOBIN（选配）<br>工作区路径下的bin文件夹（<strong>路径唯一</strong>）</li>\n</ul>\n<p>当时这块就混淆了一下。<br>因为Go是支持多个工作区域的，后面我们要为Go下载一系列依赖包（就是在命令行用 go get 获得的一堆东西），如果都放在一个工作区域，就会有些混乱。<br>所以，很多人就建立两个区域，一个放依赖包，一个用来放自己平时的东西。<br>这时候，环境变量上就要有多个区域，Mac用 ‘:’ 来区隔。（依赖包默认下载到第一个工作区域）</p>\n<p>在命令行下：</p>\n<ol>\n<li>打开配置（<code>vim .bash_profile</code>） 开始搭Go环境。</li>\n<li><code>export GOPATH=&quot;/Users/你的用户名/依赖包目录:/Users/你的用户名/工作区目录&quot;</code><br>依赖包默认下载到GOPATH的第一个目录下，所以依赖包目录要放在第一个，然后用’:’分隔<br><code>export PATH=$PATH:${GOPATH//://bin:}/bin</code><br>如果设置GOBIN，GOBIN只能设置一个路径，但是你可以将每个GOPATH下的bin添加到PATH中<br><code>export PATH=$PATH:$GOPATH</code><br>路径加入到PATH</li>\n<li>保存退出，然后重启配置（source .bash_profile)</li>\n<li>输入 go env 看看Go的环境变量</li>\n</ol>\n<p><em>PS: 关于GOBIN：go install编译存放路径。不允许设置多个路径。可以为空。为空时则遵循“约定优于配置”原则，可执行文件放在各自GOPATH目录的bin文件夹中（前提是：package main的main函数文件不能直接放到GOPATH的src下面。)</em></p>\n<p><br></p>\n<h3 id=\"VSCode的配置\"><a href=\"#VSCode的配置\" class=\"headerlink\" title=\"VSCode的配置\"></a>VSCode的配置</h3><p>下载VSCode，然后在左侧小图标的最下面那个扩展选项中，搜索Go，进行下载(一般会搜索到两个go 和 Go，我下载的是第二个Go)。<br>接下来，要下载一系列的依赖包。</p>\n<h5 id=\"1-打开命令行，分别输入以下命令进行下载：\"><a href=\"#1-打开命令行，分别输入以下命令进行下载：\" class=\"headerlink\" title=\"1. 打开命令行，分别输入以下命令进行下载：\"></a>1. 打开命令行，分别输入以下命令进行下载：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u -v github.com/nsf/gocode</span><br><span class=\"line\">go get -u -v github.com/rogpeppe/godef</span><br><span class=\"line\">go get -u -v github.com/golang/lint/golint</span><br><span class=\"line\">go get -u -v github.com/lukehoban/go-outline</span><br><span class=\"line\">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class=\"line\">go get -u -v github.com/tpng/gopkgs</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/guru</span><br></pre></td></tr></table></figure>\n<p>这一步，需要  科学上网工具  的支持，而且有时候，你有科学上网工具的支持都不顶用。<br>本质上讲，以gocode为例，它将gocode相关文件下载到src，然后将它编译生成可执行文件，将可执行文件放到bin目录下。<br>所以，可以直接去github上下载下来，然后自己编译一下，将生成的可执行文件放到bin目录下。</p>\n<h5 id=\"2-配置VSCode相关\"><a href=\"#2-配置VSCode相关\" class=\"headerlink\" title=\"2. 配置VSCode相关\"></a>2. 配置VSCode相关</h5><p>主要是 settings.json 与 launch.json</p>\n<p>如果你配置了 GOPATH、GOROOT ，就不需要配置相应的setting.json。<br>（进入方法是 code -&gt; 首选项 -&gt; 用户设置）</p>\n<p>打开VSCode，选择你的工作区域文件夹，然后在编辑配置文件。（不选文件夹不能配置）<br>进入方法是 code -&gt; 首选项 -&gt; 工作区设置</p>\n<p>主要修改program字段: <code>program: &quot;${workspaceRoot}&quot;</code><br>如果你的文件，比如test.go 放在src下就： <code>program: &quot;${workspaceRoot}/src&quot;</code></p>\n<p><br></p>\n<h3 id=\"让Mac-支持-VSCode调试功能\"><a href=\"#让Mac-支持-VSCode调试功能\" class=\"headerlink\" title=\"让Mac 支持 VSCode调试功能\"></a>让Mac 支持 VSCode调试功能</h3><p>英语原文：  <a href=\"https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md\" target=\"_blank\" rel=\"noopener\">&gt;这里&lt;</a></p>\n<p><br><br>简单翻译一下步骤：</p>\n<ol>\n<li>创建一个自签名证书<br>找到钥匙串访问，（ 证书助理 -&gt; 创建证书（身份类型：自签名证书，证书类型：代码签名，勾选 覆盖这些默认值） -&gt; 继续到最后，指定用于该证书的位置: 系统 ）</li>\n<li>设定信任属性<br>重启系统后，找到自己创建的证书，在 （ 显示简介 -&gt; 信任 -&gt; 代码签名 ） 选择 （ 始终信任 ）</li>\n<li>重新编译dlv文件<br>打开命令行，进入依赖包所处的工作区: <code>src/github.com/derekparker/delve</code><br>如果你的Go版本是1.5，则运行： <code>GO15VENDOREXPERIMENT=1 CERT=你创建的证书名称 make install</code><br>其他版本就直接：<code>CERT=你创建的证书名称 make install</code></li>\n</ol>\n<p><br></p>\n<h3 id=\"总结小记。\"><a href=\"#总结小记。\" class=\"headerlink\" title=\"总结小记。\"></a>总结小记。</h3><p>终于折腾完了。<br>花了好久时间，看了N多教程，但还是走了不少弯路。<br>在 GOPATH、GOROOT理解上，在GOBIN路径唯一上，在创建签名证书处等等。<br>所以，整理了一下这篇文章，希望对他人有所帮助。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>Go环境搭建<br>Mac + Go1.7 + VSCode1.8</p>","more":"<p><br></p>\n<p>由于工作原因，需要学习一下Go。<br>其实，我一直就对这个语言挺感兴趣的。<br>虽说技多不压身，但贪多嚼不烂；本来想着嚼烂了客户端，再去学一学Go。<br>没关系，先提前了解一下吧。<br><br><br>这个语言，对新手真是不友好到极点。<br>搭环境废了很大功夫。</p>\n<p>先列一下我的环境：<br>Mac系统 - Go 1.7 - VSCode 1.8<br>（ IDE为什么选择VSCode？VSCode优点可以自行Google ）</p>\n<p><br></p>\n<h3 id=\"Go的设置\"><a href=\"#Go的设置\" class=\"headerlink\" title=\"Go的设置\"></a>Go的设置</h3><p>先把Go下载，然后安装到Mac。<br>然后需要配置一下环境变量</p>\n<ul>\n<li>GOROOT<br>这个是你Go安装到的位置，一般在  /usr/local/go</li>\n<li>GOPATH<br>这个是你工作区路径，一般在自建的文件夹下（这个自建的文件夹下要有3个子文件夹[src、pkg、bin]）</li>\n<li>GOBIN（选配）<br>工作区路径下的bin文件夹（<strong>路径唯一</strong>）</li>\n</ul>\n<p>当时这块就混淆了一下。<br>因为Go是支持多个工作区域的，后面我们要为Go下载一系列依赖包（就是在命令行用 go get 获得的一堆东西），如果都放在一个工作区域，就会有些混乱。<br>所以，很多人就建立两个区域，一个放依赖包，一个用来放自己平时的东西。<br>这时候，环境变量上就要有多个区域，Mac用 ‘:’ 来区隔。（依赖包默认下载到第一个工作区域）</p>\n<p>在命令行下：</p>\n<ol>\n<li>打开配置（<code>vim .bash_profile</code>） 开始搭Go环境。</li>\n<li><code>export GOPATH=&quot;/Users/你的用户名/依赖包目录:/Users/你的用户名/工作区目录&quot;</code><br>依赖包默认下载到GOPATH的第一个目录下，所以依赖包目录要放在第一个，然后用’:’分隔<br><code>export PATH=$PATH:${GOPATH//://bin:}/bin</code><br>如果设置GOBIN，GOBIN只能设置一个路径，但是你可以将每个GOPATH下的bin添加到PATH中<br><code>export PATH=$PATH:$GOPATH</code><br>路径加入到PATH</li>\n<li>保存退出，然后重启配置（source .bash_profile)</li>\n<li>输入 go env 看看Go的环境变量</li>\n</ol>\n<p><em>PS: 关于GOBIN：go install编译存放路径。不允许设置多个路径。可以为空。为空时则遵循“约定优于配置”原则，可执行文件放在各自GOPATH目录的bin文件夹中（前提是：package main的main函数文件不能直接放到GOPATH的src下面。)</em></p>\n<p><br></p>\n<h3 id=\"VSCode的配置\"><a href=\"#VSCode的配置\" class=\"headerlink\" title=\"VSCode的配置\"></a>VSCode的配置</h3><p>下载VSCode，然后在左侧小图标的最下面那个扩展选项中，搜索Go，进行下载(一般会搜索到两个go 和 Go，我下载的是第二个Go)。<br>接下来，要下载一系列的依赖包。</p>\n<h5 id=\"1-打开命令行，分别输入以下命令进行下载：\"><a href=\"#1-打开命令行，分别输入以下命令进行下载：\" class=\"headerlink\" title=\"1. 打开命令行，分别输入以下命令进行下载：\"></a>1. 打开命令行，分别输入以下命令进行下载：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u -v github.com/nsf/gocode</span><br><span class=\"line\">go get -u -v github.com/rogpeppe/godef</span><br><span class=\"line\">go get -u -v github.com/golang/lint/golint</span><br><span class=\"line\">go get -u -v github.com/lukehoban/go-outline</span><br><span class=\"line\">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class=\"line\">go get -u -v github.com/tpng/gopkgs</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/guru</span><br></pre></td></tr></table></figure>\n<p>这一步，需要  科学上网工具  的支持，而且有时候，你有科学上网工具的支持都不顶用。<br>本质上讲，以gocode为例，它将gocode相关文件下载到src，然后将它编译生成可执行文件，将可执行文件放到bin目录下。<br>所以，可以直接去github上下载下来，然后自己编译一下，将生成的可执行文件放到bin目录下。</p>\n<h5 id=\"2-配置VSCode相关\"><a href=\"#2-配置VSCode相关\" class=\"headerlink\" title=\"2. 配置VSCode相关\"></a>2. 配置VSCode相关</h5><p>主要是 settings.json 与 launch.json</p>\n<p>如果你配置了 GOPATH、GOROOT ，就不需要配置相应的setting.json。<br>（进入方法是 code -&gt; 首选项 -&gt; 用户设置）</p>\n<p>打开VSCode，选择你的工作区域文件夹，然后在编辑配置文件。（不选文件夹不能配置）<br>进入方法是 code -&gt; 首选项 -&gt; 工作区设置</p>\n<p>主要修改program字段: <code>program: &quot;${workspaceRoot}&quot;</code><br>如果你的文件，比如test.go 放在src下就： <code>program: &quot;${workspaceRoot}/src&quot;</code></p>\n<p><br></p>\n<h3 id=\"让Mac-支持-VSCode调试功能\"><a href=\"#让Mac-支持-VSCode调试功能\" class=\"headerlink\" title=\"让Mac 支持 VSCode调试功能\"></a>让Mac 支持 VSCode调试功能</h3><p>英语原文：  <a href=\"https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md\" target=\"_blank\" rel=\"noopener\">&gt;这里&lt;</a></p>\n<p><br><br>简单翻译一下步骤：</p>\n<ol>\n<li>创建一个自签名证书<br>找到钥匙串访问，（ 证书助理 -&gt; 创建证书（身份类型：自签名证书，证书类型：代码签名，勾选 覆盖这些默认值） -&gt; 继续到最后，指定用于该证书的位置: 系统 ）</li>\n<li>设定信任属性<br>重启系统后，找到自己创建的证书，在 （ 显示简介 -&gt; 信任 -&gt; 代码签名 ） 选择 （ 始终信任 ）</li>\n<li>重新编译dlv文件<br>打开命令行，进入依赖包所处的工作区: <code>src/github.com/derekparker/delve</code><br>如果你的Go版本是1.5，则运行： <code>GO15VENDOREXPERIMENT=1 CERT=你创建的证书名称 make install</code><br>其他版本就直接：<code>CERT=你创建的证书名称 make install</code></li>\n</ol>\n<p><br></p>\n<h3 id=\"总结小记。\"><a href=\"#总结小记。\" class=\"headerlink\" title=\"总结小记。\"></a>总结小记。</h3><p>终于折腾完了。<br>花了好久时间，看了N多教程，但还是走了不少弯路。<br>在 GOPATH、GOROOT理解上，在GOBIN路径唯一上，在创建签名证书处等等。<br>所以，整理了一下这篇文章，希望对他人有所帮助。</p>"},{"title":"Leetcode_1  Two Sum","date":"2017-03-14T14:45:35.000Z","_content":"\nLeetcode_1  Two Sum\n简单题, 映射数组\n\n<!-- more -->\n<br/>\n\n感觉，最近算法思维在退步。\n是时候练一练了，不为进步，就为了恢复并维持之前的状态。\n\n<br/>\n\n第一道题，\n给一个数组与一个和，\n求数组内哪两个数相加可以等于那个和，\n同一个数无法用两次，输出两个数的次序。\n\n第一个方法，喜（fei）闻（chang）乐（low）见（bi）的穷举遍历。\n时间复杂度O（n^2），或许是因为第一题，竟然没有超时...\n\n<br/>\n\n第二个方法，\n构造一个映射数组，默认置为-1，\n给一个数（比如7），\n立马知道它所对应的的另一个数（如果和是9，那么另一个数肯定是2），\n在那个数下存储本数的次序（arr[2] = 7的次序），\n每次读数组内的数，判断它在映射数组内的值（比如读到2，发现映射数组中值非-1），\n那么求可以得出答案。\n此方法复杂度为O(n)\n\n<br/>\n\n\n\t\t/**\n\t\t *  Index: \t1\n\t\t *  Title: \tTwo Sum\n\t\t *\tAuthor:\tltree98\n\t\t **/\n\n\t\t// O(n^2)\n\t\tclass Solution {\n\t\tpublic:\n\t\t\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\t\t\tvector<int> ans;\n\t\t\t\tfor (int i = 0; i < nums.size(); i++) {\n\t\t\t\t\tfor (int j = i + 1; j < nums.size(); j++) {\n\t\t\t\t\t\tif (nums[i] + nums[j] == target) {\n\t\t\t\t\t\t\tans.push_back(i);\n\t\t\t\t\t\t\tans.push_back(j);\n\t\t\t\t\t\t\treturn ans;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// O(n)\n\t\tclass Solution {\n\t\tpublic:\n\t\t\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\t\t\tvector<int> ans;\n\t\t\t\tint arr[100001];\n\t\t\t\tmemset(arr, -1, sizeof(arr));\n\t\t\t\tfor (int i = 0; i < nums.size(); i++) {\n\t\t\t\t\tif( arr[nums[i]] != -1 )\t{\n\t\t\t\t\t\tans.push_back(arr[nums[i]]);\n\t\t\t\t\t\tans.push_back(i);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\n\t\t\t\t\tint temp = nums[i] - target;\n\t\t\t\t\tif(temp < 0){\n\t\t\t\t\t\ttemp = -temp;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tarr[temp] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[Leetcode]_1  Two Sum.md","raw":"---\ntitle: Leetcode_1  Two Sum\ndate: 2017-03-14 22:45:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_1  Two Sum\n简单题, 映射数组\n\n<!-- more -->\n<br/>\n\n感觉，最近算法思维在退步。\n是时候练一练了，不为进步，就为了恢复并维持之前的状态。\n\n<br/>\n\n第一道题，\n给一个数组与一个和，\n求数组内哪两个数相加可以等于那个和，\n同一个数无法用两次，输出两个数的次序。\n\n第一个方法，喜（fei）闻（chang）乐（low）见（bi）的穷举遍历。\n时间复杂度O（n^2），或许是因为第一题，竟然没有超时...\n\n<br/>\n\n第二个方法，\n构造一个映射数组，默认置为-1，\n给一个数（比如7），\n立马知道它所对应的的另一个数（如果和是9，那么另一个数肯定是2），\n在那个数下存储本数的次序（arr[2] = 7的次序），\n每次读数组内的数，判断它在映射数组内的值（比如读到2，发现映射数组中值非-1），\n那么求可以得出答案。\n此方法复杂度为O(n)\n\n<br/>\n\n\n\t\t/**\n\t\t *  Index: \t1\n\t\t *  Title: \tTwo Sum\n\t\t *\tAuthor:\tltree98\n\t\t **/\n\n\t\t// O(n^2)\n\t\tclass Solution {\n\t\tpublic:\n\t\t\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\t\t\tvector<int> ans;\n\t\t\t\tfor (int i = 0; i < nums.size(); i++) {\n\t\t\t\t\tfor (int j = i + 1; j < nums.size(); j++) {\n\t\t\t\t\t\tif (nums[i] + nums[j] == target) {\n\t\t\t\t\t\t\tans.push_back(i);\n\t\t\t\t\t\t\tans.push_back(j);\n\t\t\t\t\t\t\treturn ans;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// O(n)\n\t\tclass Solution {\n\t\tpublic:\n\t\t\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\t\t\tvector<int> ans;\n\t\t\t\tint arr[100001];\n\t\t\t\tmemset(arr, -1, sizeof(arr));\n\t\t\t\tfor (int i = 0; i < nums.size(); i++) {\n\t\t\t\t\tif( arr[nums[i]] != -1 )\t{\n\t\t\t\t\t\tans.push_back(arr[nums[i]]);\n\t\t\t\t\t\tans.push_back(i);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\n\t\t\t\t\tint temp = nums[i] - target;\n\t\t\t\t\tif(temp < 0){\n\t\t\t\t\t\ttemp = -temp;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tarr[temp] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[Leetcode]_1  Two Sum","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabf80003veueshqys9p2","content":"<p>Leetcode_1  Two Sum<br>简单题, 映射数组</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>感觉，最近算法思维在退步。<br>是时候练一练了，不为进步，就为了恢复并维持之前的状态。</p>\n<p><br></p>\n<p>第一道题，<br>给一个数组与一个和，<br>求数组内哪两个数相加可以等于那个和，<br>同一个数无法用两次，输出两个数的次序。</p>\n<p>第一个方法，喜（fei）闻（chang）乐（low）见（bi）的穷举遍历。<br>时间复杂度O（n^2），或许是因为第一题，竟然没有超时…</p>\n<p><br></p>\n<p>第二个方法，<br>构造一个映射数组，默认置为-1，<br>给一个数（比如7），<br>立马知道它所对应的的另一个数（如果和是9，那么另一个数肯定是2），<br>在那个数下存储本数的次序（arr[2] = 7的次序），<br>每次读数组内的数，判断它在映射数组内的值（比如读到2，发现映射数组中值非-1），<br>那么求可以得出答案。<br>此方法复杂度为O(n)</p>\n<p><br></p>\n<pre><code>/**\n *  Index:     1\n *  Title:     Two Sum\n *    Author:    ltree98\n **/\n\n// O(n^2)\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; ans;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = i + 1; j &lt; nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    ans.push_back(i);\n                    ans.push_back(j);\n                    return ans;\n                }\n            }\n        }\n    }\n};\n\n// O(n)\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; ans;\n        int arr[100001];\n        memset(arr, -1, sizeof(arr));\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if( arr[nums[i]] != -1 )    {\n                ans.push_back(arr[nums[i]]);\n                ans.push_back(i);\n                return ans;\n            }\n\n            int temp = nums[i] - target;\n            if(temp &lt; 0){\n                temp = -temp;\n            }\n\n            arr[temp] = i;\n        }\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_1  Two Sum<br>简单题, 映射数组</p>","more":"<p><br></p>\n<p>感觉，最近算法思维在退步。<br>是时候练一练了，不为进步，就为了恢复并维持之前的状态。</p>\n<p><br></p>\n<p>第一道题，<br>给一个数组与一个和，<br>求数组内哪两个数相加可以等于那个和，<br>同一个数无法用两次，输出两个数的次序。</p>\n<p>第一个方法，喜（fei）闻（chang）乐（low）见（bi）的穷举遍历。<br>时间复杂度O（n^2），或许是因为第一题，竟然没有超时…</p>\n<p><br></p>\n<p>第二个方法，<br>构造一个映射数组，默认置为-1，<br>给一个数（比如7），<br>立马知道它所对应的的另一个数（如果和是9，那么另一个数肯定是2），<br>在那个数下存储本数的次序（arr[2] = 7的次序），<br>每次读数组内的数，判断它在映射数组内的值（比如读到2，发现映射数组中值非-1），<br>那么求可以得出答案。<br>此方法复杂度为O(n)</p>\n<p><br></p>\n<pre><code>/**\n *  Index:     1\n *  Title:     Two Sum\n *    Author:    ltree98\n **/\n\n// O(n^2)\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; ans;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = i + 1; j &lt; nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    ans.push_back(i);\n                    ans.push_back(j);\n                    return ans;\n                }\n            }\n        }\n    }\n};\n\n// O(n)\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; ans;\n        int arr[100001];\n        memset(arr, -1, sizeof(arr));\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if( arr[nums[i]] != -1 )    {\n                ans.push_back(arr[nums[i]]);\n                ans.push_back(i);\n                return ans;\n            }\n\n            int temp = nums[i] - target;\n            if(temp &lt; 0){\n                temp = -temp;\n            }\n\n            arr[temp] = i;\n        }\n    }\n};\n</code></pre>"},{"title":"Leetcode_10  Regular Expression Matching","date":"2017-04-01T07:35:11.000Z","_content":"\nLeetcode_10  Regular Expression Matching\n\n\n<!-- more -->\n<br/>\n\n        /**\n        *  Index: 10\n        *  Title: Regular Expression Matching\n        *  Author: ltree98\n        **/\n\n\n注意: \n\n\n        ab <==> .*      true\n        .* => .. => ab  \n\n\n<br/>\n\n#### 1\n\n<br/>\n\n        p.empty()   &&  s.empty() == true   =>  true\n                    &&  s.empty() == false  =>  false \n\n        s:     p:       finally:\n        a   => a*   =>  s, p.substr(2) or s.substr(1), p\n            => .*   =>  s, p.substr(2) or s.substr(1), p\n            => a    =>  s.substr(1), p.substr(1)\n            => .    =>  s.substr(1), p.substr(1)\n            => else =>  false\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            bool isMatch(string s, string p) {\n                if( p.empty() )\n                    return s.empty();\n                else if( p.length() > 1 && p[1] == '*' ) {\n                    if( (s[0] == p[0] or p[0] == '.') and !s.empty() )\n                        return (isMatch(s, p.substr(2)) or isMatch(s.substr(1), p));\n                    return isMatch(s, p.substr(2));\n                }\n                else{\n                    if( (s[0] == p[0] or p[0] == '.') and !s.empty() )\n                        return isMatch(s.substr(1), p.substr(1));\n                }\n                return false;\n            }\n        };\n\n\n<br/>\n\n#### 2.DP\n\n<br/>\n\n\n        matchArray[i][j]: matchArray[i-1][j-1] \n        p[j-1] == '*'   =>  matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && matchArray[i-1][j];\n               else     =>  matchArray[i][j] = matchArray[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n\n\n<br/>\n\n       \n        class Solution {\n        public:\n            bool isMatch(string s, string p) {\n                int sLen = s.length(), pLen = p.length();\n                bool matchArray[1001][1001];\n                matchArray[0][0] = true;\n               \n                for(int i = 1; i <= sLen; i++)\n                    matchArray[i][0] = false;\n                for(int j = 1; j <= pLen; j++)\n                    matchArray[0][j] = j > 1 && p[j-1] == '*' && matchArray[0][j-2];\n        \n                for(int i = 1; i <= sLen; i++)  {\n                    for(int j = 1; j <= pLen; j++)  {\n                        if( p[j-1] == '*' )\n                            matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && matchArray[i-1][j];\n                        else \n                            matchArray[i][j] = matchArray[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                    }\n                }\n        \n                return matchArray[sLen][pLen];\n            }\n        };","source":"_posts/[Leetcode]_10  Regular Expression Matching.md","raw":"---\ntitle: Leetcode_10  Regular Expression Matching\ndate: 2017-04-01 15:35:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_10  Regular Expression Matching\n\n\n<!-- more -->\n<br/>\n\n        /**\n        *  Index: 10\n        *  Title: Regular Expression Matching\n        *  Author: ltree98\n        **/\n\n\n注意: \n\n\n        ab <==> .*      true\n        .* => .. => ab  \n\n\n<br/>\n\n#### 1\n\n<br/>\n\n        p.empty()   &&  s.empty() == true   =>  true\n                    &&  s.empty() == false  =>  false \n\n        s:     p:       finally:\n        a   => a*   =>  s, p.substr(2) or s.substr(1), p\n            => .*   =>  s, p.substr(2) or s.substr(1), p\n            => a    =>  s.substr(1), p.substr(1)\n            => .    =>  s.substr(1), p.substr(1)\n            => else =>  false\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            bool isMatch(string s, string p) {\n                if( p.empty() )\n                    return s.empty();\n                else if( p.length() > 1 && p[1] == '*' ) {\n                    if( (s[0] == p[0] or p[0] == '.') and !s.empty() )\n                        return (isMatch(s, p.substr(2)) or isMatch(s.substr(1), p));\n                    return isMatch(s, p.substr(2));\n                }\n                else{\n                    if( (s[0] == p[0] or p[0] == '.') and !s.empty() )\n                        return isMatch(s.substr(1), p.substr(1));\n                }\n                return false;\n            }\n        };\n\n\n<br/>\n\n#### 2.DP\n\n<br/>\n\n\n        matchArray[i][j]: matchArray[i-1][j-1] \n        p[j-1] == '*'   =>  matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && matchArray[i-1][j];\n               else     =>  matchArray[i][j] = matchArray[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n\n\n<br/>\n\n       \n        class Solution {\n        public:\n            bool isMatch(string s, string p) {\n                int sLen = s.length(), pLen = p.length();\n                bool matchArray[1001][1001];\n                matchArray[0][0] = true;\n               \n                for(int i = 1; i <= sLen; i++)\n                    matchArray[i][0] = false;\n                for(int j = 1; j <= pLen; j++)\n                    matchArray[0][j] = j > 1 && p[j-1] == '*' && matchArray[0][j-2];\n        \n                for(int i = 1; i <= sLen; i++)  {\n                    for(int j = 1; j <= pLen; j++)  {\n                        if( p[j-1] == '*' )\n                            matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && matchArray[i-1][j];\n                        else \n                            matchArray[i][j] = matchArray[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                    }\n                }\n        \n                return matchArray[sLen][pLen];\n            }\n        };","slug":"[Leetcode]_10  Regular Expression Matching","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabfe0004veueblbhoze5","content":"<p>Leetcode_10  Regular Expression Matching</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 10\n*  Title: Regular Expression Matching\n*  Author: ltree98\n**/\n</code></pre><p>注意: </p>\n<pre><code>ab &lt;==&gt; .*      true\n.* =&gt; .. =&gt; ab  \n</code></pre><p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p><br></p>\n<pre><code>p.empty()   &amp;&amp;  s.empty() == true   =&gt;  true\n            &amp;&amp;  s.empty() == false  =&gt;  false \n\ns:     p:       finally:\na   =&gt; a*   =&gt;  s, p.substr(2) or s.substr(1), p\n    =&gt; .*   =&gt;  s, p.substr(2) or s.substr(1), p\n    =&gt; a    =&gt;  s.substr(1), p.substr(1)\n    =&gt; .    =&gt;  s.substr(1), p.substr(1)\n    =&gt; else =&gt;  false\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if( p.empty() )\n            return s.empty();\n        else if( p.length() &gt; 1 &amp;&amp; p[1] == &apos;*&apos; ) {\n            if( (s[0] == p[0] or p[0] == &apos;.&apos;) and !s.empty() )\n                return (isMatch(s, p.substr(2)) or isMatch(s.substr(1), p));\n            return isMatch(s, p.substr(2));\n        }\n        else{\n            if( (s[0] == p[0] or p[0] == &apos;.&apos;) and !s.empty() )\n                return isMatch(s.substr(1), p.substr(1));\n        }\n        return false;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2-DP\"><a href=\"#2-DP\" class=\"headerlink\" title=\"2.DP\"></a>2.DP</h4><p><br></p>\n<pre><code>matchArray[i][j]: matchArray[i-1][j-1] \np[j-1] == &apos;*&apos;   =&gt;  matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == &apos;.&apos;) &amp;&amp; matchArray[i-1][j];\n       else     =&gt;  matchArray[i][j] = matchArray[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;);\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int sLen = s.length(), pLen = p.length();\n        bool matchArray[1001][1001];\n        matchArray[0][0] = true;\n\n        for(int i = 1; i &lt;= sLen; i++)\n            matchArray[i][0] = false;\n        for(int j = 1; j &lt;= pLen; j++)\n            matchArray[0][j] = j &gt; 1 &amp;&amp; p[j-1] == &apos;*&apos; &amp;&amp; matchArray[0][j-2];\n\n        for(int i = 1; i &lt;= sLen; i++)  {\n            for(int j = 1; j &lt;= pLen; j++)  {\n                if( p[j-1] == &apos;*&apos; )\n                    matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == &apos;.&apos;) &amp;&amp; matchArray[i-1][j];\n                else \n                    matchArray[i][j] = matchArray[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;);\n            }\n        }\n\n        return matchArray[sLen][pLen];\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_10  Regular Expression Matching</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 10\n*  Title: Regular Expression Matching\n*  Author: ltree98\n**/\n</code></pre><p>注意: </p>\n<pre><code>ab &lt;==&gt; .*      true\n.* =&gt; .. =&gt; ab  \n</code></pre><p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p><br></p>\n<pre><code>p.empty()   &amp;&amp;  s.empty() == true   =&gt;  true\n            &amp;&amp;  s.empty() == false  =&gt;  false \n\ns:     p:       finally:\na   =&gt; a*   =&gt;  s, p.substr(2) or s.substr(1), p\n    =&gt; .*   =&gt;  s, p.substr(2) or s.substr(1), p\n    =&gt; a    =&gt;  s.substr(1), p.substr(1)\n    =&gt; .    =&gt;  s.substr(1), p.substr(1)\n    =&gt; else =&gt;  false\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if( p.empty() )\n            return s.empty();\n        else if( p.length() &gt; 1 &amp;&amp; p[1] == &apos;*&apos; ) {\n            if( (s[0] == p[0] or p[0] == &apos;.&apos;) and !s.empty() )\n                return (isMatch(s, p.substr(2)) or isMatch(s.substr(1), p));\n            return isMatch(s, p.substr(2));\n        }\n        else{\n            if( (s[0] == p[0] or p[0] == &apos;.&apos;) and !s.empty() )\n                return isMatch(s.substr(1), p.substr(1));\n        }\n        return false;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2-DP\"><a href=\"#2-DP\" class=\"headerlink\" title=\"2.DP\"></a>2.DP</h4><p><br></p>\n<pre><code>matchArray[i][j]: matchArray[i-1][j-1] \np[j-1] == &apos;*&apos;   =&gt;  matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == &apos;.&apos;) &amp;&amp; matchArray[i-1][j];\n       else     =&gt;  matchArray[i][j] = matchArray[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;);\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int sLen = s.length(), pLen = p.length();\n        bool matchArray[1001][1001];\n        matchArray[0][0] = true;\n\n        for(int i = 1; i &lt;= sLen; i++)\n            matchArray[i][0] = false;\n        for(int j = 1; j &lt;= pLen; j++)\n            matchArray[0][j] = j &gt; 1 &amp;&amp; p[j-1] == &apos;*&apos; &amp;&amp; matchArray[0][j-2];\n\n        for(int i = 1; i &lt;= sLen; i++)  {\n            for(int j = 1; j &lt;= pLen; j++)  {\n                if( p[j-1] == &apos;*&apos; )\n                    matchArray[i][j] = matchArray[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == &apos;.&apos;) &amp;&amp; matchArray[i-1][j];\n                else \n                    matchArray[i][j] = matchArray[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;);\n            }\n        }\n\n        return matchArray[sLen][pLen];\n    }\n};\n</code></pre>"},{"title":"Leetcode_11  Container With Most Water","date":"2017-04-05T14:12:11.000Z","_content":"\nLeetcode_11  Container With Most Water\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 11\n        *  Title: Container With Most Water\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n题意做一个容器来存水 => 求两条线所构成的最大矩形\n\n根据数组 [7,6,2,3,1]\n先将数组根据索引和内容，构成一个点(注意索引从1开始)     =>  (1,7)、(2,6)、(3,2)、(4,3)、(5,1)\n然后将这些点分别与各自(索引,0)构成的点连接。            =>  (1,7) 与 (1,0); (2,6) 与 (2,0) 等\n其实，画一个坐标系，把点标记上就特别明显了。\n题目中提示了，容器不可以倾斜，意思就是，长方形的宽度是取两条线段的较短边。\n\n当然，O(n^2) 是超时的。（我不会说我傻呵呵的试了，而且还剪枝了）\n\n其实就是求矩形的面积，矩形的面积是由 长与宽来决定的。\n因此，我们从两边开始聚拢到中间，保证了长度由最长到最短，保证长度的前提求面积，\n然后再以缩短长度的代价，去寻找更长的宽度，再求面积。\n这期间就一定会出现最大的面积。\n\n\n\n        class Solution {\n        public:\n            int maxArea(vector<int>& height) {\n                int maxWater = 0;\n                int h = 0, left = 0, right = height.size()-1;\n        \n                while(left < right) {\n                    if(height[left] < height[right])\n                        h = height[left++];\n                    else\n                        h = height[right--];\n                    maxWater = max(maxWater, (right-left+1)*h);\n                }\n        \n                return maxWater;\n            }\n        };\n","source":"_posts/[Leetcode]_11  Container With Most Water.md","raw":"---\ntitle: Leetcode_11  Container With Most Water\ndate: 2017-04-05 22:12:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_11  Container With Most Water\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 11\n        *  Title: Container With Most Water\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n题意做一个容器来存水 => 求两条线所构成的最大矩形\n\n根据数组 [7,6,2,3,1]\n先将数组根据索引和内容，构成一个点(注意索引从1开始)     =>  (1,7)、(2,6)、(3,2)、(4,3)、(5,1)\n然后将这些点分别与各自(索引,0)构成的点连接。            =>  (1,7) 与 (1,0); (2,6) 与 (2,0) 等\n其实，画一个坐标系，把点标记上就特别明显了。\n题目中提示了，容器不可以倾斜，意思就是，长方形的宽度是取两条线段的较短边。\n\n当然，O(n^2) 是超时的。（我不会说我傻呵呵的试了，而且还剪枝了）\n\n其实就是求矩形的面积，矩形的面积是由 长与宽来决定的。\n因此，我们从两边开始聚拢到中间，保证了长度由最长到最短，保证长度的前提求面积，\n然后再以缩短长度的代价，去寻找更长的宽度，再求面积。\n这期间就一定会出现最大的面积。\n\n\n\n        class Solution {\n        public:\n            int maxArea(vector<int>& height) {\n                int maxWater = 0;\n                int h = 0, left = 0, right = height.size()-1;\n        \n                while(left < right) {\n                    if(height[left] < height[right])\n                        h = height[left++];\n                    else\n                        h = height[right--];\n                    maxWater = max(maxWater, (right-left+1)*h);\n                }\n        \n                return maxWater;\n            }\n        };\n","slug":"[Leetcode]_11  Container With Most Water","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabfh0005veuewt7g5v9i","content":"<p>Leetcode_11  Container With Most Water</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 11\n*  Title: Container With Most Water\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意做一个容器来存水 =&gt; 求两条线所构成的最大矩形</p>\n<p>根据数组 [7,6,2,3,1]<br>先将数组根据索引和内容，构成一个点(注意索引从1开始)     =&gt;  (1,7)、(2,6)、(3,2)、(4,3)、(5,1)<br>然后将这些点分别与各自(索引,0)构成的点连接。            =&gt;  (1,7) 与 (1,0); (2,6) 与 (2,0) 等<br>其实，画一个坐标系，把点标记上就特别明显了。<br>题目中提示了，容器不可以倾斜，意思就是，长方形的宽度是取两条线段的较短边。</p>\n<p>当然，O(n^2) 是超时的。（我不会说我傻呵呵的试了，而且还剪枝了）</p>\n<p>其实就是求矩形的面积，矩形的面积是由 长与宽来决定的。<br>因此，我们从两边开始聚拢到中间，保证了长度由最长到最短，保证长度的前提求面积，<br>然后再以缩短长度的代价，去寻找更长的宽度，再求面积。<br>这期间就一定会出现最大的面积。</p>\n<pre><code>class Solution {\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) {\n        int maxWater = 0;\n        int h = 0, left = 0, right = height.size()-1;\n\n        while(left &lt; right) {\n            if(height[left] &lt; height[right])\n                h = height[left++];\n            else\n                h = height[right--];\n            maxWater = max(maxWater, (right-left+1)*h);\n        }\n\n        return maxWater;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_11  Container With Most Water</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 11\n*  Title: Container With Most Water\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意做一个容器来存水 =&gt; 求两条线所构成的最大矩形</p>\n<p>根据数组 [7,6,2,3,1]<br>先将数组根据索引和内容，构成一个点(注意索引从1开始)     =&gt;  (1,7)、(2,6)、(3,2)、(4,3)、(5,1)<br>然后将这些点分别与各自(索引,0)构成的点连接。            =&gt;  (1,7) 与 (1,0); (2,6) 与 (2,0) 等<br>其实，画一个坐标系，把点标记上就特别明显了。<br>题目中提示了，容器不可以倾斜，意思就是，长方形的宽度是取两条线段的较短边。</p>\n<p>当然，O(n^2) 是超时的。（我不会说我傻呵呵的试了，而且还剪枝了）</p>\n<p>其实就是求矩形的面积，矩形的面积是由 长与宽来决定的。<br>因此，我们从两边开始聚拢到中间，保证了长度由最长到最短，保证长度的前提求面积，<br>然后再以缩短长度的代价，去寻找更长的宽度，再求面积。<br>这期间就一定会出现最大的面积。</p>\n<pre><code>class Solution {\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) {\n        int maxWater = 0;\n        int h = 0, left = 0, right = height.size()-1;\n\n        while(left &lt; right) {\n            if(height[left] &lt; height[right])\n                h = height[left++];\n            else\n                h = height[right--];\n            maxWater = max(maxWater, (right-left+1)*h);\n        }\n\n        return maxWater;\n    }\n};\n</code></pre>"},{"title":"Leetcode_12  Integer to Roman","date":"2017-04-05T14:20:11.000Z","_content":"\nLeetcode_12  Integer to Roman\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 12\n        *  Title: Integer to Roman\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码。\n罗马数字采用七个罗马字母作数字,即Ⅰ(1)、X(10)、C (100)、M (1000),V (5)、L(50)、D (500)。\n记数的方法:\n(1)相同的数字连写,所表示的数等于这些数字相加得到的数,如, Ⅲ = 3；\n(2)小的数字在大的数字的右边,所表示的数等于这些数字相加得到的数, 如,Ⅷ = 8,Ⅻ = 12；\n(3)小的数字,(限于Ⅰ、X 和 C)在大的数字的左边,所表示的数等于大数减小数得到的数,如,Ⅳ = 4,Ⅸ = 9；\n(4)在一个数的上面画一条横线,表示这个数增值 1 000 倍,如 Ⅻ = 12 000 。\n\n罗马数字的组数规则,有几条须注意掌握；\n(1)基本数字Ⅰ、X 、C 中的任何一个,自身连用构成数目,或者放在大数的右边连用构成数目,都不能超过三个；放在大数的左边只能用一个。\n(2)不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目,只能使用一个。\n(3)V 和 X 左边的小数字只能用Ⅰ。\n(4)L 和 C 左边的小数字只能用X。\n(5)D 和 M 左边的小数字只能用C 。\n\n<br/>\n\n####  解法1\n\n先找了找规律，\n发现一个数可以拆分成下面这种形式：\n2143 = 2*1000 + 1*100 + 4*10 + 3*1\n\n对于不同阶位的 1、5、10 所对应的罗马字符不同：\n\n\n\n        阶位  1       5       10\n        个位  I       V       X\n        十位  X       L       C\n        百位  C       D       M\n        千位  M\n\n\n\n综上所述，\n做两张映射表，\n第一个，1-9所对应的罗马数模板，\n第二个，阶位的1，5，10所对应的字符，\n然后进行字符串查找替换。\n\n\n<br/>\n\n\n\n        class Solution {\n        private:\n            string numTemplate[11] = {\"\", \"F\", \"FF\", \"FFF\", \"FS\", \"S\", \"SF\", \"SFF\", \"SFFF\", \"FT\"};\n            char orderTemplate[4][3] = {'I', 'V', 'X',\n                                        'X', 'L', 'C',\n                                        'C', 'D', 'M',\n                                        'M', 'M', 'M'};\n        \n        \n        public:\n            string numByOther(int num, int order)   {\n                char fO = orderTemplate[order][0];\n                char sO = orderTemplate[order][1];\n                char tO = orderTemplate[order][2];\n        \n                string temp = numTemplate[num];\n                for(int i = 0; i < temp.length(); i++)  {\n                    if(temp[i] == 'F')\n                        temp[i] = fO;\n                    else if(temp[i] == 'S')\n                        temp[i] = sO;\n                    else if(temp[i] == 'T')\n                        temp[i] = tO;\n                }\n        \n                return temp;\n            }\n        \n            string intToRoman(int num) {\n                string ans = \"\";\n                int order = 0;\n                while(num > 0)  {\n                    int temp = num%10;\n                    string sTemp = numByOther(temp, order);\n                    ans = sTemp + ans;\n                    num /= 10;\n                    ++order;\n                }\n        \n                return ans;\n            }\n        };\n\n\n\n<br/>\n\n#### 解法2:贪心\n\n\n从大数往后依次计算能不能替换，如果能替换，并减去所替换的数的值，再继续替换到最后。\n\n举个小例子，7\n10 - X, 5 - V, 4 - IV, 1 - I\n从最大的数10, 7无法用10来替换,\n所以用后面的5, 5可以替换,         答案:V    数字:2(7-5)\n2小于5, 小于4, 无法用5和4替换,\n但可以用1来替换:   答案:VI       数字:1(2-1)\n还可以用1来替换:   答案:VII  数字:0(1-1)\n数字归0, 返回答案: VII\n\n<br/>\n\n\n        class Solution {\n        public:\n            string intToRoman(int num) {\n                int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n                string valueToRoman[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n                string ans = \"\";\n                for(int i = 0; i < 13; i++) {\n                    while(num >= values[i]) {\n                        num -= values[i];\n                        ans = ans + valueToRoman[i];\n                    }\n                }\n        \n                return ans;\n            }\n        };","source":"_posts/[Leetcode]_12  Integer to Roman.md","raw":"---\ntitle: Leetcode_12  Integer to Roman\ndate: 2017-04-05 22:20:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_12  Integer to Roman\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 12\n        *  Title: Integer to Roman\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码。\n罗马数字采用七个罗马字母作数字,即Ⅰ(1)、X(10)、C (100)、M (1000),V (5)、L(50)、D (500)。\n记数的方法:\n(1)相同的数字连写,所表示的数等于这些数字相加得到的数,如, Ⅲ = 3；\n(2)小的数字在大的数字的右边,所表示的数等于这些数字相加得到的数, 如,Ⅷ = 8,Ⅻ = 12；\n(3)小的数字,(限于Ⅰ、X 和 C)在大的数字的左边,所表示的数等于大数减小数得到的数,如,Ⅳ = 4,Ⅸ = 9；\n(4)在一个数的上面画一条横线,表示这个数增值 1 000 倍,如 Ⅻ = 12 000 。\n\n罗马数字的组数规则,有几条须注意掌握；\n(1)基本数字Ⅰ、X 、C 中的任何一个,自身连用构成数目,或者放在大数的右边连用构成数目,都不能超过三个；放在大数的左边只能用一个。\n(2)不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目,只能使用一个。\n(3)V 和 X 左边的小数字只能用Ⅰ。\n(4)L 和 C 左边的小数字只能用X。\n(5)D 和 M 左边的小数字只能用C 。\n\n<br/>\n\n####  解法1\n\n先找了找规律，\n发现一个数可以拆分成下面这种形式：\n2143 = 2*1000 + 1*100 + 4*10 + 3*1\n\n对于不同阶位的 1、5、10 所对应的罗马字符不同：\n\n\n\n        阶位  1       5       10\n        个位  I       V       X\n        十位  X       L       C\n        百位  C       D       M\n        千位  M\n\n\n\n综上所述，\n做两张映射表，\n第一个，1-9所对应的罗马数模板，\n第二个，阶位的1，5，10所对应的字符，\n然后进行字符串查找替换。\n\n\n<br/>\n\n\n\n        class Solution {\n        private:\n            string numTemplate[11] = {\"\", \"F\", \"FF\", \"FFF\", \"FS\", \"S\", \"SF\", \"SFF\", \"SFFF\", \"FT\"};\n            char orderTemplate[4][3] = {'I', 'V', 'X',\n                                        'X', 'L', 'C',\n                                        'C', 'D', 'M',\n                                        'M', 'M', 'M'};\n        \n        \n        public:\n            string numByOther(int num, int order)   {\n                char fO = orderTemplate[order][0];\n                char sO = orderTemplate[order][1];\n                char tO = orderTemplate[order][2];\n        \n                string temp = numTemplate[num];\n                for(int i = 0; i < temp.length(); i++)  {\n                    if(temp[i] == 'F')\n                        temp[i] = fO;\n                    else if(temp[i] == 'S')\n                        temp[i] = sO;\n                    else if(temp[i] == 'T')\n                        temp[i] = tO;\n                }\n        \n                return temp;\n            }\n        \n            string intToRoman(int num) {\n                string ans = \"\";\n                int order = 0;\n                while(num > 0)  {\n                    int temp = num%10;\n                    string sTemp = numByOther(temp, order);\n                    ans = sTemp + ans;\n                    num /= 10;\n                    ++order;\n                }\n        \n                return ans;\n            }\n        };\n\n\n\n<br/>\n\n#### 解法2:贪心\n\n\n从大数往后依次计算能不能替换，如果能替换，并减去所替换的数的值，再继续替换到最后。\n\n举个小例子，7\n10 - X, 5 - V, 4 - IV, 1 - I\n从最大的数10, 7无法用10来替换,\n所以用后面的5, 5可以替换,         答案:V    数字:2(7-5)\n2小于5, 小于4, 无法用5和4替换,\n但可以用1来替换:   答案:VI       数字:1(2-1)\n还可以用1来替换:   答案:VII  数字:0(1-1)\n数字归0, 返回答案: VII\n\n<br/>\n\n\n        class Solution {\n        public:\n            string intToRoman(int num) {\n                int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n                string valueToRoman[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n                string ans = \"\";\n                for(int i = 0; i < 13; i++) {\n                    while(num >= values[i]) {\n                        num -= values[i];\n                        ans = ans + valueToRoman[i];\n                    }\n                }\n        \n                return ans;\n            }\n        };","slug":"[Leetcode]_12  Integer to Roman","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabfn0008veuegp0dsow2","content":"<p>Leetcode_12  Integer to Roman</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 12\n*  Title: Integer to Roman\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码。<br>罗马数字采用七个罗马字母作数字,即Ⅰ(1)、X(10)、C (100)、M (1000),V (5)、L(50)、D (500)。<br>记数的方法:<br>(1)相同的数字连写,所表示的数等于这些数字相加得到的数,如, Ⅲ = 3；<br>(2)小的数字在大的数字的右边,所表示的数等于这些数字相加得到的数, 如,Ⅷ = 8,Ⅻ = 12；<br>(3)小的数字,(限于Ⅰ、X 和 C)在大的数字的左边,所表示的数等于大数减小数得到的数,如,Ⅳ = 4,Ⅸ = 9；<br>(4)在一个数的上面画一条横线,表示这个数增值 1 000 倍,如 Ⅻ = 12 000 。</p>\n<p>罗马数字的组数规则,有几条须注意掌握；<br>(1)基本数字Ⅰ、X 、C 中的任何一个,自身连用构成数目,或者放在大数的右边连用构成数目,都不能超过三个；放在大数的左边只能用一个。<br>(2)不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目,只能使用一个。<br>(3)V 和 X 左边的小数字只能用Ⅰ。<br>(4)L 和 C 左边的小数字只能用X。<br>(5)D 和 M 左边的小数字只能用C 。</p>\n<p><br></p>\n<h4 id=\"解法1\"><a href=\"#解法1\" class=\"headerlink\" title=\"解法1\"></a>解法1</h4><p>先找了找规律，<br>发现一个数可以拆分成下面这种形式：<br>2143 = 2<em>1000 + 1</em>100 + 4<em>10 + 3</em>1</p>\n<p>对于不同阶位的 1、5、10 所对应的罗马字符不同：</p>\n<pre><code>阶位  1       5       10\n个位  I       V       X\n十位  X       L       C\n百位  C       D       M\n千位  M\n</code></pre><p>综上所述，<br>做两张映射表，<br>第一个，1-9所对应的罗马数模板，<br>第二个，阶位的1，5，10所对应的字符，<br>然后进行字符串查找替换。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    string numTemplate[11] = {&quot;&quot;, &quot;F&quot;, &quot;FF&quot;, &quot;FFF&quot;, &quot;FS&quot;, &quot;S&quot;, &quot;SF&quot;, &quot;SFF&quot;, &quot;SFFF&quot;, &quot;FT&quot;};\n    char orderTemplate[4][3] = {&apos;I&apos;, &apos;V&apos;, &apos;X&apos;,\n                                &apos;X&apos;, &apos;L&apos;, &apos;C&apos;,\n                                &apos;C&apos;, &apos;D&apos;, &apos;M&apos;,\n                                &apos;M&apos;, &apos;M&apos;, &apos;M&apos;};\n\n\npublic:\n    string numByOther(int num, int order)   {\n        char fO = orderTemplate[order][0];\n        char sO = orderTemplate[order][1];\n        char tO = orderTemplate[order][2];\n\n        string temp = numTemplate[num];\n        for(int i = 0; i &lt; temp.length(); i++)  {\n            if(temp[i] == &apos;F&apos;)\n                temp[i] = fO;\n            else if(temp[i] == &apos;S&apos;)\n                temp[i] = sO;\n            else if(temp[i] == &apos;T&apos;)\n                temp[i] = tO;\n        }\n\n        return temp;\n    }\n\n    string intToRoman(int num) {\n        string ans = &quot;&quot;;\n        int order = 0;\n        while(num &gt; 0)  {\n            int temp = num%10;\n            string sTemp = numByOther(temp, order);\n            ans = sTemp + ans;\n            num /= 10;\n            ++order;\n        }\n\n        return ans;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"解法2-贪心\"><a href=\"#解法2-贪心\" class=\"headerlink\" title=\"解法2:贪心\"></a>解法2:贪心</h4><p>从大数往后依次计算能不能替换，如果能替换，并减去所替换的数的值，再继续替换到最后。</p>\n<p>举个小例子，7<br>10 - X, 5 - V, 4 - IV, 1 - I<br>从最大的数10, 7无法用10来替换,<br>所以用后面的5, 5可以替换,         答案:V    数字:2(7-5)<br>2小于5, 小于4, 无法用5和4替换,<br>但可以用1来替换:   答案:VI       数字:1(2-1)<br>还可以用1来替换:   答案:VII  数字:0(1-1)<br>数字归0, 返回答案: VII</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string intToRoman(int num) {\n        int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string valueToRoman[13] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};\n\n        string ans = &quot;&quot;;\n        for(int i = 0; i &lt; 13; i++) {\n            while(num &gt;= values[i]) {\n                num -= values[i];\n                ans = ans + valueToRoman[i];\n            }\n        }\n\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_12  Integer to Roman</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 12\n*  Title: Integer to Roman\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>罗马数字是欧洲在阿拉伯数字传入之前使用的一种数码。<br>罗马数字采用七个罗马字母作数字,即Ⅰ(1)、X(10)、C (100)、M (1000),V (5)、L(50)、D (500)。<br>记数的方法:<br>(1)相同的数字连写,所表示的数等于这些数字相加得到的数,如, Ⅲ = 3；<br>(2)小的数字在大的数字的右边,所表示的数等于这些数字相加得到的数, 如,Ⅷ = 8,Ⅻ = 12；<br>(3)小的数字,(限于Ⅰ、X 和 C)在大的数字的左边,所表示的数等于大数减小数得到的数,如,Ⅳ = 4,Ⅸ = 9；<br>(4)在一个数的上面画一条横线,表示这个数增值 1 000 倍,如 Ⅻ = 12 000 。</p>\n<p>罗马数字的组数规则,有几条须注意掌握；<br>(1)基本数字Ⅰ、X 、C 中的任何一个,自身连用构成数目,或者放在大数的右边连用构成数目,都不能超过三个；放在大数的左边只能用一个。<br>(2)不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目,只能使用一个。<br>(3)V 和 X 左边的小数字只能用Ⅰ。<br>(4)L 和 C 左边的小数字只能用X。<br>(5)D 和 M 左边的小数字只能用C 。</p>\n<p><br></p>\n<h4 id=\"解法1\"><a href=\"#解法1\" class=\"headerlink\" title=\"解法1\"></a>解法1</h4><p>先找了找规律，<br>发现一个数可以拆分成下面这种形式：<br>2143 = 2<em>1000 + 1</em>100 + 4<em>10 + 3</em>1</p>\n<p>对于不同阶位的 1、5、10 所对应的罗马字符不同：</p>\n<pre><code>阶位  1       5       10\n个位  I       V       X\n十位  X       L       C\n百位  C       D       M\n千位  M\n</code></pre><p>综上所述，<br>做两张映射表，<br>第一个，1-9所对应的罗马数模板，<br>第二个，阶位的1，5，10所对应的字符，<br>然后进行字符串查找替换。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    string numTemplate[11] = {&quot;&quot;, &quot;F&quot;, &quot;FF&quot;, &quot;FFF&quot;, &quot;FS&quot;, &quot;S&quot;, &quot;SF&quot;, &quot;SFF&quot;, &quot;SFFF&quot;, &quot;FT&quot;};\n    char orderTemplate[4][3] = {&apos;I&apos;, &apos;V&apos;, &apos;X&apos;,\n                                &apos;X&apos;, &apos;L&apos;, &apos;C&apos;,\n                                &apos;C&apos;, &apos;D&apos;, &apos;M&apos;,\n                                &apos;M&apos;, &apos;M&apos;, &apos;M&apos;};\n\n\npublic:\n    string numByOther(int num, int order)   {\n        char fO = orderTemplate[order][0];\n        char sO = orderTemplate[order][1];\n        char tO = orderTemplate[order][2];\n\n        string temp = numTemplate[num];\n        for(int i = 0; i &lt; temp.length(); i++)  {\n            if(temp[i] == &apos;F&apos;)\n                temp[i] = fO;\n            else if(temp[i] == &apos;S&apos;)\n                temp[i] = sO;\n            else if(temp[i] == &apos;T&apos;)\n                temp[i] = tO;\n        }\n\n        return temp;\n    }\n\n    string intToRoman(int num) {\n        string ans = &quot;&quot;;\n        int order = 0;\n        while(num &gt; 0)  {\n            int temp = num%10;\n            string sTemp = numByOther(temp, order);\n            ans = sTemp + ans;\n            num /= 10;\n            ++order;\n        }\n\n        return ans;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"解法2-贪心\"><a href=\"#解法2-贪心\" class=\"headerlink\" title=\"解法2:贪心\"></a>解法2:贪心</h4><p>从大数往后依次计算能不能替换，如果能替换，并减去所替换的数的值，再继续替换到最后。</p>\n<p>举个小例子，7<br>10 - X, 5 - V, 4 - IV, 1 - I<br>从最大的数10, 7无法用10来替换,<br>所以用后面的5, 5可以替换,         答案:V    数字:2(7-5)<br>2小于5, 小于4, 无法用5和4替换,<br>但可以用1来替换:   答案:VI       数字:1(2-1)<br>还可以用1来替换:   答案:VII  数字:0(1-1)<br>数字归0, 返回答案: VII</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string intToRoman(int num) {\n        int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string valueToRoman[13] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};\n\n        string ans = &quot;&quot;;\n        for(int i = 0; i &lt; 13; i++) {\n            while(num &gt;= values[i]) {\n                num -= values[i];\n                ans = ans + valueToRoman[i];\n            }\n        }\n\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_13  Roman to Integer","date":"2017-04-10T14:03:11.000Z","_content":"\nLeetcode_13  Roman to Integer\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 13\n        *  Title: Roman to Integer\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n#### 1\n\n<br/>\n\n之前是数字转罗马数，现在反过来了，罗马数转数字。（1~3999）\n思路同数字转罗马，\n将 valueToRoman数组从第一个比较到最后一个，然后符合情况时将对应的值加起来。\n\n<br/>\n\n\n        class Solution {\n        public:\n            int romanToInt(string s) {\n                int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n                string valueToRoman[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n                int startPos = 0, len = s.length();\n                int ans = 0;\n                for(int i = 0; i < 13; i++) {\n                    while( startPos < len ) {\n                        string tempS = s.substr(startPos, valueToRoman[i].length());\n                        if(tempS == valueToRoman[i])    {\n                            ans += values[i];\n                            startPos = startPos + tempS.length();\n                        }\n                        else\n                            break;\n                    }\n                }\n                return ans;        \n            }\n        };\n\n\n<br/>\n\n#### 2\n\n<br/>\n\n在讨论组又发现一个更简单的。\n根据罗马数的规则：小的数放在右边是加小的数，小的数放在左边是减去小的数。\n所以就从右向左把数字加起来，如果发现当前的数比右边的数小，就减去这个数的值。\n比如: IXVI\nI -> V -> X 每个都比右面的数字大（V > I, X > V), 所以 XVI就是 10 + 5 + 1 = 16。\n但是，接下来 I < X, 这时候就需要将总和把 I 的这部分减去： IXVI = 16 - 1 = 15。\n这个例子只是为了说明方法， 正常来说15 应该是 XV 。\n\n<br/>\n\n\n        class Solution {\n        private:\n            map<char, int> comparedMap = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };\n        \n        public:\n            int romanToInt(string s) {        \n                int ans = comparedMap[s[s.length()-1]];\n        \n                for(int i = s.length()-2; i >= 0; i--)  {\n                    if( comparedMap[s[i+1]] > comparedMap[s[i]] )   {\n                        ans -= comparedMap[s[i]];\n                    }\n                    else    {\n                        ans += comparedMap[s[i]];\n                    }\n                }\n        \n                return ans;        \n            }\n        };","source":"_posts/[Leetcode]_13  Roman to Integer.md","raw":"---\ntitle: Leetcode_13  Roman to Integer\ndate: 2017-04-10 22:03:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_13  Roman to Integer\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 13\n        *  Title: Roman to Integer\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n#### 1\n\n<br/>\n\n之前是数字转罗马数，现在反过来了，罗马数转数字。（1~3999）\n思路同数字转罗马，\n将 valueToRoman数组从第一个比较到最后一个，然后符合情况时将对应的值加起来。\n\n<br/>\n\n\n        class Solution {\n        public:\n            int romanToInt(string s) {\n                int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n                string valueToRoman[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n                int startPos = 0, len = s.length();\n                int ans = 0;\n                for(int i = 0; i < 13; i++) {\n                    while( startPos < len ) {\n                        string tempS = s.substr(startPos, valueToRoman[i].length());\n                        if(tempS == valueToRoman[i])    {\n                            ans += values[i];\n                            startPos = startPos + tempS.length();\n                        }\n                        else\n                            break;\n                    }\n                }\n                return ans;        \n            }\n        };\n\n\n<br/>\n\n#### 2\n\n<br/>\n\n在讨论组又发现一个更简单的。\n根据罗马数的规则：小的数放在右边是加小的数，小的数放在左边是减去小的数。\n所以就从右向左把数字加起来，如果发现当前的数比右边的数小，就减去这个数的值。\n比如: IXVI\nI -> V -> X 每个都比右面的数字大（V > I, X > V), 所以 XVI就是 10 + 5 + 1 = 16。\n但是，接下来 I < X, 这时候就需要将总和把 I 的这部分减去： IXVI = 16 - 1 = 15。\n这个例子只是为了说明方法， 正常来说15 应该是 XV 。\n\n<br/>\n\n\n        class Solution {\n        private:\n            map<char, int> comparedMap = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };\n        \n        public:\n            int romanToInt(string s) {        \n                int ans = comparedMap[s[s.length()-1]];\n        \n                for(int i = s.length()-2; i >= 0; i--)  {\n                    if( comparedMap[s[i+1]] > comparedMap[s[i]] )   {\n                        ans -= comparedMap[s[i]];\n                    }\n                    else    {\n                        ans += comparedMap[s[i]];\n                    }\n                }\n        \n                return ans;        \n            }\n        };","slug":"[Leetcode]_13  Roman to Integer","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabfr0009veueujr2snut","content":"<p>Leetcode_13  Roman to Integer</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 13\n*  Title: Roman to Integer\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p><br></p>\n<p>之前是数字转罗马数，现在反过来了，罗马数转数字。（1~3999）<br>思路同数字转罗马，<br>将 valueToRoman数组从第一个比较到最后一个，然后符合情况时将对应的值加起来。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int romanToInt(string s) {\n        int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string valueToRoman[13] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};\n\n        int startPos = 0, len = s.length();\n        int ans = 0;\n        for(int i = 0; i &lt; 13; i++) {\n            while( startPos &lt; len ) {\n                string tempS = s.substr(startPos, valueToRoman[i].length());\n                if(tempS == valueToRoman[i])    {\n                    ans += values[i];\n                    startPos = startPos + tempS.length();\n                }\n                else\n                    break;\n            }\n        }\n        return ans;        \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p><br></p>\n<p>在讨论组又发现一个更简单的。<br>根据罗马数的规则：小的数放在右边是加小的数，小的数放在左边是减去小的数。<br>所以就从右向左把数字加起来，如果发现当前的数比右边的数小，就减去这个数的值。<br>比如: IXVI<br>I -&gt; V -&gt; X 每个都比右面的数字大（V &gt; I, X &gt; V), 所以 XVI就是 10 + 5 + 1 = 16。<br>但是，接下来 I &lt; X, 这时候就需要将总和把 I 的这部分减去： IXVI = 16 - 1 = 15。<br>这个例子只是为了说明方法， 正常来说15 应该是 XV 。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    map&lt;char, int&gt; comparedMap = {{&apos;I&apos;, 1}, {&apos;V&apos;, 5}, {&apos;X&apos;, 10}, {&apos;L&apos;, 50}, {&apos;C&apos;, 100}, {&apos;D&apos;, 500}, {&apos;M&apos;, 1000}, };\n\npublic:\n    int romanToInt(string s) {        \n        int ans = comparedMap[s[s.length()-1]];\n\n        for(int i = s.length()-2; i &gt;= 0; i--)  {\n            if( comparedMap[s[i+1]] &gt; comparedMap[s[i]] )   {\n                ans -= comparedMap[s[i]];\n            }\n            else    {\n                ans += comparedMap[s[i]];\n            }\n        }\n\n        return ans;        \n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_13  Roman to Integer</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 13\n*  Title: Roman to Integer\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p><br></p>\n<p>之前是数字转罗马数，现在反过来了，罗马数转数字。（1~3999）<br>思路同数字转罗马，<br>将 valueToRoman数组从第一个比较到最后一个，然后符合情况时将对应的值加起来。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int romanToInt(string s) {\n        int values[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string valueToRoman[13] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};\n\n        int startPos = 0, len = s.length();\n        int ans = 0;\n        for(int i = 0; i &lt; 13; i++) {\n            while( startPos &lt; len ) {\n                string tempS = s.substr(startPos, valueToRoman[i].length());\n                if(tempS == valueToRoman[i])    {\n                    ans += values[i];\n                    startPos = startPos + tempS.length();\n                }\n                else\n                    break;\n            }\n        }\n        return ans;        \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p><br></p>\n<p>在讨论组又发现一个更简单的。<br>根据罗马数的规则：小的数放在右边是加小的数，小的数放在左边是减去小的数。<br>所以就从右向左把数字加起来，如果发现当前的数比右边的数小，就减去这个数的值。<br>比如: IXVI<br>I -&gt; V -&gt; X 每个都比右面的数字大（V &gt; I, X &gt; V), 所以 XVI就是 10 + 5 + 1 = 16。<br>但是，接下来 I &lt; X, 这时候就需要将总和把 I 的这部分减去： IXVI = 16 - 1 = 15。<br>这个例子只是为了说明方法， 正常来说15 应该是 XV 。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    map&lt;char, int&gt; comparedMap = {{&apos;I&apos;, 1}, {&apos;V&apos;, 5}, {&apos;X&apos;, 10}, {&apos;L&apos;, 50}, {&apos;C&apos;, 100}, {&apos;D&apos;, 500}, {&apos;M&apos;, 1000}, };\n\npublic:\n    int romanToInt(string s) {        \n        int ans = comparedMap[s[s.length()-1]];\n\n        for(int i = s.length()-2; i &gt;= 0; i--)  {\n            if( comparedMap[s[i+1]] &gt; comparedMap[s[i]] )   {\n                ans -= comparedMap[s[i]];\n            }\n            else    {\n                ans += comparedMap[s[i]];\n            }\n        }\n\n        return ans;        \n    }\n};\n</code></pre>"},{"title":"Leetcode_14  Longest Common Prefix","date":"2017-04-12T15:03:11.000Z","_content":"\nLeetcode_14  Longest Common Prefix\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 14\n        *  Title: Longest Common Prefix\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题意就是在一个字符串集合中找出公共前缀。\n其实就是遍历，\n每个都进行比较，\n当有不同的出现，直接返回即可。\n没有什么难度。\n\n<br/>\n\n\n        class Solution {\n        public:\n            string longestCommonPrefix(vector<string>& strs) {\n                string ans = \"\";\n                for(int index = 0; index <= strs.size() && strs.size(); index++)    {\n                    for(int j = 0; j < strs.size(); j++)\n                        if(index >= strs[j].size() ||(j > 0 && strs[j][index] != strs[j-1][index]))\n                            return ans;\n                    ans += strs[0][index];\n                }\n                return ans;\n            }\n        };\n\n","source":"_posts/[Leetcode]_14  Longest Common Prefix.md","raw":"---\ntitle: Leetcode_14  Longest Common Prefix\ndate: 2017-04-12 23:03:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_14  Longest Common Prefix\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 14\n        *  Title: Longest Common Prefix\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题意就是在一个字符串集合中找出公共前缀。\n其实就是遍历，\n每个都进行比较，\n当有不同的出现，直接返回即可。\n没有什么难度。\n\n<br/>\n\n\n        class Solution {\n        public:\n            string longestCommonPrefix(vector<string>& strs) {\n                string ans = \"\";\n                for(int index = 0; index <= strs.size() && strs.size(); index++)    {\n                    for(int j = 0; j < strs.size(); j++)\n                        if(index >= strs[j].size() ||(j > 0 && strs[j][index] != strs[j-1][index]))\n                            return ans;\n                    ans += strs[0][index];\n                }\n                return ans;\n            }\n        };\n\n","slug":"[Leetcode]_14  Longest Common Prefix","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabfw000bveuewxzx5pak","content":"<p>Leetcode_14  Longest Common Prefix</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 14\n*  Title: Longest Common Prefix\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意就是在一个字符串集合中找出公共前缀。<br>其实就是遍历，<br>每个都进行比较，<br>当有不同的出现，直接返回即可。<br>没有什么难度。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n        string ans = &quot;&quot;;\n        for(int index = 0; index &lt;= strs.size() &amp;&amp; strs.size(); index++)    {\n            for(int j = 0; j &lt; strs.size(); j++)\n                if(index &gt;= strs[j].size() ||(j &gt; 0 &amp;&amp; strs[j][index] != strs[j-1][index]))\n                    return ans;\n            ans += strs[0][index];\n        }\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_14  Longest Common Prefix</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 14\n*  Title: Longest Common Prefix\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意就是在一个字符串集合中找出公共前缀。<br>其实就是遍历，<br>每个都进行比较，<br>当有不同的出现，直接返回即可。<br>没有什么难度。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n        string ans = &quot;&quot;;\n        for(int index = 0; index &lt;= strs.size() &amp;&amp; strs.size(); index++)    {\n            for(int j = 0; j &lt; strs.size(); j++)\n                if(index &gt;= strs[j].size() ||(j &gt; 0 &amp;&amp; strs[j][index] != strs[j-1][index]))\n                    return ans;\n            ans += strs[0][index];\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_15  3Sum","date":"2017-04-17T15:37:11.000Z","_content":"\nLeetcode_15  3Sum\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 15\n        *  Title: 3Sum\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n暴力肯定TLE，不用多想。\n\n先对所有数据进行排序，\n然后从第一个数开始，取一个数，计算这个数后面是否有两个数加这个数等于0。\n最关键就是:\n\n1. 排序(此方法的基点)\n2. 确定一组答案后过滤前后同值的数(过滤同样的答案, 且不影响其他不同的答案)\n\n<br/>\n\n\n        class Solution {\n        public:\n            vector<vector<int>> threeSum(vector<int>& nums) {\n                if(nums.size() < 3)\n                    return {};\n        \n                std::sort(nums.begin(), nums.end());\n                vector<vector<int>> ans;\n                \n                for(int i = 0; i < nums.size(); )   {\n                    int l = i+1, h = nums.size()-1, s = -nums[i];\n                    while(l < h)    {\n                        if(nums[l] + nums[h] == s)  {\n                            ans.push_back({nums[i], nums[l], nums[h]});\n                            l++, h--;           \n                            while(l < h && nums[l] == nums[l-1])\n                                l++;\n                            while(l < h && nums[h] == nums[h+1])\n                                h--;\n                        }\n                        else if(nums[l] + nums[h] < s)\n                            l++;\n                        else\n                            h--;\n                    }\n        \n                    i++;\n                    while(i < nums.size() && nums[i] == nums[i-1])\n                        i++;\n                }\n        \n                return ans;\n            }\n        };\n\n","source":"_posts/[Leetcode]_15  3Sum.md","raw":"---\ntitle: Leetcode_15  3Sum\ndate: 2017-04-17 23:37:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_15  3Sum\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 15\n        *  Title: 3Sum\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n暴力肯定TLE，不用多想。\n\n先对所有数据进行排序，\n然后从第一个数开始，取一个数，计算这个数后面是否有两个数加这个数等于0。\n最关键就是:\n\n1. 排序(此方法的基点)\n2. 确定一组答案后过滤前后同值的数(过滤同样的答案, 且不影响其他不同的答案)\n\n<br/>\n\n\n        class Solution {\n        public:\n            vector<vector<int>> threeSum(vector<int>& nums) {\n                if(nums.size() < 3)\n                    return {};\n        \n                std::sort(nums.begin(), nums.end());\n                vector<vector<int>> ans;\n                \n                for(int i = 0; i < nums.size(); )   {\n                    int l = i+1, h = nums.size()-1, s = -nums[i];\n                    while(l < h)    {\n                        if(nums[l] + nums[h] == s)  {\n                            ans.push_back({nums[i], nums[l], nums[h]});\n                            l++, h--;           \n                            while(l < h && nums[l] == nums[l-1])\n                                l++;\n                            while(l < h && nums[h] == nums[h+1])\n                                h--;\n                        }\n                        else if(nums[l] + nums[h] < s)\n                            l++;\n                        else\n                            h--;\n                    }\n        \n                    i++;\n                    while(i < nums.size() && nums[i] == nums[i-1])\n                        i++;\n                }\n        \n                return ans;\n            }\n        };\n\n","slug":"[Leetcode]_15  3Sum","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabg0000cveuemzblex1r","content":"<p>Leetcode_15  3Sum</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 15\n*  Title: 3Sum\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>暴力肯定TLE，不用多想。</p>\n<p>先对所有数据进行排序，<br>然后从第一个数开始，取一个数，计算这个数后面是否有两个数加这个数等于0。<br>最关键就是:</p>\n<ol>\n<li>排序(此方法的基点)</li>\n<li>确定一组答案后过滤前后同值的数(过滤同样的答案, 且不影响其他不同的答案)</li>\n</ol>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() &lt; 3)\n            return {};\n\n        std::sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        for(int i = 0; i &lt; nums.size(); )   {\n            int l = i+1, h = nums.size()-1, s = -nums[i];\n            while(l &lt; h)    {\n                if(nums[l] + nums[h] == s)  {\n                    ans.push_back({nums[i], nums[l], nums[h]});\n                    l++, h--;           \n                    while(l &lt; h &amp;&amp; nums[l] == nums[l-1])\n                        l++;\n                    while(l &lt; h &amp;&amp; nums[h] == nums[h+1])\n                        h--;\n                }\n                else if(nums[l] + nums[h] &lt; s)\n                    l++;\n                else\n                    h--;\n            }\n\n            i++;\n            while(i &lt; nums.size() &amp;&amp; nums[i] == nums[i-1])\n                i++;\n        }\n\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_15  3Sum</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 15\n*  Title: 3Sum\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>暴力肯定TLE，不用多想。</p>\n<p>先对所有数据进行排序，<br>然后从第一个数开始，取一个数，计算这个数后面是否有两个数加这个数等于0。<br>最关键就是:</p>\n<ol>\n<li>排序(此方法的基点)</li>\n<li>确定一组答案后过滤前后同值的数(过滤同样的答案, 且不影响其他不同的答案)</li>\n</ol>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() &lt; 3)\n            return {};\n\n        std::sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        for(int i = 0; i &lt; nums.size(); )   {\n            int l = i+1, h = nums.size()-1, s = -nums[i];\n            while(l &lt; h)    {\n                if(nums[l] + nums[h] == s)  {\n                    ans.push_back({nums[i], nums[l], nums[h]});\n                    l++, h--;           \n                    while(l &lt; h &amp;&amp; nums[l] == nums[l-1])\n                        l++;\n                    while(l &lt; h &amp;&amp; nums[h] == nums[h+1])\n                        h--;\n                }\n                else if(nums[l] + nums[h] &lt; s)\n                    l++;\n                else\n                    h--;\n            }\n\n            i++;\n            while(i &lt; nums.size() &amp;&amp; nums[i] == nums[i-1])\n                i++;\n        }\n\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_16  3Sum Closest","date":"2017-04-17T15:47:11.000Z","_content":"\nLeetcode_16  3Sum Closest\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 16\n        *  Title: 3Sum Closest\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n第15题的变种，\n之前是三个数相加等于0，\n这次让三个数相加等于给定的数，若相等，直接返回给定的数。\n否则就一直算。\n\n注意：\n此处ans初始值设置为INT_MAX,\n但是ans类型不能是INT，\n因为当target是负数时，INT_MAX-target 会溢出。\n\n<br/>\n\n\n        class Solution {\n        public:\n            int threeSumClosest(vector<int>& nums, int target) {\n                std::sort(nums.begin(), nums.end());\n                long ans = INT_MAX;\n        \n                for(int i = 0; i < nums.size(); )   {\n                    int l = i+1, h = nums.size()-1;\n                    while(l < h)    {\n                        int temp = nums[i] + nums[l] + nums[h];\n                        if(temp == target)  {\n                            return target;\n                        }\n                        else if(temp < target)   {\n                            if(abs(ans-target) > abs(temp-target))\n                                ans = temp;\n                            l++;\n                        }\n                        else {\n                            if(abs(ans-target) > abs(temp-target))\n                                ans = temp;\n                            h--;\n                        }\n                    }\n        \n                    i++;\n                    while(i < nums.size() && nums[i] == nums[i-1])\n                        i++;\n                }\n        \n                return ans;\n            }\n        };\n\n\n","source":"_posts/[Leetcode]_16  3Sum Closest.md","raw":"---\ntitle: Leetcode_16  3Sum Closest\ndate: 2017-04-17 23:47:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_16  3Sum Closest\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 16\n        *  Title: 3Sum Closest\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n第15题的变种，\n之前是三个数相加等于0，\n这次让三个数相加等于给定的数，若相等，直接返回给定的数。\n否则就一直算。\n\n注意：\n此处ans初始值设置为INT_MAX,\n但是ans类型不能是INT，\n因为当target是负数时，INT_MAX-target 会溢出。\n\n<br/>\n\n\n        class Solution {\n        public:\n            int threeSumClosest(vector<int>& nums, int target) {\n                std::sort(nums.begin(), nums.end());\n                long ans = INT_MAX;\n        \n                for(int i = 0; i < nums.size(); )   {\n                    int l = i+1, h = nums.size()-1;\n                    while(l < h)    {\n                        int temp = nums[i] + nums[l] + nums[h];\n                        if(temp == target)  {\n                            return target;\n                        }\n                        else if(temp < target)   {\n                            if(abs(ans-target) > abs(temp-target))\n                                ans = temp;\n                            l++;\n                        }\n                        else {\n                            if(abs(ans-target) > abs(temp-target))\n                                ans = temp;\n                            h--;\n                        }\n                    }\n        \n                    i++;\n                    while(i < nums.size() && nums[i] == nums[i-1])\n                        i++;\n                }\n        \n                return ans;\n            }\n        };\n\n\n","slug":"[Leetcode]_16  3Sum Closest","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabg5000eveuee63rksmf","content":"<p>Leetcode_16  3Sum Closest</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 16\n*  Title: 3Sum Closest\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>第15题的变种，<br>之前是三个数相加等于0，<br>这次让三个数相加等于给定的数，若相等，直接返回给定的数。<br>否则就一直算。</p>\n<p>注意：<br>此处ans初始值设置为INT_MAX,<br>但是ans类型不能是INT，<br>因为当target是负数时，INT_MAX-target 会溢出。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        std::sort(nums.begin(), nums.end());\n        long ans = INT_MAX;\n\n        for(int i = 0; i &lt; nums.size(); )   {\n            int l = i+1, h = nums.size()-1;\n            while(l &lt; h)    {\n                int temp = nums[i] + nums[l] + nums[h];\n                if(temp == target)  {\n                    return target;\n                }\n                else if(temp &lt; target)   {\n                    if(abs(ans-target) &gt; abs(temp-target))\n                        ans = temp;\n                    l++;\n                }\n                else {\n                    if(abs(ans-target) &gt; abs(temp-target))\n                        ans = temp;\n                    h--;\n                }\n            }\n\n            i++;\n            while(i &lt; nums.size() &amp;&amp; nums[i] == nums[i-1])\n                i++;\n        }\n\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_16  3Sum Closest</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 16\n*  Title: 3Sum Closest\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>第15题的变种，<br>之前是三个数相加等于0，<br>这次让三个数相加等于给定的数，若相等，直接返回给定的数。<br>否则就一直算。</p>\n<p>注意：<br>此处ans初始值设置为INT_MAX,<br>但是ans类型不能是INT，<br>因为当target是负数时，INT_MAX-target 会溢出。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        std::sort(nums.begin(), nums.end());\n        long ans = INT_MAX;\n\n        for(int i = 0; i &lt; nums.size(); )   {\n            int l = i+1, h = nums.size()-1;\n            while(l &lt; h)    {\n                int temp = nums[i] + nums[l] + nums[h];\n                if(temp == target)  {\n                    return target;\n                }\n                else if(temp &lt; target)   {\n                    if(abs(ans-target) &gt; abs(temp-target))\n                        ans = temp;\n                    l++;\n                }\n                else {\n                    if(abs(ans-target) &gt; abs(temp-target))\n                        ans = temp;\n                    h--;\n                }\n            }\n\n            i++;\n            while(i &lt; nums.size() &amp;&amp; nums[i] == nums[i-1])\n                i++;\n        }\n\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_17  Letter Combinations of a Phone Number","date":"2017-04-20T15:46:11.000Z","_content":"\nLeetcode_17  Letter Combinations of a Phone Number\n递归\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 17\n        *  Title: Letter Combinations of a Phone Number\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题应该是用递归来做\n\n\n        digits.length() >   1  =>   将 digits[0]对应的集合 与 digits.substr(1)返回的集合连接\n        digits.length() ==  1  =>   返回数字对应的字符串集合\n\n\n然后再处理一些无效值的情况:\n\n*   数字中 0, 1, *, # 等其他值。 —— 这里用他们 ASCII码的差值来判断。\n*   如果输入的数字中存在无效值，整个返回空。 —— 这里判断后面字符串的返回值是否为空，若为空，直接返回空。\n\n\n<br/>\n\n\n        class Solution {\n        private:\n            string map[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        \n        public:\n            vector<string> letterCombinations(string digits) {\n                if(digits.length() == 0)    return {};\n        \n                int temp = digits[0] - '0';\n                if( temp < 2 || temp > 9 )  return {};\n        \n                vector<string> ans = {};\n                string mapStr = map[temp];\n                if(digits.length() > 1) {\n                    vector<string> preAns = letterCombinations(digits.substr(1, digits.length()-1));\n                    if(preAns.size() == 0)  return {};\n        \n                    for(int i = 0; i < mapStr.length(); i++)    {\n                        for(int j = 0; j < preAns.size(); j++)  {\n                            ans.push_back(mapStr[i]+preAns[j]);\n                        }\n                    }\n                }\n                else    {\n                    for(int i = 0; i < mapStr.length(); i++)    {\n                        ans.push_back(mapStr.substr(i, 1));\n                    }\n                }\n                return ans;\n            }\n        };\n\n\n","source":"_posts/[Leetcode]_17  Letter Combinations of a Phone Number.md","raw":"---\ntitle: Leetcode_17  Letter Combinations of a Phone Number\ndate: 2017-04-20 23:46:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_17  Letter Combinations of a Phone Number\n递归\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 17\n        *  Title: Letter Combinations of a Phone Number\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题应该是用递归来做\n\n\n        digits.length() >   1  =>   将 digits[0]对应的集合 与 digits.substr(1)返回的集合连接\n        digits.length() ==  1  =>   返回数字对应的字符串集合\n\n\n然后再处理一些无效值的情况:\n\n*   数字中 0, 1, *, # 等其他值。 —— 这里用他们 ASCII码的差值来判断。\n*   如果输入的数字中存在无效值，整个返回空。 —— 这里判断后面字符串的返回值是否为空，若为空，直接返回空。\n\n\n<br/>\n\n\n        class Solution {\n        private:\n            string map[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        \n        public:\n            vector<string> letterCombinations(string digits) {\n                if(digits.length() == 0)    return {};\n        \n                int temp = digits[0] - '0';\n                if( temp < 2 || temp > 9 )  return {};\n        \n                vector<string> ans = {};\n                string mapStr = map[temp];\n                if(digits.length() > 1) {\n                    vector<string> preAns = letterCombinations(digits.substr(1, digits.length()-1));\n                    if(preAns.size() == 0)  return {};\n        \n                    for(int i = 0; i < mapStr.length(); i++)    {\n                        for(int j = 0; j < preAns.size(); j++)  {\n                            ans.push_back(mapStr[i]+preAns[j]);\n                        }\n                    }\n                }\n                else    {\n                    for(int i = 0; i < mapStr.length(); i++)    {\n                        ans.push_back(mapStr.substr(i, 1));\n                    }\n                }\n                return ans;\n            }\n        };\n\n\n","slug":"[Leetcode]_17  Letter Combinations of a Phone Number","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabg7000gveueeolvnmz7","content":"<p>Leetcode_17  Letter Combinations of a Phone Number<br>递归</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 17\n*  Title: Letter Combinations of a Phone Number\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题应该是用递归来做</p>\n<pre><code>digits.length() &gt;   1  =&gt;   将 digits[0]对应的集合 与 digits.substr(1)返回的集合连接\ndigits.length() ==  1  =&gt;   返回数字对应的字符串集合\n</code></pre><p>然后再处理一些无效值的情况:</p>\n<ul>\n<li>数字中 0, 1, *, # 等其他值。 —— 这里用他们 ASCII码的差值来判断。</li>\n<li>如果输入的数字中存在无效值，整个返回空。 —— 这里判断后面字符串的返回值是否为空，若为空，直接返回空。</li>\n</ul>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    string map[10] = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};\n\npublic:\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if(digits.length() == 0)    return {};\n\n        int temp = digits[0] - &apos;0&apos;;\n        if( temp &lt; 2 || temp &gt; 9 )  return {};\n\n        vector&lt;string&gt; ans = {};\n        string mapStr = map[temp];\n        if(digits.length() &gt; 1) {\n            vector&lt;string&gt; preAns = letterCombinations(digits.substr(1, digits.length()-1));\n            if(preAns.size() == 0)  return {};\n\n            for(int i = 0; i &lt; mapStr.length(); i++)    {\n                for(int j = 0; j &lt; preAns.size(); j++)  {\n                    ans.push_back(mapStr[i]+preAns[j]);\n                }\n            }\n        }\n        else    {\n            for(int i = 0; i &lt; mapStr.length(); i++)    {\n                ans.push_back(mapStr.substr(i, 1));\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_17  Letter Combinations of a Phone Number<br>递归</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 17\n*  Title: Letter Combinations of a Phone Number\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题应该是用递归来做</p>\n<pre><code>digits.length() &gt;   1  =&gt;   将 digits[0]对应的集合 与 digits.substr(1)返回的集合连接\ndigits.length() ==  1  =&gt;   返回数字对应的字符串集合\n</code></pre><p>然后再处理一些无效值的情况:</p>\n<ul>\n<li>数字中 0, 1, *, # 等其他值。 —— 这里用他们 ASCII码的差值来判断。</li>\n<li>如果输入的数字中存在无效值，整个返回空。 —— 这里判断后面字符串的返回值是否为空，若为空，直接返回空。</li>\n</ul>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    string map[10] = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};\n\npublic:\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if(digits.length() == 0)    return {};\n\n        int temp = digits[0] - &apos;0&apos;;\n        if( temp &lt; 2 || temp &gt; 9 )  return {};\n\n        vector&lt;string&gt; ans = {};\n        string mapStr = map[temp];\n        if(digits.length() &gt; 1) {\n            vector&lt;string&gt; preAns = letterCombinations(digits.substr(1, digits.length()-1));\n            if(preAns.size() == 0)  return {};\n\n            for(int i = 0; i &lt; mapStr.length(); i++)    {\n                for(int j = 0; j &lt; preAns.size(); j++)  {\n                    ans.push_back(mapStr[i]+preAns[j]);\n                }\n            }\n        }\n        else    {\n            for(int i = 0; i &lt; mapStr.length(); i++)    {\n                ans.push_back(mapStr.substr(i, 1));\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_18  4Sum","date":"2017-04-24T14:46:11.000Z","_content":"\nLeetcode_18 4Sum\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 18\n        *  Title: 4Sum\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题和之前的 3Sum, 3Sum Closest 差不多。\n用的同样的方法。\n\n值得一说的就是这里的一个小剪枝。\n因为进行了排序，如果发现:\n\n- 从某个数开始连加都小于给定的目标值，那么 >整个< 就不需要查了，后面的数一定没有正确答案。\n- 某个数加上最大的三个数仍小于给定的目标值，那么 >本数< 就不需要查了，怎么加都比目标值小。\n\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                int len = nums.size();\n                if(len < 4)\n                    return {};\n        \n                std::sort(nums.begin(), nums.end());\n                vector<vector<int>> ans;\n                \n                for(int i = 0; i < len - 3; i++)    {\n                    if(i > 0 && nums[i] == nums[i-1]) continue;\n        \n                    // 关键剪枝\n                    if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\n                    if(nums[i]+nums[len-3]+nums[len-2]+nums[len-1] < target) continue;\n        \n                    for(int j = i+1; j < len - 2; ) {\n                        int l = j+1, h = len - 1, s = target-nums[i]-nums[j];\n                        while(l < h)    {\n                            if(nums[l] + nums[h] == s)  {\n                                ans.push_back({nums[i], nums[j], nums[l], nums[h]});\n                                l++, h--;           \n                                while(l < h && nums[l] == nums[l-1])\n                                    l++;\n                                while(l < h && nums[h] == nums[h+1])\n                                    h--;\n                            }\n                            else if(nums[l] + nums[h] < s)\n                                l++;\n                            else\n                                h--;\n                        }\n        \n                        j++;\n                        while(j < len-2 && nums[j] == nums[j-1])    j++;\n                    }\n                }\n                return ans;\n            }\n        };","source":"_posts/[Leetcode]_18  4Sum.md","raw":"---\ntitle: Leetcode_18  4Sum\ndate: 2017-04-24 22:46:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_18 4Sum\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 18\n        *  Title: 4Sum\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题和之前的 3Sum, 3Sum Closest 差不多。\n用的同样的方法。\n\n值得一说的就是这里的一个小剪枝。\n因为进行了排序，如果发现:\n\n- 从某个数开始连加都小于给定的目标值，那么 >整个< 就不需要查了，后面的数一定没有正确答案。\n- 某个数加上最大的三个数仍小于给定的目标值，那么 >本数< 就不需要查了，怎么加都比目标值小。\n\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                int len = nums.size();\n                if(len < 4)\n                    return {};\n        \n                std::sort(nums.begin(), nums.end());\n                vector<vector<int>> ans;\n                \n                for(int i = 0; i < len - 3; i++)    {\n                    if(i > 0 && nums[i] == nums[i-1]) continue;\n        \n                    // 关键剪枝\n                    if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\n                    if(nums[i]+nums[len-3]+nums[len-2]+nums[len-1] < target) continue;\n        \n                    for(int j = i+1; j < len - 2; ) {\n                        int l = j+1, h = len - 1, s = target-nums[i]-nums[j];\n                        while(l < h)    {\n                            if(nums[l] + nums[h] == s)  {\n                                ans.push_back({nums[i], nums[j], nums[l], nums[h]});\n                                l++, h--;           \n                                while(l < h && nums[l] == nums[l-1])\n                                    l++;\n                                while(l < h && nums[h] == nums[h+1])\n                                    h--;\n                            }\n                            else if(nums[l] + nums[h] < s)\n                                l++;\n                            else\n                                h--;\n                        }\n        \n                        j++;\n                        while(j < len-2 && nums[j] == nums[j-1])    j++;\n                    }\n                }\n                return ans;\n            }\n        };","slug":"[Leetcode]_18  4Sum","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgb000jveueimj0l8oi","content":"<p>Leetcode_18 4Sum</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 18\n*  Title: 4Sum\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题和之前的 3Sum, 3Sum Closest 差不多。<br>用的同样的方法。</p>\n<p>值得一说的就是这里的一个小剪枝。<br>因为进行了排序，如果发现:</p>\n<ul>\n<li>从某个数开始连加都小于给定的目标值，那么 &gt;整个&lt; 就不需要查了，后面的数一定没有正确答案。</li>\n<li>某个数加上最大的三个数仍小于给定的目标值，那么 &gt;本数&lt; 就不需要查了，怎么加都比目标值小。</li>\n</ul>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        int len = nums.size();\n        if(len &lt; 4)\n            return {};\n\n        std::sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        for(int i = 0; i &lt; len - 3; i++)    {\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;\n\n            // 关键剪枝\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target) break;\n            if(nums[i]+nums[len-3]+nums[len-2]+nums[len-1] &lt; target) continue;\n\n            for(int j = i+1; j &lt; len - 2; ) {\n                int l = j+1, h = len - 1, s = target-nums[i]-nums[j];\n                while(l &lt; h)    {\n                    if(nums[l] + nums[h] == s)  {\n                        ans.push_back({nums[i], nums[j], nums[l], nums[h]});\n                        l++, h--;           \n                        while(l &lt; h &amp;&amp; nums[l] == nums[l-1])\n                            l++;\n                        while(l &lt; h &amp;&amp; nums[h] == nums[h+1])\n                            h--;\n                    }\n                    else if(nums[l] + nums[h] &lt; s)\n                        l++;\n                    else\n                        h--;\n                }\n\n                j++;\n                while(j &lt; len-2 &amp;&amp; nums[j] == nums[j-1])    j++;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_18 4Sum</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 18\n*  Title: 4Sum\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题和之前的 3Sum, 3Sum Closest 差不多。<br>用的同样的方法。</p>\n<p>值得一说的就是这里的一个小剪枝。<br>因为进行了排序，如果发现:</p>\n<ul>\n<li>从某个数开始连加都小于给定的目标值，那么 &gt;整个&lt; 就不需要查了，后面的数一定没有正确答案。</li>\n<li>某个数加上最大的三个数仍小于给定的目标值，那么 &gt;本数&lt; 就不需要查了，怎么加都比目标值小。</li>\n</ul>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        int len = nums.size();\n        if(len &lt; 4)\n            return {};\n\n        std::sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        for(int i = 0; i &lt; len - 3; i++)    {\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;\n\n            // 关键剪枝\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target) break;\n            if(nums[i]+nums[len-3]+nums[len-2]+nums[len-1] &lt; target) continue;\n\n            for(int j = i+1; j &lt; len - 2; ) {\n                int l = j+1, h = len - 1, s = target-nums[i]-nums[j];\n                while(l &lt; h)    {\n                    if(nums[l] + nums[h] == s)  {\n                        ans.push_back({nums[i], nums[j], nums[l], nums[h]});\n                        l++, h--;           \n                        while(l &lt; h &amp;&amp; nums[l] == nums[l-1])\n                            l++;\n                        while(l &lt; h &amp;&amp; nums[h] == nums[h+1])\n                            h--;\n                    }\n                    else if(nums[l] + nums[h] &lt; s)\n                        l++;\n                    else\n                        h--;\n                }\n\n                j++;\n                while(j &lt; len-2 &amp;&amp; nums[j] == nums[j-1])    j++;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_19  Remove Nth Node From End of List","date":"2017-04-24T14:50:11.000Z","_content":"\nLeetcode_19  Remove Nth Node From End of List\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 19\n        *  Title: Remove Nth Node From End of List\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题关键在于一遍过。\n我想法就是两个指针，相距n个位置，如果前面的指针到底了，那么后面的就是需要被排除的东西。\n然后在将一些边界条件判断一下。\n\n\n\n<br/>\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* removeNthFromEnd(ListNode* head, int n) {\n                ListNode* slow = head;\n                ListNode* fast = head;\n                while(n > 0)    {\n                    if(fast)    {\n                        fast = fast->next;\n                        n--;                \n                    }\n                    else\n                        return NULL;\n                }\n        \n                if(fast == NULL)    {\n                    slow = slow->next;\n                    return slow;\n                }\n        \n                while(fast->next) {\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n            \n                ListNode* temp = slow->next;\n                slow->next = temp->next;\n                temp = NULL;\n                \n                return head;\n            }\n        };","source":"_posts/[Leetcode]_19  Remove Nth Node From End of List.md","raw":"---\ntitle: Leetcode_19  Remove Nth Node From End of List\ndate: 2017-04-24 22:50:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_19  Remove Nth Node From End of List\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 19\n        *  Title: Remove Nth Node From End of List\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n这道题关键在于一遍过。\n我想法就是两个指针，相距n个位置，如果前面的指针到底了，那么后面的就是需要被排除的东西。\n然后在将一些边界条件判断一下。\n\n\n\n<br/>\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* removeNthFromEnd(ListNode* head, int n) {\n                ListNode* slow = head;\n                ListNode* fast = head;\n                while(n > 0)    {\n                    if(fast)    {\n                        fast = fast->next;\n                        n--;                \n                    }\n                    else\n                        return NULL;\n                }\n        \n                if(fast == NULL)    {\n                    slow = slow->next;\n                    return slow;\n                }\n        \n                while(fast->next) {\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n            \n                ListNode* temp = slow->next;\n                slow->next = temp->next;\n                temp = NULL;\n                \n                return head;\n            }\n        };","slug":"[Leetcode]_19  Remove Nth Node From End of List","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabge000kveueg3u6lcnj","content":"<p>Leetcode_19  Remove Nth Node From End of List</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 19\n*  Title: Remove Nth Node From End of List\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题关键在于一遍过。<br>我想法就是两个指针，相距n个位置，如果前面的指针到底了，那么后面的就是需要被排除的东西。<br>然后在将一些边界条件判断一下。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(n &gt; 0)    {\n            if(fast)    {\n                fast = fast-&gt;next;\n                n--;                \n            }\n            else\n                return NULL;\n        }\n\n        if(fast == NULL)    {\n            slow = slow-&gt;next;\n            return slow;\n        }\n\n        while(fast-&gt;next) {\n            fast = fast-&gt;next;\n            slow = slow-&gt;next;\n        }\n\n        ListNode* temp = slow-&gt;next;\n        slow-&gt;next = temp-&gt;next;\n        temp = NULL;\n\n        return head;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_19  Remove Nth Node From End of List</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 19\n*  Title: Remove Nth Node From End of List\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>这道题关键在于一遍过。<br>我想法就是两个指针，相距n个位置，如果前面的指针到底了，那么后面的就是需要被排除的东西。<br>然后在将一些边界条件判断一下。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(n &gt; 0)    {\n            if(fast)    {\n                fast = fast-&gt;next;\n                n--;                \n            }\n            else\n                return NULL;\n        }\n\n        if(fast == NULL)    {\n            slow = slow-&gt;next;\n            return slow;\n        }\n\n        while(fast-&gt;next) {\n            fast = fast-&gt;next;\n            slow = slow-&gt;next;\n        }\n\n        ListNode* temp = slow-&gt;next;\n        slow-&gt;next = temp-&gt;next;\n        temp = NULL;\n\n        return head;\n    }\n};\n</code></pre>"},{"title":"Leetcode_2  Add Two Numbers","date":"2017-03-15T14:13:35.000Z","_content":"\nLeetcode_2  Add Two Numbers\n简单题\n\n<!-- more -->\n<br/>\n\n\n很基础..\n合并l1 和 l2\n\n\n\t\tclass Solution {\n\t\tpublic:\n\t\t    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {      \n    \t\t    ListNode* lnTemp = new ListNode(0);\n        \t\tListNode* ori = lnTemp;\n    \t\t    int op = 0;\n\n\t\t        while( l1 || l2 || op )   {\n    \t\t        int sum = op;\n        \t\t    if(l1)  {\n            \t\t    sum += l1->val;\n            \t\t    l1 = l1->next;\n        \t\t    }\n        \t\t    if(l2)  {\n            \t\t    sum += l2->val;\n                \t\tl2 = l2->next;\n            \t\t}\n\n\t\t            op = sum/10;\n    \t\t        lnTemp->next = new ListNode(sum%10);\n        \t\t    lnTemp = lnTemp->next;\n        \t\t}\n        \t\treturn ori->next;\n    \t\t}\n\t\t};\n\n\n<br/>\n用更少的空间，\n一个记录初始地址结构体，一个进位值，一个补足进位结构体。\n将所有的数都加在l1上，如果l2比l1长 => l1->next = l2->next 将l2后半部分并到l1\n\n\n\n\t\tclass Solution {\n\t\tpublic:\n    \t\tListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n    \t\t    ListNode *ori = l1;\n   \t\t     int op = 0;\n\t\t\n   \t\t     while (true) {\n   \t\t         l1->val += (l2->val + op);\n    \t\t        op = l1->val/10;\n   \t\t         l1->val %= 10;\n\n   \t\t         if (!l1->next) {\n   \t\t             l1->next = l2->next;\n  \t\t              break;\n       \t\t     }\n            \t\telse if (!l2->next)\n             \t\t   break;\n\n       \t\t     l1 = l1->next;\n       \t\t     l2 = l2->next;\n      \t\t}\n        \n       \t\twhile (l1->next && op) {\n      \t\t\t\tl1 = l1->next;\n        \t\t    op = (l1->val += op)/10;\n        \t\t    l1->val %= 10;\n        \t\t}\n\n        \t\tif (op)\n            \t\tl1->next = new ListNode(op);\n\n        \t\treturn ori;\n    \t\t}\n\t\t};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[Leetcode]_2  Add Two Numbers.md","raw":"---\ntitle: Leetcode_2  Add Two Numbers\ndate: 2017-03-15 22:13:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_2  Add Two Numbers\n简单题\n\n<!-- more -->\n<br/>\n\n\n很基础..\n合并l1 和 l2\n\n\n\t\tclass Solution {\n\t\tpublic:\n\t\t    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {      \n    \t\t    ListNode* lnTemp = new ListNode(0);\n        \t\tListNode* ori = lnTemp;\n    \t\t    int op = 0;\n\n\t\t        while( l1 || l2 || op )   {\n    \t\t        int sum = op;\n        \t\t    if(l1)  {\n            \t\t    sum += l1->val;\n            \t\t    l1 = l1->next;\n        \t\t    }\n        \t\t    if(l2)  {\n            \t\t    sum += l2->val;\n                \t\tl2 = l2->next;\n            \t\t}\n\n\t\t            op = sum/10;\n    \t\t        lnTemp->next = new ListNode(sum%10);\n        \t\t    lnTemp = lnTemp->next;\n        \t\t}\n        \t\treturn ori->next;\n    \t\t}\n\t\t};\n\n\n<br/>\n用更少的空间，\n一个记录初始地址结构体，一个进位值，一个补足进位结构体。\n将所有的数都加在l1上，如果l2比l1长 => l1->next = l2->next 将l2后半部分并到l1\n\n\n\n\t\tclass Solution {\n\t\tpublic:\n    \t\tListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n    \t\t    ListNode *ori = l1;\n   \t\t     int op = 0;\n\t\t\n   \t\t     while (true) {\n   \t\t         l1->val += (l2->val + op);\n    \t\t        op = l1->val/10;\n   \t\t         l1->val %= 10;\n\n   \t\t         if (!l1->next) {\n   \t\t             l1->next = l2->next;\n  \t\t              break;\n       \t\t     }\n            \t\telse if (!l2->next)\n             \t\t   break;\n\n       \t\t     l1 = l1->next;\n       \t\t     l2 = l2->next;\n      \t\t}\n        \n       \t\twhile (l1->next && op) {\n      \t\t\t\tl1 = l1->next;\n        \t\t    op = (l1->val += op)/10;\n        \t\t    l1->val %= 10;\n        \t\t}\n\n        \t\tif (op)\n            \t\tl1->next = new ListNode(op);\n\n        \t\treturn ori;\n    \t\t}\n\t\t};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[Leetcode]_2  Add Two Numbers","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgg000lveuecujwuqrg","content":"<p>Leetcode_2  Add Two Numbers<br>简单题</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>很基础..<br>合并l1 和 l2</p>\n<pre><code>class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {      \n        ListNode* lnTemp = new ListNode(0);\n        ListNode* ori = lnTemp;\n        int op = 0;\n\n        while( l1 || l2 || op )   {\n            int sum = op;\n            if(l1)  {\n                sum += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if(l2)  {\n                sum += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n\n            op = sum/10;\n            lnTemp-&gt;next = new ListNode(sum%10);\n            lnTemp = lnTemp-&gt;next;\n        }\n        return ori-&gt;next;\n    }\n};\n</code></pre><p><br><br>用更少的空间，<br>一个记录初始地址结构体，一个进位值，一个补足进位结构体。<br>将所有的数都加在l1上，如果l2比l1长 =&gt; l1-&gt;next = l2-&gt;next 将l2后半部分并到l1</p>\n<pre><code>class Solution {\npublic:\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n        ListNode *ori = l1;\n        int op = 0;\n\n        while (true) {\n            l1-&gt;val += (l2-&gt;val + op);\n            op = l1-&gt;val/10;\n            l1-&gt;val %= 10;\n\n            if (!l1-&gt;next) {\n                l1-&gt;next = l2-&gt;next;\n                break;\n            }\n            else if (!l2-&gt;next)\n                break;\n\n            l1 = l1-&gt;next;\n            l2 = l2-&gt;next;\n      }\n\n       while (l1-&gt;next &amp;&amp; op) {\n              l1 = l1-&gt;next;\n            op = (l1-&gt;val += op)/10;\n            l1-&gt;val %= 10;\n        }\n\n        if (op)\n            l1-&gt;next = new ListNode(op);\n\n        return ori;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_2  Add Two Numbers<br>简单题</p>","more":"<p><br></p>\n<p>很基础..<br>合并l1 和 l2</p>\n<pre><code>class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {      \n        ListNode* lnTemp = new ListNode(0);\n        ListNode* ori = lnTemp;\n        int op = 0;\n\n        while( l1 || l2 || op )   {\n            int sum = op;\n            if(l1)  {\n                sum += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if(l2)  {\n                sum += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n\n            op = sum/10;\n            lnTemp-&gt;next = new ListNode(sum%10);\n            lnTemp = lnTemp-&gt;next;\n        }\n        return ori-&gt;next;\n    }\n};\n</code></pre><p><br><br>用更少的空间，<br>一个记录初始地址结构体，一个进位值，一个补足进位结构体。<br>将所有的数都加在l1上，如果l2比l1长 =&gt; l1-&gt;next = l2-&gt;next 将l2后半部分并到l1</p>\n<pre><code>class Solution {\npublic:\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n        ListNode *ori = l1;\n        int op = 0;\n\n        while (true) {\n            l1-&gt;val += (l2-&gt;val + op);\n            op = l1-&gt;val/10;\n            l1-&gt;val %= 10;\n\n            if (!l1-&gt;next) {\n                l1-&gt;next = l2-&gt;next;\n                break;\n            }\n            else if (!l2-&gt;next)\n                break;\n\n            l1 = l1-&gt;next;\n            l2 = l2-&gt;next;\n      }\n\n       while (l1-&gt;next &amp;&amp; op) {\n              l1 = l1-&gt;next;\n            op = (l1-&gt;val += op)/10;\n            l1-&gt;val %= 10;\n        }\n\n        if (op)\n            l1-&gt;next = new ListNode(op);\n\n        return ori;\n    }\n};\n</code></pre>"},{"title":"Leetcode_20  Valid Parentheses","date":"2017-04-26T14:37:11.000Z","_content":"\nLeetcode_20  Valid Parentheses\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 20\n        *  Title: Valid Parentheses\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n括号配对，利用栈先进后出的特点。\n当出现右半部分时，必须与之前最后出现的左半部分配对成功，否则GG。\n\n\n注意几个样例：\n\n\n        \"[\"\n        \"]\"\n        \"][\"\n        \"[(])\"\n        \"[()]\"\n\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            bool isValid(string s) {\n                stack<char> container;\n        \n                for(int i = 0; i < s.length(); i++) {\n                    switch(s[i])    {\n                        case '(': \n                        case '{': \n                        case '[':   container.push(s[i]);   break;\n                        case ')':   {if(container.empty() || container.top()!='(') return false; else container.pop();} break;\n                        case '}':   {if(container.empty() || container.top()!='{') return false; else container.pop();} break;\n                        case ']':   {if(container.empty() || container.top()!='[') return false; else container.pop();} break;\n                        default: ;\n                    }\n                }\n        \n                return (container.size() == 0);\n            }\n        };","source":"_posts/[Leetcode]_20  Valid Parentheses.md","raw":"---\ntitle: Leetcode_20  Valid Parentheses\ndate: 2017-04-26 22:37:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_20  Valid Parentheses\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 20\n        *  Title: Valid Parentheses\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n括号配对，利用栈先进后出的特点。\n当出现右半部分时，必须与之前最后出现的左半部分配对成功，否则GG。\n\n\n注意几个样例：\n\n\n        \"[\"\n        \"]\"\n        \"][\"\n        \"[(])\"\n        \"[()]\"\n\n\n\n<br/>\n\n\n        class Solution {\n        public:\n            bool isValid(string s) {\n                stack<char> container;\n        \n                for(int i = 0; i < s.length(); i++) {\n                    switch(s[i])    {\n                        case '(': \n                        case '{': \n                        case '[':   container.push(s[i]);   break;\n                        case ')':   {if(container.empty() || container.top()!='(') return false; else container.pop();} break;\n                        case '}':   {if(container.empty() || container.top()!='{') return false; else container.pop();} break;\n                        case ']':   {if(container.empty() || container.top()!='[') return false; else container.pop();} break;\n                        default: ;\n                    }\n                }\n        \n                return (container.size() == 0);\n            }\n        };","slug":"[Leetcode]_20  Valid Parentheses","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgk000oveueme0emc25","content":"<p>Leetcode_20  Valid Parentheses</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 20\n*  Title: Valid Parentheses\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>括号配对，利用栈先进后出的特点。<br>当出现右半部分时，必须与之前最后出现的左半部分配对成功，否则GG。</p>\n<p>注意几个样例：</p>\n<pre><code>&quot;[&quot;\n&quot;]&quot;\n&quot;][&quot;\n&quot;[(])&quot;\n&quot;[()]&quot;\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isValid(string s) {\n        stack&lt;char&gt; container;\n\n        for(int i = 0; i &lt; s.length(); i++) {\n            switch(s[i])    {\n                case &apos;(&apos;: \n                case &apos;{&apos;: \n                case &apos;[&apos;:   container.push(s[i]);   break;\n                case &apos;)&apos;:   {if(container.empty() || container.top()!=&apos;(&apos;) return false; else container.pop();} break;\n                case &apos;}&apos;:   {if(container.empty() || container.top()!=&apos;{&apos;) return false; else container.pop();} break;\n                case &apos;]&apos;:   {if(container.empty() || container.top()!=&apos;[&apos;) return false; else container.pop();} break;\n                default: ;\n            }\n        }\n\n        return (container.size() == 0);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_20  Valid Parentheses</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 20\n*  Title: Valid Parentheses\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>括号配对，利用栈先进后出的特点。<br>当出现右半部分时，必须与之前最后出现的左半部分配对成功，否则GG。</p>\n<p>注意几个样例：</p>\n<pre><code>&quot;[&quot;\n&quot;]&quot;\n&quot;][&quot;\n&quot;[(])&quot;\n&quot;[()]&quot;\n</code></pre><p><br></p>\n<pre><code>class Solution {\npublic:\n    bool isValid(string s) {\n        stack&lt;char&gt; container;\n\n        for(int i = 0; i &lt; s.length(); i++) {\n            switch(s[i])    {\n                case &apos;(&apos;: \n                case &apos;{&apos;: \n                case &apos;[&apos;:   container.push(s[i]);   break;\n                case &apos;)&apos;:   {if(container.empty() || container.top()!=&apos;(&apos;) return false; else container.pop();} break;\n                case &apos;}&apos;:   {if(container.empty() || container.top()!=&apos;{&apos;) return false; else container.pop();} break;\n                case &apos;]&apos;:   {if(container.empty() || container.top()!=&apos;[&apos;) return false; else container.pop();} break;\n                default: ;\n            }\n        }\n\n        return (container.size() == 0);\n    }\n};\n</code></pre>"},{"title":"Leetcode_21  Merge Two Sorted Lists","date":"2017-04-30T09:17:00.000Z","_content":"\nLeetcode_21  Merge Two Sorted Lists\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 21\n        *  Title: Merge Two Sorted Lists\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n将两个有序的数组合并成一个数组。\n\n\n<br/>\n\n#### 第三方介入\n\n最通俗易懂的，设置一个第三方，来进行存储合并。\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n                ListNode* l3 = new ListNode(0);\n                ListNode* head = l3;\n        \n                while(l1 && l2) {\n                    if(l1->val <= l2->val)  {\n                        ListNode* temp = new ListNode(l1->val);\n                        l3->next = temp;\n                        l1 = l1->next;\n                    }\n                    else    {\n                        ListNode* temp = new ListNode(l2->val);\n                        l3->next = temp;\n                        l2 = l2->next;\n                    }\n                    l3 = l3->next;\n                }\n        \n                if(l1)\n                    l3->next = l1;\n                else\n                    l3->next = l2;\n        \n                return head->next;\n            }\n        };\n\n\n<br/>\n\n\n#### 递归\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n                if(l1 == NULL)  return l2;\n                if(l2 == NULL)  return l1;\n        \n                if(l1->val <= l2->val)  {\n                    l1->next = mergeTwoLists(l1->next, l2);\n                    return l1;\n                }\n                else    {\n                    l2->next = mergeTwoLists(l1, l2->next);\n                    return l2;\n                }\n            }\n        };\n","source":"_posts/[Leetcode]_21  Merge Two Sorted Lists.md","raw":"---\ntitle: Leetcode_21  Merge Two Sorted Lists\ndate: 2017-04-30 17:17:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_21  Merge Two Sorted Lists\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 21\n        *  Title: Merge Two Sorted Lists\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n将两个有序的数组合并成一个数组。\n\n\n<br/>\n\n#### 第三方介入\n\n最通俗易懂的，设置一个第三方，来进行存储合并。\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n                ListNode* l3 = new ListNode(0);\n                ListNode* head = l3;\n        \n                while(l1 && l2) {\n                    if(l1->val <= l2->val)  {\n                        ListNode* temp = new ListNode(l1->val);\n                        l3->next = temp;\n                        l1 = l1->next;\n                    }\n                    else    {\n                        ListNode* temp = new ListNode(l2->val);\n                        l3->next = temp;\n                        l2 = l2->next;\n                    }\n                    l3 = l3->next;\n                }\n        \n                if(l1)\n                    l3->next = l1;\n                else\n                    l3->next = l2;\n        \n                return head->next;\n            }\n        };\n\n\n<br/>\n\n\n#### 递归\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n                if(l1 == NULL)  return l2;\n                if(l2 == NULL)  return l1;\n        \n                if(l1->val <= l2->val)  {\n                    l1->next = mergeTwoLists(l1->next, l2);\n                    return l1;\n                }\n                else    {\n                    l2->next = mergeTwoLists(l1, l2->next);\n                    return l2;\n                }\n            }\n        };\n","slug":"[Leetcode]_21  Merge Two Sorted Lists","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgn000qveuexf73zwny","content":"<p>Leetcode_21  Merge Two Sorted Lists</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 21\n*  Title: Merge Two Sorted Lists\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>将两个有序的数组合并成一个数组。</p>\n<p><br></p>\n<h4 id=\"第三方介入\"><a href=\"#第三方介入\" class=\"headerlink\" title=\"第三方介入\"></a>第三方介入</h4><p>最通俗易懂的，设置一个第三方，来进行存储合并。</p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* l3 = new ListNode(0);\n        ListNode* head = l3;\n\n        while(l1 &amp;&amp; l2) {\n            if(l1-&gt;val &lt;= l2-&gt;val)  {\n                ListNode* temp = new ListNode(l1-&gt;val);\n                l3-&gt;next = temp;\n                l1 = l1-&gt;next;\n            }\n            else    {\n                ListNode* temp = new ListNode(l2-&gt;val);\n                l3-&gt;next = temp;\n                l2 = l2-&gt;next;\n            }\n            l3 = l3-&gt;next;\n        }\n\n        if(l1)\n            l3-&gt;next = l1;\n        else\n            l3-&gt;next = l2;\n\n        return head-&gt;next;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1 == NULL)  return l2;\n        if(l2 == NULL)  return l1;\n\n        if(l1-&gt;val &lt;= l2-&gt;val)  {\n            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);\n            return l1;\n        }\n        else    {\n            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);\n            return l2;\n        }\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_21  Merge Two Sorted Lists</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 21\n*  Title: Merge Two Sorted Lists\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>将两个有序的数组合并成一个数组。</p>\n<p><br></p>\n<h4 id=\"第三方介入\"><a href=\"#第三方介入\" class=\"headerlink\" title=\"第三方介入\"></a>第三方介入</h4><p>最通俗易懂的，设置一个第三方，来进行存储合并。</p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* l3 = new ListNode(0);\n        ListNode* head = l3;\n\n        while(l1 &amp;&amp; l2) {\n            if(l1-&gt;val &lt;= l2-&gt;val)  {\n                ListNode* temp = new ListNode(l1-&gt;val);\n                l3-&gt;next = temp;\n                l1 = l1-&gt;next;\n            }\n            else    {\n                ListNode* temp = new ListNode(l2-&gt;val);\n                l3-&gt;next = temp;\n                l2 = l2-&gt;next;\n            }\n            l3 = l3-&gt;next;\n        }\n\n        if(l1)\n            l3-&gt;next = l1;\n        else\n            l3-&gt;next = l2;\n\n        return head-&gt;next;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1 == NULL)  return l2;\n        if(l2 == NULL)  return l1;\n\n        if(l1-&gt;val &lt;= l2-&gt;val)  {\n            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);\n            return l1;\n        }\n        else    {\n            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);\n            return l2;\n        }\n    }\n};\n</code></pre>"},{"title":"Leetcode_22  Generate Parentheses","date":"2017-05-04T13:12:00.000Z","_content":"\nLeetcode_22  Generate Parentheses\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 22\n        *  Title: Generate Parentheses\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n括号配对种类\n必须左右配对，不可右左。\n做完以后，看了其他的解法，思维其实是一样的。\n\n\n递归的解法\n先放一个符合条件的，然后获得后面符合条件的，再讲这个与后面符合条件的组合。\n层层返回符合条件的情况，进行组合，再向上返回。\n\n终点就是 当左右括号剩余均为0的时候。\n当然，放置括号也是有限制的，当前放置的右括号数量不可超过左括号数量。\n\n\n<br/>\n\n\n\n        class Solution {\n        private:\n            vector<string> generateParenthesisTemp(int l, int r)    {\n                vector<string> vec;\n                if(l == 0 && r == 0)    {\n                    vec.push_back(\"\");\n                    return vec;\n                }\n        \n                if(l <= r)  {\n                    if(l > 0)   {\n                        string temp = \"(\";\n                        vector<string> vs = generateParenthesisTemp(l-1, r);\n                        for(int i = 0; i < vs.size(); i++)\n                            vec.push_back(temp+vs[i]);\n                    }\n        \n                    if(r > 0)   {\n                        string temp = \")\";\n                        vector<string> vs = generateParenthesisTemp(l, r-1);\n                        for(int i = 0; i < vs.size(); i++)\n                            vec.push_back(temp+vs[i]);              \n                    }\n                }\n                return vec;\n            }\n        \n        public:\n            vector<string> generateParenthesis(int n) {\n                return generateParenthesisTemp(n, n);\n            }\n        };","source":"_posts/[Leetcode]_22  Generate Parentheses.md","raw":"---\ntitle: Leetcode_22  Generate Parentheses\ndate: 2017-05-04 21:12:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_22  Generate Parentheses\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 22\n        *  Title: Generate Parentheses\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n括号配对种类\n必须左右配对，不可右左。\n做完以后，看了其他的解法，思维其实是一样的。\n\n\n递归的解法\n先放一个符合条件的，然后获得后面符合条件的，再讲这个与后面符合条件的组合。\n层层返回符合条件的情况，进行组合，再向上返回。\n\n终点就是 当左右括号剩余均为0的时候。\n当然，放置括号也是有限制的，当前放置的右括号数量不可超过左括号数量。\n\n\n<br/>\n\n\n\n        class Solution {\n        private:\n            vector<string> generateParenthesisTemp(int l, int r)    {\n                vector<string> vec;\n                if(l == 0 && r == 0)    {\n                    vec.push_back(\"\");\n                    return vec;\n                }\n        \n                if(l <= r)  {\n                    if(l > 0)   {\n                        string temp = \"(\";\n                        vector<string> vs = generateParenthesisTemp(l-1, r);\n                        for(int i = 0; i < vs.size(); i++)\n                            vec.push_back(temp+vs[i]);\n                    }\n        \n                    if(r > 0)   {\n                        string temp = \")\";\n                        vector<string> vs = generateParenthesisTemp(l, r-1);\n                        for(int i = 0; i < vs.size(); i++)\n                            vec.push_back(temp+vs[i]);              \n                    }\n                }\n                return vec;\n            }\n        \n        public:\n            vector<string> generateParenthesis(int n) {\n                return generateParenthesisTemp(n, n);\n            }\n        };","slug":"[Leetcode]_22  Generate Parentheses","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgt000tveue13wd4se5","content":"<p>Leetcode_22  Generate Parentheses</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 22\n*  Title: Generate Parentheses\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>括号配对种类<br>必须左右配对，不可右左。<br>做完以后，看了其他的解法，思维其实是一样的。</p>\n<p>递归的解法<br>先放一个符合条件的，然后获得后面符合条件的，再讲这个与后面符合条件的组合。<br>层层返回符合条件的情况，进行组合，再向上返回。</p>\n<p>终点就是 当左右括号剩余均为0的时候。<br>当然，放置括号也是有限制的，当前放置的右括号数量不可超过左括号数量。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; generateParenthesisTemp(int l, int r)    {\n        vector&lt;string&gt; vec;\n        if(l == 0 &amp;&amp; r == 0)    {\n            vec.push_back(&quot;&quot;);\n            return vec;\n        }\n\n        if(l &lt;= r)  {\n            if(l &gt; 0)   {\n                string temp = &quot;(&quot;;\n                vector&lt;string&gt; vs = generateParenthesisTemp(l-1, r);\n                for(int i = 0; i &lt; vs.size(); i++)\n                    vec.push_back(temp+vs[i]);\n            }\n\n            if(r &gt; 0)   {\n                string temp = &quot;)&quot;;\n                vector&lt;string&gt; vs = generateParenthesisTemp(l, r-1);\n                for(int i = 0; i &lt; vs.size(); i++)\n                    vec.push_back(temp+vs[i]);              \n            }\n        }\n        return vec;\n    }\n\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) {\n        return generateParenthesisTemp(n, n);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_22  Generate Parentheses</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 22\n*  Title: Generate Parentheses\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>括号配对种类<br>必须左右配对，不可右左。<br>做完以后，看了其他的解法，思维其实是一样的。</p>\n<p>递归的解法<br>先放一个符合条件的，然后获得后面符合条件的，再讲这个与后面符合条件的组合。<br>层层返回符合条件的情况，进行组合，再向上返回。</p>\n<p>终点就是 当左右括号剩余均为0的时候。<br>当然，放置括号也是有限制的，当前放置的右括号数量不可超过左括号数量。</p>\n<p><br></p>\n<pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; generateParenthesisTemp(int l, int r)    {\n        vector&lt;string&gt; vec;\n        if(l == 0 &amp;&amp; r == 0)    {\n            vec.push_back(&quot;&quot;);\n            return vec;\n        }\n\n        if(l &lt;= r)  {\n            if(l &gt; 0)   {\n                string temp = &quot;(&quot;;\n                vector&lt;string&gt; vs = generateParenthesisTemp(l-1, r);\n                for(int i = 0; i &lt; vs.size(); i++)\n                    vec.push_back(temp+vs[i]);\n            }\n\n            if(r &gt; 0)   {\n                string temp = &quot;)&quot;;\n                vector&lt;string&gt; vs = generateParenthesisTemp(l, r-1);\n                for(int i = 0; i &lt; vs.size(); i++)\n                    vec.push_back(temp+vs[i]);              \n            }\n        }\n        return vec;\n    }\n\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) {\n        return generateParenthesisTemp(n, n);\n    }\n};\n</code></pre>"},{"title":"Leetcode_23  Merge k Sorted Lists","date":"2017-05-07T13:12:00.000Z","_content":"\nLeetcode_23  Merge k Sorted Lists\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 23\n        *  Title: Merge k Sorted Lists\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n#### 齐头并进的比较\n\n1. 比较一轮，\n2. 记录最小值及最小值的位置，\n3. 创建新链加载最小值，\n4. 将最小值位置的那条链后移一位，\n5. 回到1开始重复\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\n                ListNode* master = new ListNode(0);\n                ListNode* head = master;\n        \n               while(true)  {\n                    int min = INT_MAX;\n                    int index = -1;\n        \n                    for(int i = 0; i < lists.size(); i++)   {\n                        if(lists[i] && lists[i]->val < min) {\n                            min = lists[i]->val;\n                            index = i;\n                        }\n                    }\n        \n                    if(index != -1) {\n                        master->next = new ListNode(min);\n                        master = master->next;\n                        lists[index] = lists[index]->next;\n                    }\n                    else\n                        break;\n                }\n                return head->next;    \n            }\n        };\n\n\n\n<br/>\n\n#### 齐头并进的比较 & 剪枝\n\n加了个剪枝，就是将vector中的空的链，直接移除，不再遍历。\n然后，如果删除空链后只剩下一条链，那么新链直接连在这条链后面。\n\n<br/>\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\n                ListNode* master = new ListNode(0);\n                ListNode* head = master;\n        \n               while(true)  {\n                    int min = INT_MAX;\n                    int index = -1;\n                    int needRmvIndex = -1;\n                    for(int i = 0; i < lists.size(); i++)   {\n                        if(lists[i])    {\n                            if(lists[i]->val < min) {\n                                min = lists[i]->val;\n                                index = i;\n                            }\n                        }\n                        else    {\n                            needRmvIndex = i;\n                        }\n                    }\n        \n                    if(index != -1) {\n                        master->next = new ListNode(min);\n                        master = master->next;\n                        lists[index] = lists[index]->next;\n                    }\n                    else\n                        break;\n                        \n                    if(needRmvIndex != -1)  {\n                        vector<ListNode*>::iterator iter = lists.begin()+needRmvIndex;\n                        lists.erase(iter);\n        \n                        if(lists.size() == 1 && lists[0])   {\n                            master->next = lists[0];\n                            break;\n                        }\n                    }\n                }\n                return head->next;     \n            }\n        };\n\n\n<br/>\n\n#### 两两合并\n\n不断将两条链合并，直至剩下一条链。\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        private:\n            ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n                if(l1 == NULL)\n                    return l2;\n                if(l2 == NULL)\n                    return l1;\n                if(l1->val <= l2->val){\n                    l1->next = mergeTwoLists(l1->next, l2);\n                    return l1;\n                }\n                else{\n                    l2->next = mergeTwoLists(l1, l2->next);\n                    return l2;\n                }\n            }\n        public:\n            ListNode *mergeKLists(vector<ListNode *> &lists) {\n                if(lists.empty())\n                    return NULL;\n                \n                while(lists.size() > 1){\n                    lists.push_back(mergeTwoLists(lists[0], lists[1]));\n                    lists.erase(lists.begin());\n                    lists.erase(lists.begin());\n                }\n                return lists.front();\n            }\n        };","source":"_posts/[Leetcode]_23  Merge k Sorted Lists.md","raw":"---\ntitle: Leetcode_23  Merge k Sorted Lists\ndate: 2017-05-07 21:12:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_23  Merge k Sorted Lists\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 23\n        *  Title: Merge k Sorted Lists\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n#### 齐头并进的比较\n\n1. 比较一轮，\n2. 记录最小值及最小值的位置，\n3. 创建新链加载最小值，\n4. 将最小值位置的那条链后移一位，\n5. 回到1开始重复\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\n                ListNode* master = new ListNode(0);\n                ListNode* head = master;\n        \n               while(true)  {\n                    int min = INT_MAX;\n                    int index = -1;\n        \n                    for(int i = 0; i < lists.size(); i++)   {\n                        if(lists[i] && lists[i]->val < min) {\n                            min = lists[i]->val;\n                            index = i;\n                        }\n                    }\n        \n                    if(index != -1) {\n                        master->next = new ListNode(min);\n                        master = master->next;\n                        lists[index] = lists[index]->next;\n                    }\n                    else\n                        break;\n                }\n                return head->next;    \n            }\n        };\n\n\n\n<br/>\n\n#### 齐头并进的比较 & 剪枝\n\n加了个剪枝，就是将vector中的空的链，直接移除，不再遍历。\n然后，如果删除空链后只剩下一条链，那么新链直接连在这条链后面。\n\n<br/>\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\n                ListNode* master = new ListNode(0);\n                ListNode* head = master;\n        \n               while(true)  {\n                    int min = INT_MAX;\n                    int index = -1;\n                    int needRmvIndex = -1;\n                    for(int i = 0; i < lists.size(); i++)   {\n                        if(lists[i])    {\n                            if(lists[i]->val < min) {\n                                min = lists[i]->val;\n                                index = i;\n                            }\n                        }\n                        else    {\n                            needRmvIndex = i;\n                        }\n                    }\n        \n                    if(index != -1) {\n                        master->next = new ListNode(min);\n                        master = master->next;\n                        lists[index] = lists[index]->next;\n                    }\n                    else\n                        break;\n                        \n                    if(needRmvIndex != -1)  {\n                        vector<ListNode*>::iterator iter = lists.begin()+needRmvIndex;\n                        lists.erase(iter);\n        \n                        if(lists.size() == 1 && lists[0])   {\n                            master->next = lists[0];\n                            break;\n                        }\n                    }\n                }\n                return head->next;     \n            }\n        };\n\n\n<br/>\n\n#### 两两合并\n\n不断将两条链合并，直至剩下一条链。\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        private:\n            ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n                if(l1 == NULL)\n                    return l2;\n                if(l2 == NULL)\n                    return l1;\n                if(l1->val <= l2->val){\n                    l1->next = mergeTwoLists(l1->next, l2);\n                    return l1;\n                }\n                else{\n                    l2->next = mergeTwoLists(l1, l2->next);\n                    return l2;\n                }\n            }\n        public:\n            ListNode *mergeKLists(vector<ListNode *> &lists) {\n                if(lists.empty())\n                    return NULL;\n                \n                while(lists.size() > 1){\n                    lists.push_back(mergeTwoLists(lists[0], lists[1]));\n                    lists.erase(lists.begin());\n                    lists.erase(lists.begin());\n                }\n                return lists.front();\n            }\n        };","slug":"[Leetcode]_23  Merge k Sorted Lists","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgw000vveueqbiefv3d","content":"<p>Leetcode_23  Merge k Sorted Lists</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 23\n*  Title: Merge k Sorted Lists\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"齐头并进的比较\"><a href=\"#齐头并进的比较\" class=\"headerlink\" title=\"齐头并进的比较\"></a>齐头并进的比较</h4><ol>\n<li>比较一轮，</li>\n<li>记录最小值及最小值的位置，</li>\n<li>创建新链加载最小值，</li>\n<li>将最小值位置的那条链后移一位，</li>\n<li>回到1开始重复</li>\n</ol>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        ListNode* master = new ListNode(0);\n        ListNode* head = master;\n\n       while(true)  {\n            int min = INT_MAX;\n            int index = -1;\n\n            for(int i = 0; i &lt; lists.size(); i++)   {\n                if(lists[i] &amp;&amp; lists[i]-&gt;val &lt; min) {\n                    min = lists[i]-&gt;val;\n                    index = i;\n                }\n            }\n\n            if(index != -1) {\n                master-&gt;next = new ListNode(min);\n                master = master-&gt;next;\n                lists[index] = lists[index]-&gt;next;\n            }\n            else\n                break;\n        }\n        return head-&gt;next;    \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"齐头并进的比较-amp-剪枝\"><a href=\"#齐头并进的比较-amp-剪枝\" class=\"headerlink\" title=\"齐头并进的比较 &amp; 剪枝\"></a>齐头并进的比较 &amp; 剪枝</h4><p>加了个剪枝，就是将vector中的空的链，直接移除，不再遍历。<br>然后，如果删除空链后只剩下一条链，那么新链直接连在这条链后面。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        ListNode* master = new ListNode(0);\n        ListNode* head = master;\n\n       while(true)  {\n            int min = INT_MAX;\n            int index = -1;\n            int needRmvIndex = -1;\n            for(int i = 0; i &lt; lists.size(); i++)   {\n                if(lists[i])    {\n                    if(lists[i]-&gt;val &lt; min) {\n                        min = lists[i]-&gt;val;\n                        index = i;\n                    }\n                }\n                else    {\n                    needRmvIndex = i;\n                }\n            }\n\n            if(index != -1) {\n                master-&gt;next = new ListNode(min);\n                master = master-&gt;next;\n                lists[index] = lists[index]-&gt;next;\n            }\n            else\n                break;\n\n            if(needRmvIndex != -1)  {\n                vector&lt;ListNode*&gt;::iterator iter = lists.begin()+needRmvIndex;\n                lists.erase(iter);\n\n                if(lists.size() == 1 &amp;&amp; lists[0])   {\n                    master-&gt;next = lists[0];\n                    break;\n                }\n            }\n        }\n        return head-&gt;next;     \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"两两合并\"><a href=\"#两两合并\" class=\"headerlink\" title=\"两两合并\"></a>两两合并</h4><p>不断将两条链合并，直至剩下一条链。</p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        if(l1 == NULL)\n            return l2;\n        if(l2 == NULL)\n            return l1;\n        if(l1-&gt;val &lt;= l2-&gt;val){\n            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);\n            return l1;\n        }\n        else{\n            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);\n            return l2;\n        }\n    }\npublic:\n    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {\n        if(lists.empty())\n            return NULL;\n\n        while(lists.size() &gt; 1){\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\n            lists.erase(lists.begin());\n            lists.erase(lists.begin());\n        }\n        return lists.front();\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_23  Merge k Sorted Lists</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 23\n*  Title: Merge k Sorted Lists\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"齐头并进的比较\"><a href=\"#齐头并进的比较\" class=\"headerlink\" title=\"齐头并进的比较\"></a>齐头并进的比较</h4><ol>\n<li>比较一轮，</li>\n<li>记录最小值及最小值的位置，</li>\n<li>创建新链加载最小值，</li>\n<li>将最小值位置的那条链后移一位，</li>\n<li>回到1开始重复</li>\n</ol>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        ListNode* master = new ListNode(0);\n        ListNode* head = master;\n\n       while(true)  {\n            int min = INT_MAX;\n            int index = -1;\n\n            for(int i = 0; i &lt; lists.size(); i++)   {\n                if(lists[i] &amp;&amp; lists[i]-&gt;val &lt; min) {\n                    min = lists[i]-&gt;val;\n                    index = i;\n                }\n            }\n\n            if(index != -1) {\n                master-&gt;next = new ListNode(min);\n                master = master-&gt;next;\n                lists[index] = lists[index]-&gt;next;\n            }\n            else\n                break;\n        }\n        return head-&gt;next;    \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"齐头并进的比较-amp-剪枝\"><a href=\"#齐头并进的比较-amp-剪枝\" class=\"headerlink\" title=\"齐头并进的比较 &amp; 剪枝\"></a>齐头并进的比较 &amp; 剪枝</h4><p>加了个剪枝，就是将vector中的空的链，直接移除，不再遍历。<br>然后，如果删除空链后只剩下一条链，那么新链直接连在这条链后面。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        ListNode* master = new ListNode(0);\n        ListNode* head = master;\n\n       while(true)  {\n            int min = INT_MAX;\n            int index = -1;\n            int needRmvIndex = -1;\n            for(int i = 0; i &lt; lists.size(); i++)   {\n                if(lists[i])    {\n                    if(lists[i]-&gt;val &lt; min) {\n                        min = lists[i]-&gt;val;\n                        index = i;\n                    }\n                }\n                else    {\n                    needRmvIndex = i;\n                }\n            }\n\n            if(index != -1) {\n                master-&gt;next = new ListNode(min);\n                master = master-&gt;next;\n                lists[index] = lists[index]-&gt;next;\n            }\n            else\n                break;\n\n            if(needRmvIndex != -1)  {\n                vector&lt;ListNode*&gt;::iterator iter = lists.begin()+needRmvIndex;\n                lists.erase(iter);\n\n                if(lists.size() == 1 &amp;&amp; lists[0])   {\n                    master-&gt;next = lists[0];\n                    break;\n                }\n            }\n        }\n        return head-&gt;next;     \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"两两合并\"><a href=\"#两两合并\" class=\"headerlink\" title=\"两两合并\"></a>两两合并</h4><p>不断将两条链合并，直至剩下一条链。</p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        if(l1 == NULL)\n            return l2;\n        if(l2 == NULL)\n            return l1;\n        if(l1-&gt;val &lt;= l2-&gt;val){\n            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);\n            return l1;\n        }\n        else{\n            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);\n            return l2;\n        }\n    }\npublic:\n    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {\n        if(lists.empty())\n            return NULL;\n\n        while(lists.size() &gt; 1){\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\n            lists.erase(lists.begin());\n            lists.erase(lists.begin());\n        }\n        return lists.front();\n    }\n};\n</code></pre>"},{"title":"Leetcode_24  Swap Nodes in Pairs","date":"2017-05-08T13:45:00.000Z","_content":"\nLeetcode_24  Swap Nodes in Pairs\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 24\n        *  Title: Swap Nodes in Pairs\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n两个指针，一个前一个后，然后互换值，如果没有后面的就不换。\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* swapPairs(ListNode* head) {\n                ListNode* ans = head;\n                ListNode* pre = head;\n        \n                while(pre && pre->next) {\n                    ListNode* bck = pre->next;\n        \n                    pre->val += bck->val;\n                    bck->val = pre->val - bck->val;\n                    pre->val -= bck->val;\n        \n                    pre = bck->next;\n                }\n        \n                return ans;\n            }\n        };","source":"_posts/[Leetcode]_24  Swap Nodes in Pairs.md","raw":"---\ntitle: Leetcode_24  Swap Nodes in Pairs\ndate: 2017-05-08 21:45:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_24  Swap Nodes in Pairs\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 24\n        *  Title: Swap Nodes in Pairs\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n两个指针，一个前一个后，然后互换值，如果没有后面的就不换。\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* swapPairs(ListNode* head) {\n                ListNode* ans = head;\n                ListNode* pre = head;\n        \n                while(pre && pre->next) {\n                    ListNode* bck = pre->next;\n        \n                    pre->val += bck->val;\n                    bck->val = pre->val - bck->val;\n                    pre->val -= bck->val;\n        \n                    pre = bck->next;\n                }\n        \n                return ans;\n            }\n        };","slug":"[Leetcode]_24  Swap Nodes in Pairs","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabgz000yveue837t1emp","content":"<p>Leetcode_24  Swap Nodes in Pairs</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 24\n*  Title: Swap Nodes in Pairs\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>两个指针，一个前一个后，然后互换值，如果没有后面的就不换。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* ans = head;\n        ListNode* pre = head;\n\n        while(pre &amp;&amp; pre-&gt;next) {\n            ListNode* bck = pre-&gt;next;\n\n            pre-&gt;val += bck-&gt;val;\n            bck-&gt;val = pre-&gt;val - bck-&gt;val;\n            pre-&gt;val -= bck-&gt;val;\n\n            pre = bck-&gt;next;\n        }\n\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_24  Swap Nodes in Pairs</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 24\n*  Title: Swap Nodes in Pairs\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>两个指针，一个前一个后，然后互换值，如果没有后面的就不换。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* ans = head;\n        ListNode* pre = head;\n\n        while(pre &amp;&amp; pre-&gt;next) {\n            ListNode* bck = pre-&gt;next;\n\n            pre-&gt;val += bck-&gt;val;\n            bck-&gt;val = pre-&gt;val - bck-&gt;val;\n            pre-&gt;val -= bck-&gt;val;\n\n            pre = bck-&gt;next;\n        }\n\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_25  Reverse Nodes in k-Group","date":"2017-05-10T15:00:00.000Z","_content":"\nLeetcode_25  Reverse Nodes in k-Group\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 25\n        *  Title: Reverse Nodes in k-Group\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题目要求，将一组链表根据给定的k值，进行部分逆序。\n而且，最后不足k的部分，要按照原来的顺序。\n\n\n#### 1\n\n以[1,2,3,4,5] k=3 为例\n\n解题方法：\n\n\n            pre     cur     nxt\n        1.  0   -   1   -   2   -   3   -   4   -   5\n\n            pre     nxt     cur     \n        2.  0   -   2   -   1   -   3   -   4   -   5\n\n\n            pre             cur     nxt\n        3.  0   -   2   -   1   -   3   -   4   -   5\n\n            pre     nxt             cur\n        4.  0   -   3   -   2   -   1   -   4   -   5\n\n\n其实，步骤1、2 与 步骤3、4 是一样的，不断重复这些步骤。\n每次进行一次步骤，计数一次，直到到k-1；则pre移到cur的位置，继续重复以上步骤。\n\n最后，到后面没有后续值后，如果计数器不到k-1，则再把后面的值翻过来一遍。\n\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* reverseKGroup(ListNode* head, int k) {\n                if(head == NULL || k == 1)\n                    return head;\n        \n                ListNode *ori = new ListNode(0);\n                ori->next = head;\n                ListNode *cur, *nxt, *pre = ori;\n        \n                int counter;\n                while(true) {\n                    counter = k;\n                    cur = pre->next;\n                    nxt = cur->next;\n        \n                    while(cur->next and counter-- > 1)  {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n        \n                    if(cur->next == NULL)\n                        break;\n                    pre = cur;\n                }\n        \n                if(counter > 1) {\n                    counter = k - counter;\n                    cur = pre->next;\n                    nxt = cur->next;\n                    \n                    while(counter--)    {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n                }\n        \n                return ori->next;\n            }\n        };\n\n\n\n<br/>\n\n#### 2\n\n这个方法是我看热门解题里的，通过遍历一遍链表，就不用把最后反过来的再翻回去了。\n但是结果是缩短了代码行数。\n\n\n\n        class Solution {\n        public:\n            ListNode *reverseKGroup(ListNode *head, int k) {\n                if(head == NULL || k == 1) \n                    return head;\n        \n                int num = 0;\n                ListNode *ori = new ListNode(-1);\n                ori->next = head;\n                ListNode *cur = ori, *nxt, *pre = ori;\n                \n                while(cur = cur->next) \n                    num++;\n        \n                while(num >= k) {\n                    cur = pre->next;\n                    nxt = cur->next;\n                    for(int i = 1; i < k ; ++i) {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n                    pre = cur;\n                    num -= k;\n                }\n                return ori->next;\n            }\n        };","source":"_posts/[Leetcode]_25  Reverse Nodes in k-Group.md","raw":"---\ntitle: Leetcode_25  Reverse Nodes in k-Group\ndate: 2017-05-10 23:00:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_25  Reverse Nodes in k-Group\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 25\n        *  Title: Reverse Nodes in k-Group\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题目要求，将一组链表根据给定的k值，进行部分逆序。\n而且，最后不足k的部分，要按照原来的顺序。\n\n\n#### 1\n\n以[1,2,3,4,5] k=3 为例\n\n解题方法：\n\n\n            pre     cur     nxt\n        1.  0   -   1   -   2   -   3   -   4   -   5\n\n            pre     nxt     cur     \n        2.  0   -   2   -   1   -   3   -   4   -   5\n\n\n            pre             cur     nxt\n        3.  0   -   2   -   1   -   3   -   4   -   5\n\n            pre     nxt             cur\n        4.  0   -   3   -   2   -   1   -   4   -   5\n\n\n其实，步骤1、2 与 步骤3、4 是一样的，不断重复这些步骤。\n每次进行一次步骤，计数一次，直到到k-1；则pre移到cur的位置，继续重复以上步骤。\n\n最后，到后面没有后续值后，如果计数器不到k-1，则再把后面的值翻过来一遍。\n\n\n<br/>\n\n\n\n        /**\n         * Definition for singly-linked list.\n         * struct ListNode {\n         *     int val;\n         *     ListNode *next;\n         *     ListNode(int x) : val(x), next(NULL) {}\n         * };\n         */\n        class Solution {\n        public:\n            ListNode* reverseKGroup(ListNode* head, int k) {\n                if(head == NULL || k == 1)\n                    return head;\n        \n                ListNode *ori = new ListNode(0);\n                ori->next = head;\n                ListNode *cur, *nxt, *pre = ori;\n        \n                int counter;\n                while(true) {\n                    counter = k;\n                    cur = pre->next;\n                    nxt = cur->next;\n        \n                    while(cur->next and counter-- > 1)  {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n        \n                    if(cur->next == NULL)\n                        break;\n                    pre = cur;\n                }\n        \n                if(counter > 1) {\n                    counter = k - counter;\n                    cur = pre->next;\n                    nxt = cur->next;\n                    \n                    while(counter--)    {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n                }\n        \n                return ori->next;\n            }\n        };\n\n\n\n<br/>\n\n#### 2\n\n这个方法是我看热门解题里的，通过遍历一遍链表，就不用把最后反过来的再翻回去了。\n但是结果是缩短了代码行数。\n\n\n\n        class Solution {\n        public:\n            ListNode *reverseKGroup(ListNode *head, int k) {\n                if(head == NULL || k == 1) \n                    return head;\n        \n                int num = 0;\n                ListNode *ori = new ListNode(-1);\n                ori->next = head;\n                ListNode *cur = ori, *nxt, *pre = ori;\n                \n                while(cur = cur->next) \n                    num++;\n        \n                while(num >= k) {\n                    cur = pre->next;\n                    nxt = cur->next;\n                    for(int i = 1; i < k ; ++i) {\n                        cur->next = nxt->next;\n                        nxt->next = pre->next;\n                        pre->next = nxt;\n                        nxt = cur->next;\n                    }\n                    pre = cur;\n                    num -= k;\n                }\n                return ori->next;\n            }\n        };","slug":"[Leetcode]_25  Reverse Nodes in k-Group","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabh20010veueixni50l0","content":"<p>Leetcode_25  Reverse Nodes in k-Group</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 25\n*  Title: Reverse Nodes in k-Group\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题目要求，将一组链表根据给定的k值，进行部分逆序。<br>而且，最后不足k的部分，要按照原来的顺序。</p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p>以[1,2,3,4,5] k=3 为例</p>\n<p>解题方法：</p>\n<pre><code>    pre     cur     nxt\n1.  0   -   1   -   2   -   3   -   4   -   5\n\n    pre     nxt     cur     \n2.  0   -   2   -   1   -   3   -   4   -   5\n\n\n    pre             cur     nxt\n3.  0   -   2   -   1   -   3   -   4   -   5\n\n    pre     nxt             cur\n4.  0   -   3   -   2   -   1   -   4   -   5\n</code></pre><p>其实，步骤1、2 与 步骤3、4 是一样的，不断重复这些步骤。<br>每次进行一次步骤，计数一次，直到到k-1；则pre移到cur的位置，继续重复以上步骤。</p>\n<p>最后，到后面没有后续值后，如果计数器不到k-1，则再把后面的值翻过来一遍。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(head == NULL || k == 1)\n            return head;\n\n        ListNode *ori = new ListNode(0);\n        ori-&gt;next = head;\n        ListNode *cur, *nxt, *pre = ori;\n\n        int counter;\n        while(true) {\n            counter = k;\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n\n            while(cur-&gt;next and counter-- &gt; 1)  {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n\n            if(cur-&gt;next == NULL)\n                break;\n            pre = cur;\n        }\n\n        if(counter &gt; 1) {\n            counter = k - counter;\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n\n            while(counter--)    {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n        }\n\n        return ori-&gt;next;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p>这个方法是我看热门解题里的，通过遍历一遍链表，就不用把最后反过来的再翻回去了。<br>但是结果是缩短了代码行数。</p>\n<pre><code>class Solution {\npublic:\n    ListNode *reverseKGroup(ListNode *head, int k) {\n        if(head == NULL || k == 1) \n            return head;\n\n        int num = 0;\n        ListNode *ori = new ListNode(-1);\n        ori-&gt;next = head;\n        ListNode *cur = ori, *nxt, *pre = ori;\n\n        while(cur = cur-&gt;next) \n            num++;\n\n        while(num &gt;= k) {\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n            for(int i = 1; i &lt; k ; ++i) {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n            pre = cur;\n            num -= k;\n        }\n        return ori-&gt;next;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_25  Reverse Nodes in k-Group</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 25\n*  Title: Reverse Nodes in k-Group\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题目要求，将一组链表根据给定的k值，进行部分逆序。<br>而且，最后不足k的部分，要按照原来的顺序。</p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p>以[1,2,3,4,5] k=3 为例</p>\n<p>解题方法：</p>\n<pre><code>    pre     cur     nxt\n1.  0   -   1   -   2   -   3   -   4   -   5\n\n    pre     nxt     cur     \n2.  0   -   2   -   1   -   3   -   4   -   5\n\n\n    pre             cur     nxt\n3.  0   -   2   -   1   -   3   -   4   -   5\n\n    pre     nxt             cur\n4.  0   -   3   -   2   -   1   -   4   -   5\n</code></pre><p>其实，步骤1、2 与 步骤3、4 是一样的，不断重复这些步骤。<br>每次进行一次步骤，计数一次，直到到k-1；则pre移到cur的位置，继续重复以上步骤。</p>\n<p>最后，到后面没有后续值后，如果计数器不到k-1，则再把后面的值翻过来一遍。</p>\n<p><br></p>\n<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(head == NULL || k == 1)\n            return head;\n\n        ListNode *ori = new ListNode(0);\n        ori-&gt;next = head;\n        ListNode *cur, *nxt, *pre = ori;\n\n        int counter;\n        while(true) {\n            counter = k;\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n\n            while(cur-&gt;next and counter-- &gt; 1)  {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n\n            if(cur-&gt;next == NULL)\n                break;\n            pre = cur;\n        }\n\n        if(counter &gt; 1) {\n            counter = k - counter;\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n\n            while(counter--)    {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n        }\n\n        return ori-&gt;next;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p>这个方法是我看热门解题里的，通过遍历一遍链表，就不用把最后反过来的再翻回去了。<br>但是结果是缩短了代码行数。</p>\n<pre><code>class Solution {\npublic:\n    ListNode *reverseKGroup(ListNode *head, int k) {\n        if(head == NULL || k == 1) \n            return head;\n\n        int num = 0;\n        ListNode *ori = new ListNode(-1);\n        ori-&gt;next = head;\n        ListNode *cur = ori, *nxt, *pre = ori;\n\n        while(cur = cur-&gt;next) \n            num++;\n\n        while(num &gt;= k) {\n            cur = pre-&gt;next;\n            nxt = cur-&gt;next;\n            for(int i = 1; i &lt; k ; ++i) {\n                cur-&gt;next = nxt-&gt;next;\n                nxt-&gt;next = pre-&gt;next;\n                pre-&gt;next = nxt;\n                nxt = cur-&gt;next;\n            }\n            pre = cur;\n            num -= k;\n        }\n        return ori-&gt;next;\n    }\n};\n</code></pre>"},{"title":"Leetcode_26  Remove Duplicates from Sorted Array","date":"2017-05-13T13:12:00.000Z","_content":"\nLeetcode_26  Remove Duplicates from Sorted Array\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 26\n        *  Title: Remove Duplicates from Sorted Array\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题目给出的几个注意点：\n1. 所给的数组是排序的（很重要）\n2. 其实答案是根据返回的数组长度而截取原数组所得的数组\n3. 空间复杂度在O(1)\n\n#### 记录重复数量，不重复的序列号，当前比较的数值\n\n借助几个变量存储上述的值，在每次比较数值变化的时候，来改变序列号与比较数值，其他时候递增重复数值，即可。\n\n\n\n<br/>\n\n\n\n        class Solution {\n        public:\n            int removeDuplicates(vector<int>& nums) {\n                int index = 0, cur = INT_MIN, repeat = 0, len = nums.size();\n        \n                for(int i = 0; i < len; i++)    {\n                    if(nums[i] > cur)   {\n                        cur = nums[i];\n                        nums[index++] = cur;\n                    }\n                    else\n                        ++repeat;\n                }\n        \n                return len - repeat;\n            }\n        };\n\n\n\n<br/>\n\n#### 更为精简\n\n只用一个变量，来存储重复的数量，\n如果连续的两个数值不等，就将之前重复的替换掉（根据重复的数量可以求出）。\n\n\n\n        class Solution {\n        public:\n            int removeDuplicates(vector<int>& nums) {\n                int repeat = 0, len = nums.size();\n                for(int i = 1; i < len; i++){\n                    if(nums[i] == nums[i-1]) repeat++;\n                    else nums[i-repeat] = nums[i];\n                }\n                return len-repeat;\n            }\n        };","source":"_posts/[Leetcode]_26  Remove Duplicates from Sorted Array.md","raw":"---\ntitle: Leetcode_26  Remove Duplicates from Sorted Array\ndate: 2017-05-13 21:12:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_26  Remove Duplicates from Sorted Array\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 26\n        *  Title: Remove Duplicates from Sorted Array\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题目给出的几个注意点：\n1. 所给的数组是排序的（很重要）\n2. 其实答案是根据返回的数组长度而截取原数组所得的数组\n3. 空间复杂度在O(1)\n\n#### 记录重复数量，不重复的序列号，当前比较的数值\n\n借助几个变量存储上述的值，在每次比较数值变化的时候，来改变序列号与比较数值，其他时候递增重复数值，即可。\n\n\n\n<br/>\n\n\n\n        class Solution {\n        public:\n            int removeDuplicates(vector<int>& nums) {\n                int index = 0, cur = INT_MIN, repeat = 0, len = nums.size();\n        \n                for(int i = 0; i < len; i++)    {\n                    if(nums[i] > cur)   {\n                        cur = nums[i];\n                        nums[index++] = cur;\n                    }\n                    else\n                        ++repeat;\n                }\n        \n                return len - repeat;\n            }\n        };\n\n\n\n<br/>\n\n#### 更为精简\n\n只用一个变量，来存储重复的数量，\n如果连续的两个数值不等，就将之前重复的替换掉（根据重复的数量可以求出）。\n\n\n\n        class Solution {\n        public:\n            int removeDuplicates(vector<int>& nums) {\n                int repeat = 0, len = nums.size();\n                for(int i = 1; i < len; i++){\n                    if(nums[i] == nums[i-1]) repeat++;\n                    else nums[i-repeat] = nums[i];\n                }\n                return len-repeat;\n            }\n        };","slug":"[Leetcode]_26  Remove Duplicates from Sorted Array","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabh60013veuetz6zhnwk","content":"<p>Leetcode_26  Remove Duplicates from Sorted Array</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 26\n*  Title: Remove Duplicates from Sorted Array\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题目给出的几个注意点：</p>\n<ol>\n<li>所给的数组是排序的（很重要）</li>\n<li>其实答案是根据返回的数组长度而截取原数组所得的数组</li>\n<li>空间复杂度在O(1)</li>\n</ol>\n<h4 id=\"记录重复数量，不重复的序列号，当前比较的数值\"><a href=\"#记录重复数量，不重复的序列号，当前比较的数值\" class=\"headerlink\" title=\"记录重复数量，不重复的序列号，当前比较的数值\"></a>记录重复数量，不重复的序列号，当前比较的数值</h4><p>借助几个变量存储上述的值，在每次比较数值变化的时候，来改变序列号与比较数值，其他时候递增重复数值，即可。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int index = 0, cur = INT_MIN, repeat = 0, len = nums.size();\n\n        for(int i = 0; i &lt; len; i++)    {\n            if(nums[i] &gt; cur)   {\n                cur = nums[i];\n                nums[index++] = cur;\n            }\n            else\n                ++repeat;\n        }\n\n        return len - repeat;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"更为精简\"><a href=\"#更为精简\" class=\"headerlink\" title=\"更为精简\"></a>更为精简</h4><p>只用一个变量，来存储重复的数量，<br>如果连续的两个数值不等，就将之前重复的替换掉（根据重复的数量可以求出）。</p>\n<pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int repeat = 0, len = nums.size();\n        for(int i = 1; i &lt; len; i++){\n            if(nums[i] == nums[i-1]) repeat++;\n            else nums[i-repeat] = nums[i];\n        }\n        return len-repeat;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_26  Remove Duplicates from Sorted Array</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 26\n*  Title: Remove Duplicates from Sorted Array\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题目给出的几个注意点：</p>\n<ol>\n<li>所给的数组是排序的（很重要）</li>\n<li>其实答案是根据返回的数组长度而截取原数组所得的数组</li>\n<li>空间复杂度在O(1)</li>\n</ol>\n<h4 id=\"记录重复数量，不重复的序列号，当前比较的数值\"><a href=\"#记录重复数量，不重复的序列号，当前比较的数值\" class=\"headerlink\" title=\"记录重复数量，不重复的序列号，当前比较的数值\"></a>记录重复数量，不重复的序列号，当前比较的数值</h4><p>借助几个变量存储上述的值，在每次比较数值变化的时候，来改变序列号与比较数值，其他时候递增重复数值，即可。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int index = 0, cur = INT_MIN, repeat = 0, len = nums.size();\n\n        for(int i = 0; i &lt; len; i++)    {\n            if(nums[i] &gt; cur)   {\n                cur = nums[i];\n                nums[index++] = cur;\n            }\n            else\n                ++repeat;\n        }\n\n        return len - repeat;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"更为精简\"><a href=\"#更为精简\" class=\"headerlink\" title=\"更为精简\"></a>更为精简</h4><p>只用一个变量，来存储重复的数量，<br>如果连续的两个数值不等，就将之前重复的替换掉（根据重复的数量可以求出）。</p>\n<pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int repeat = 0, len = nums.size();\n        for(int i = 1; i &lt; len; i++){\n            if(nums[i] == nums[i-1]) repeat++;\n            else nums[i-repeat] = nums[i];\n        }\n        return len-repeat;\n    }\n};\n</code></pre>"},{"title":"Leetcode_27  Remove Element","date":"2017-05-15T14:17:00.000Z","_content":"\nLeetcode_27  Remove Element\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 27\n        *  Title: Remove Element\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n#### 记录不重复的序列号，然后往前并。\n\n\n\n        class Solution {\n        public:\n            int removeElement(vector<int>& nums, int val) {\n                int index = 0, len = nums.size();\n                for(int i = 0; i < len ; i++) \n                    if(nums[i] != val) \n                        nums[index++] = nums[i];\n                return index;       \n            }\n        };\n\n\n\n<br/>\n\n#### 从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\n\n\n        class Solution {\n        public:\n            int removeElement(vector<int>& nums, int val) {\n                int repeat = 0, len = nums.size() - 1;\n        \n                for(int i = len; i >= 0; i--)   {\n                    if(nums[i] == val)  {\n                        nums[i] ^= nums[len-repeat];\n                        nums[len-repeat] ^= nums[i];\n                        nums[i] ^= nums[len-repeat];\n                        ++repeat;\n                    }\n                }\n        \n                return (len - repeat + 1);\n            }\n        };\n\n\n\n","source":"_posts/[Leetcode]_27  Remove Element.md","raw":"---\ntitle: Leetcode_27  Remove Element\ndate: 2017-05-15 22:17:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_27  Remove Element\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 27\n        *  Title: Remove Element\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n#### 记录不重复的序列号，然后往前并。\n\n\n\n        class Solution {\n        public:\n            int removeElement(vector<int>& nums, int val) {\n                int index = 0, len = nums.size();\n                for(int i = 0; i < len ; i++) \n                    if(nums[i] != val) \n                        nums[index++] = nums[i];\n                return index;       \n            }\n        };\n\n\n\n<br/>\n\n#### 从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\n\n\n        class Solution {\n        public:\n            int removeElement(vector<int>& nums, int val) {\n                int repeat = 0, len = nums.size() - 1;\n        \n                for(int i = len; i >= 0; i--)   {\n                    if(nums[i] == val)  {\n                        nums[i] ^= nums[len-repeat];\n                        nums[len-repeat] ^= nums[i];\n                        nums[i] ^= nums[len-repeat];\n                        ++repeat;\n                    }\n                }\n        \n                return (len - repeat + 1);\n            }\n        };\n\n\n\n","slug":"[Leetcode]_27  Remove Element","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabh90015veuecszp9cp1","content":"<p>Leetcode_27  Remove Element</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 27\n*  Title: Remove Element\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"记录不重复的序列号，然后往前并。\"><a href=\"#记录不重复的序列号，然后往前并。\" class=\"headerlink\" title=\"记录不重复的序列号，然后往前并。\"></a>记录不重复的序列号，然后往前并。</h4><pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int index = 0, len = nums.size();\n        for(int i = 0; i &lt; len ; i++) \n            if(nums[i] != val) \n                nums[index++] = nums[i];\n        return index;       \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\"><a href=\"#从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\" class=\"headerlink\" title=\"从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\"></a>从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）</h4><pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int repeat = 0, len = nums.size() - 1;\n\n        for(int i = len; i &gt;= 0; i--)   {\n            if(nums[i] == val)  {\n                nums[i] ^= nums[len-repeat];\n                nums[len-repeat] ^= nums[i];\n                nums[i] ^= nums[len-repeat];\n                ++repeat;\n            }\n        }\n\n        return (len - repeat + 1);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_27  Remove Element</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 27\n*  Title: Remove Element\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<h4 id=\"记录不重复的序列号，然后往前并。\"><a href=\"#记录不重复的序列号，然后往前并。\" class=\"headerlink\" title=\"记录不重复的序列号，然后往前并。\"></a>记录不重复的序列号，然后往前并。</h4><pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int index = 0, len = nums.size();\n        for(int i = 0; i &lt; len ; i++) \n            if(nums[i] != val) \n                nums[index++] = nums[i];\n        return index;       \n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\"><a href=\"#从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\" class=\"headerlink\" title=\"从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）\"></a>从后往前遍历，如果是目标值，跟尾部的值交换（根据出现目标值的个数）</h4><pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int repeat = 0, len = nums.size() - 1;\n\n        for(int i = len; i &gt;= 0; i--)   {\n            if(nums[i] == val)  {\n                nums[i] ^= nums[len-repeat];\n                nums[len-repeat] ^= nums[i];\n                nums[i] ^= nums[len-repeat];\n                ++repeat;\n            }\n        }\n\n        return (len - repeat + 1);\n    }\n};\n</code></pre>"},{"title":"Leetcode_28  Implement strStr()","date":"2017-05-30T14:17:00.000Z","_content":"\nLeetcode_28  Implement strStr()\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 28\n        *  Title: Implement strStr()\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n字符串的模式匹配\n\n通过这一道题，可以练习一下这些匹配算法。\n\n<br/>\n\n#### BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)\n最普通的模式匹配算法。\n依次比较，如果匹配失败，从头再来。\n可以看出，是一个很暴力的算法。\n\n加了两个小剪枝，\n1. 如果匹配串长度大于原串，直接返回-1\n2. 如果两串长度相等，直接判断值是否相等，返回相应值。（不加会TLE）\n3. 如果匹配串为空，返回0\n\n\n\n        class Solution {\n        public:\n            int strStr(string haystack, string needle) {\n                int lenHs = haystack.length();\n                int lenNe = needle.length();\n                if(lenHs < lenNe)\n                    return -1;\n                else if(lenHs == lenNe)\n                    if(haystack == needle)\n                        return 0;\n                    else\n                        return -1;\n                else if(lenNe == 0)\n                    return 0;\n    \n                int i = 0, j = 0;\n                while(i < lenHs)  {\n                    if(haystack[i] == needle[j])  {\n                        ++i;\n                        ++j;\n    \n                    if(j == lenNe)\n                        return i - j;\n                    }\n                    else  {\n                        i = i - j + 1;\n                        j = 0;\n                    }\n                }\n    \n                return -1;\n            }\n        };\n\n\n<br/>\n\n#### KMP算法  时间复杂度：O(m+n)\n\n举个板栗：\n原串：abababc | 匹配串是：ababc\n当我比较到原串的第五个字符a 与 匹配串的第五个字符c，发现匹配失败；\n这时，我不需要从原串第二个字符b 与 匹配串第一个字符a，进行比较；\n只需要将原串的第三个字符a 与 匹配串的第三个字符a，进行比较；\n因为它们前缀是部分重复的。\n\n这个特性是由匹配串来决定的，所以，KMP算法，重要在于求出匹配失败后，跳回的部分，即 求出匹配串的Next数组。\n\nnext数组如何求呢？\n1. 第一个字符next值设置为-1\n2. 是从前往后推到的，就是next[1] 是由str[0] 与 next[0] 决定的\n3. 如果前一个数的next值为-1，则此next值为0（-1 + 1）\n4. 如果前一个数next值不为-1，比较前一个字符 与 前next值对应的字符；如果字符相等，则next值为前一个next值+1；如果不等则继续往前比较。\n    以 index = 2 为例，应该比较 str[1](b) 与 str[next[1]](b)，相等，所以 next[2] = next[1] + 1 = 1\n    以 index = 3 为例, 比较 str[2](a) 与 str[next[2]](b), 不相等， 继续比较 str[2](a) 与 str[0](next[index = 2] -> index 1 -> 因为不相等 -> next[index = 1] -> index = 0), 也不相等，但是此时 next[index] 为-1，所以next[3] = 0(-1 + 1)\n\n\nindex     0   1   2   3   4   5   6\nstr       b   b   a   b   b   a   \nnext      -1  0   1   0   1   2   3 \n\n\n\n        class Solution {\n        private:\n            int NEXT[100001];\n      \n        public:\n            void createNextArray(string str, int len) {\n                int i = 0, j = -1;\n    \n                NEXT[0] = -1;\n                while(i < len)  {\n                if(j == -1 || str[i] == str[j]) \n                    NEXT[++i] = ++j;\n                else\n                    j = NEXT[j];\n                }\n            }\n    \n            int strStr(string haystack, string needle) {\n                int lenHs = haystack.length();\n                int lenNe = needle.length();\n                if(lenHs < lenNe)\n                    return -1;\n                else if(lenHs == lenNe)\n                    if(haystack == needle)\n                        return 0;\n                    else\n                        return -1;\n                else if(lenNe == 0)\n                    return 0;\n                    \n                memset(NEXT, -1, sizeof(NEXT));        \n                createNextArray(needle, lenNe+1);\n    \n                int i = 0, j = 0;\n                while(i < lenHs) {\n                    if(haystack[i] == needle[j])  {\n                        ++i;\n                        ++j;\n    \n                        if(j == lenNe)\n                            return i - j;\n                    }\n                    else\n                        if(NEXT[j] == -1) {\n                            ++i;\n                            j = 0;\n                        }\n                        else\n                            j = NEXT[j];\n                }\n    \n                return -1;\n            }\n        };","source":"_posts/[Leetcode]_28  Implement strStr().md","raw":"---\ntitle: Leetcode_28  Implement strStr()\ndate: 2017-05-30 22:17:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_28  Implement strStr()\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 28\n        *  Title: Implement strStr()\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n字符串的模式匹配\n\n通过这一道题，可以练习一下这些匹配算法。\n\n<br/>\n\n#### BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)\n最普通的模式匹配算法。\n依次比较，如果匹配失败，从头再来。\n可以看出，是一个很暴力的算法。\n\n加了两个小剪枝，\n1. 如果匹配串长度大于原串，直接返回-1\n2. 如果两串长度相等，直接判断值是否相等，返回相应值。（不加会TLE）\n3. 如果匹配串为空，返回0\n\n\n\n        class Solution {\n        public:\n            int strStr(string haystack, string needle) {\n                int lenHs = haystack.length();\n                int lenNe = needle.length();\n                if(lenHs < lenNe)\n                    return -1;\n                else if(lenHs == lenNe)\n                    if(haystack == needle)\n                        return 0;\n                    else\n                        return -1;\n                else if(lenNe == 0)\n                    return 0;\n    \n                int i = 0, j = 0;\n                while(i < lenHs)  {\n                    if(haystack[i] == needle[j])  {\n                        ++i;\n                        ++j;\n    \n                    if(j == lenNe)\n                        return i - j;\n                    }\n                    else  {\n                        i = i - j + 1;\n                        j = 0;\n                    }\n                }\n    \n                return -1;\n            }\n        };\n\n\n<br/>\n\n#### KMP算法  时间复杂度：O(m+n)\n\n举个板栗：\n原串：abababc | 匹配串是：ababc\n当我比较到原串的第五个字符a 与 匹配串的第五个字符c，发现匹配失败；\n这时，我不需要从原串第二个字符b 与 匹配串第一个字符a，进行比较；\n只需要将原串的第三个字符a 与 匹配串的第三个字符a，进行比较；\n因为它们前缀是部分重复的。\n\n这个特性是由匹配串来决定的，所以，KMP算法，重要在于求出匹配失败后，跳回的部分，即 求出匹配串的Next数组。\n\nnext数组如何求呢？\n1. 第一个字符next值设置为-1\n2. 是从前往后推到的，就是next[1] 是由str[0] 与 next[0] 决定的\n3. 如果前一个数的next值为-1，则此next值为0（-1 + 1）\n4. 如果前一个数next值不为-1，比较前一个字符 与 前next值对应的字符；如果字符相等，则next值为前一个next值+1；如果不等则继续往前比较。\n    以 index = 2 为例，应该比较 str[1](b) 与 str[next[1]](b)，相等，所以 next[2] = next[1] + 1 = 1\n    以 index = 3 为例, 比较 str[2](a) 与 str[next[2]](b), 不相等， 继续比较 str[2](a) 与 str[0](next[index = 2] -> index 1 -> 因为不相等 -> next[index = 1] -> index = 0), 也不相等，但是此时 next[index] 为-1，所以next[3] = 0(-1 + 1)\n\n\nindex     0   1   2   3   4   5   6\nstr       b   b   a   b   b   a   \nnext      -1  0   1   0   1   2   3 \n\n\n\n        class Solution {\n        private:\n            int NEXT[100001];\n      \n        public:\n            void createNextArray(string str, int len) {\n                int i = 0, j = -1;\n    \n                NEXT[0] = -1;\n                while(i < len)  {\n                if(j == -1 || str[i] == str[j]) \n                    NEXT[++i] = ++j;\n                else\n                    j = NEXT[j];\n                }\n            }\n    \n            int strStr(string haystack, string needle) {\n                int lenHs = haystack.length();\n                int lenNe = needle.length();\n                if(lenHs < lenNe)\n                    return -1;\n                else if(lenHs == lenNe)\n                    if(haystack == needle)\n                        return 0;\n                    else\n                        return -1;\n                else if(lenNe == 0)\n                    return 0;\n                    \n                memset(NEXT, -1, sizeof(NEXT));        \n                createNextArray(needle, lenNe+1);\n    \n                int i = 0, j = 0;\n                while(i < lenHs) {\n                    if(haystack[i] == needle[j])  {\n                        ++i;\n                        ++j;\n    \n                        if(j == lenNe)\n                            return i - j;\n                    }\n                    else\n                        if(NEXT[j] == -1) {\n                            ++i;\n                            j = 0;\n                        }\n                        else\n                            j = NEXT[j];\n                }\n    \n                return -1;\n            }\n        };","slug":"[Leetcode]_28  Implement strStr()","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabhe0018veuek3rnva60","content":"<p>Leetcode_28  Implement strStr()</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 28\n*  Title: Implement strStr()\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>字符串的模式匹配</p>\n<p>通过这一道题，可以练习一下这些匹配算法。</p>\n<p><br></p>\n<h4 id=\"BF算法（Brute-Force-暴风算法）-时间复杂度-O-m-n\"><a href=\"#BF算法（Brute-Force-暴风算法）-时间复杂度-O-m-n\" class=\"headerlink\" title=\"BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)\"></a>BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)</h4><p>最普通的模式匹配算法。<br>依次比较，如果匹配失败，从头再来。<br>可以看出，是一个很暴力的算法。</p>\n<p>加了两个小剪枝，</p>\n<ol>\n<li>如果匹配串长度大于原串，直接返回-1</li>\n<li>如果两串长度相等，直接判断值是否相等，返回相应值。（不加会TLE）</li>\n<li>如果匹配串为空，返回0</li>\n</ol>\n<pre><code>class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int lenHs = haystack.length();\n        int lenNe = needle.length();\n        if(lenHs &lt; lenNe)\n            return -1;\n        else if(lenHs == lenNe)\n            if(haystack == needle)\n                return 0;\n            else\n                return -1;\n        else if(lenNe == 0)\n            return 0;\n\n        int i = 0, j = 0;\n        while(i &lt; lenHs)  {\n            if(haystack[i] == needle[j])  {\n                ++i;\n                ++j;\n\n            if(j == lenNe)\n                return i - j;\n            }\n            else  {\n                i = i - j + 1;\n                j = 0;\n            }\n        }\n\n        return -1;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"KMP算法-时间复杂度：O-m-n\"><a href=\"#KMP算法-时间复杂度：O-m-n\" class=\"headerlink\" title=\"KMP算法  时间复杂度：O(m+n)\"></a>KMP算法  时间复杂度：O(m+n)</h4><p>举个板栗：<br>原串：abababc | 匹配串是：ababc<br>当我比较到原串的第五个字符a 与 匹配串的第五个字符c，发现匹配失败；<br>这时，我不需要从原串第二个字符b 与 匹配串第一个字符a，进行比较；<br>只需要将原串的第三个字符a 与 匹配串的第三个字符a，进行比较；<br>因为它们前缀是部分重复的。</p>\n<p>这个特性是由匹配串来决定的，所以，KMP算法，重要在于求出匹配失败后，跳回的部分，即 求出匹配串的Next数组。</p>\n<p>next数组如何求呢？</p>\n<ol>\n<li>第一个字符next值设置为-1</li>\n<li>是从前往后推到的，就是next[1] 是由str[0] 与 next[0] 决定的</li>\n<li>如果前一个数的next值为-1，则此next值为0（-1 + 1）</li>\n<li>如果前一个数next值不为-1，比较前一个字符 与 前next值对应的字符；如果字符相等，则next值为前一个next值+1；如果不等则继续往前比较。<br> 以 index = 2 为例，应该比较 str<a href=\"b\">1</a> 与 str<a href=\"b\">next[1]</a>，相等，所以 next[2] = next[1] + 1 = 1<br> 以 index = 3 为例, 比较 str<a href=\"a\">2</a> 与 str<a href=\"b\">next[2]</a>, 不相等， 继续比较 str<a href=\"a\">2</a> 与 str<a href=\"next[index = 2] -&gt; index 1 -&gt; 因为不相等 -&gt; next[index = 1] -&gt; index = 0\">0</a>, 也不相等，但是此时 next[index] 为-1，所以next[3] = 0(-1 + 1)</li>\n</ol>\n<p>index     0   1   2   3   4   5   6<br>str       b   b   a   b   b   a<br>next      -1  0   1   0   1   2   3 </p>\n<pre><code>class Solution {\nprivate:\n    int NEXT[100001];\n\npublic:\n    void createNextArray(string str, int len) {\n        int i = 0, j = -1;\n\n        NEXT[0] = -1;\n        while(i &lt; len)  {\n        if(j == -1 || str[i] == str[j]) \n            NEXT[++i] = ++j;\n        else\n            j = NEXT[j];\n        }\n    }\n\n    int strStr(string haystack, string needle) {\n        int lenHs = haystack.length();\n        int lenNe = needle.length();\n        if(lenHs &lt; lenNe)\n            return -1;\n        else if(lenHs == lenNe)\n            if(haystack == needle)\n                return 0;\n            else\n                return -1;\n        else if(lenNe == 0)\n            return 0;\n\n        memset(NEXT, -1, sizeof(NEXT));        \n        createNextArray(needle, lenNe+1);\n\n        int i = 0, j = 0;\n        while(i &lt; lenHs) {\n            if(haystack[i] == needle[j])  {\n                ++i;\n                ++j;\n\n                if(j == lenNe)\n                    return i - j;\n            }\n            else\n                if(NEXT[j] == -1) {\n                    ++i;\n                    j = 0;\n                }\n                else\n                    j = NEXT[j];\n        }\n\n        return -1;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_28  Implement strStr()</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 28\n*  Title: Implement strStr()\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>字符串的模式匹配</p>\n<p>通过这一道题，可以练习一下这些匹配算法。</p>\n<p><br></p>\n<h4 id=\"BF算法（Brute-Force-暴风算法）-时间复杂度-O-m-n\"><a href=\"#BF算法（Brute-Force-暴风算法）-时间复杂度-O-m-n\" class=\"headerlink\" title=\"BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)\"></a>BF算法（Brute Force - 暴风算法）   时间复杂度 O(m*n)</h4><p>最普通的模式匹配算法。<br>依次比较，如果匹配失败，从头再来。<br>可以看出，是一个很暴力的算法。</p>\n<p>加了两个小剪枝，</p>\n<ol>\n<li>如果匹配串长度大于原串，直接返回-1</li>\n<li>如果两串长度相等，直接判断值是否相等，返回相应值。（不加会TLE）</li>\n<li>如果匹配串为空，返回0</li>\n</ol>\n<pre><code>class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int lenHs = haystack.length();\n        int lenNe = needle.length();\n        if(lenHs &lt; lenNe)\n            return -1;\n        else if(lenHs == lenNe)\n            if(haystack == needle)\n                return 0;\n            else\n                return -1;\n        else if(lenNe == 0)\n            return 0;\n\n        int i = 0, j = 0;\n        while(i &lt; lenHs)  {\n            if(haystack[i] == needle[j])  {\n                ++i;\n                ++j;\n\n            if(j == lenNe)\n                return i - j;\n            }\n            else  {\n                i = i - j + 1;\n                j = 0;\n            }\n        }\n\n        return -1;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"KMP算法-时间复杂度：O-m-n\"><a href=\"#KMP算法-时间复杂度：O-m-n\" class=\"headerlink\" title=\"KMP算法  时间复杂度：O(m+n)\"></a>KMP算法  时间复杂度：O(m+n)</h4><p>举个板栗：<br>原串：abababc | 匹配串是：ababc<br>当我比较到原串的第五个字符a 与 匹配串的第五个字符c，发现匹配失败；<br>这时，我不需要从原串第二个字符b 与 匹配串第一个字符a，进行比较；<br>只需要将原串的第三个字符a 与 匹配串的第三个字符a，进行比较；<br>因为它们前缀是部分重复的。</p>\n<p>这个特性是由匹配串来决定的，所以，KMP算法，重要在于求出匹配失败后，跳回的部分，即 求出匹配串的Next数组。</p>\n<p>next数组如何求呢？</p>\n<ol>\n<li>第一个字符next值设置为-1</li>\n<li>是从前往后推到的，就是next[1] 是由str[0] 与 next[0] 决定的</li>\n<li>如果前一个数的next值为-1，则此next值为0（-1 + 1）</li>\n<li>如果前一个数next值不为-1，比较前一个字符 与 前next值对应的字符；如果字符相等，则next值为前一个next值+1；如果不等则继续往前比较。<br> 以 index = 2 为例，应该比较 str<a href=\"b\">1</a> 与 str<a href=\"b\">next[1]</a>，相等，所以 next[2] = next[1] + 1 = 1<br> 以 index = 3 为例, 比较 str<a href=\"a\">2</a> 与 str<a href=\"b\">next[2]</a>, 不相等， 继续比较 str<a href=\"a\">2</a> 与 str<a href=\"next[index = 2] -&gt; index 1 -&gt; 因为不相等 -&gt; next[index = 1] -&gt; index = 0\">0</a>, 也不相等，但是此时 next[index] 为-1，所以next[3] = 0(-1 + 1)</li>\n</ol>\n<p>index     0   1   2   3   4   5   6<br>str       b   b   a   b   b   a<br>next      -1  0   1   0   1   2   3 </p>\n<pre><code>class Solution {\nprivate:\n    int NEXT[100001];\n\npublic:\n    void createNextArray(string str, int len) {\n        int i = 0, j = -1;\n\n        NEXT[0] = -1;\n        while(i &lt; len)  {\n        if(j == -1 || str[i] == str[j]) \n            NEXT[++i] = ++j;\n        else\n            j = NEXT[j];\n        }\n    }\n\n    int strStr(string haystack, string needle) {\n        int lenHs = haystack.length();\n        int lenNe = needle.length();\n        if(lenHs &lt; lenNe)\n            return -1;\n        else if(lenHs == lenNe)\n            if(haystack == needle)\n                return 0;\n            else\n                return -1;\n        else if(lenNe == 0)\n            return 0;\n\n        memset(NEXT, -1, sizeof(NEXT));        \n        createNextArray(needle, lenNe+1);\n\n        int i = 0, j = 0;\n        while(i &lt; lenHs) {\n            if(haystack[i] == needle[j])  {\n                ++i;\n                ++j;\n\n                if(j == lenNe)\n                    return i - j;\n            }\n            else\n                if(NEXT[j] == -1) {\n                    ++i;\n                    j = 0;\n                }\n                else\n                    j = NEXT[j];\n        }\n\n        return -1;\n    }\n};\n</code></pre>"},{"title":"Leetcode_29  Divide Two Integers","date":"2017-05-30T14:20:00.000Z","_content":"\nLeetcode_29  Divide Two Integers\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 29\n        *  Title: Divide Two Integers\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n除法的模拟运算。\n最简单的肯定是，除数一直减去被除数，直到除数小于被除数。\n\n\n        while(dividend >= divisor)  {\n            dividend -= divisor;\n            ++ans;\n        }\n\n\n这种方法肯定会超时（我不会说我试过。。。）\n而且，显然题主不会是想让我们用这种方法来做，\n题目中有明示了 division and mod operator（用位运算分解）\n\n任何一个数都可以用以2的幂为底的数字序列之和。\n比如：17 = 2^4*1 + 2^3*0 + 2^2*0 + 2^1*0 + 2^0*1\n\n所以，就出现下面的这个解法，先找到最高可以减去的2的幂指数。\n以17为例，找到4，\n17 - 2^4*1 = 1\n然后，再将1用3，用2，用1，用0，依次逐分。\n\n最最后，注意一下数据处理。\n首先，就是最小值，最大值部分。\n然后，就是最后答案的正负值。\n\n\n\n        class Solution {\n        public:\n            int divide(int dividend, int divisor) {\n                if(dividend == INT_MIN)\n                    if(divisor == 1)\n                        return INT_MIN;\n                    else if(divisor == -1)\n                        return INT_MAX;\n                else if(abs(divisor) == 1)\n                    return dividend*divisor;\n        \n                long dividendTemp = dividend;\n                long divisorTemp = divisor;     \n                int isNegative = 1;\n                if(dividendTemp < 0)    {\n                    dividendTemp = abs(dividendTemp);\n                    isNegative *= -1;\n                }\n                if(divisorTemp < 0) {\n                    divisorTemp = abs(divisorTemp);\n                    isNegative *= -1;\n                }\n        \n                int maxFactor = 0;\n                while(divisorTemp <= (dividendTemp>>1)) {\n                    divisorTemp <<= 1;\n                    ++maxFactor;\n                }\n        \n                long ans = 0;\n                while(maxFactor >= 0)   {\n                    if(dividendTemp >= divisorTemp) {\n                        ans += 1<<maxFactor;\n                        dividendTemp -= divisorTemp;\n                    }\n                    divisorTemp >>= 1;\n                    --maxFactor;\n                }\n        \n        \n                if(ans >= INT_MAX)\n                    return INT_MAX;\n                return ans*isNegative;\n            }\n        };","source":"_posts/[Leetcode]_29  Divide Two Integers.md","raw":"---\ntitle: Leetcode_29  Divide Two Integers\ndate: 2017-05-30 22:20:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_29  Divide Two Integers\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 29\n        *  Title: Divide Two Integers\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n除法的模拟运算。\n最简单的肯定是，除数一直减去被除数，直到除数小于被除数。\n\n\n        while(dividend >= divisor)  {\n            dividend -= divisor;\n            ++ans;\n        }\n\n\n这种方法肯定会超时（我不会说我试过。。。）\n而且，显然题主不会是想让我们用这种方法来做，\n题目中有明示了 division and mod operator（用位运算分解）\n\n任何一个数都可以用以2的幂为底的数字序列之和。\n比如：17 = 2^4*1 + 2^3*0 + 2^2*0 + 2^1*0 + 2^0*1\n\n所以，就出现下面的这个解法，先找到最高可以减去的2的幂指数。\n以17为例，找到4，\n17 - 2^4*1 = 1\n然后，再将1用3，用2，用1，用0，依次逐分。\n\n最最后，注意一下数据处理。\n首先，就是最小值，最大值部分。\n然后，就是最后答案的正负值。\n\n\n\n        class Solution {\n        public:\n            int divide(int dividend, int divisor) {\n                if(dividend == INT_MIN)\n                    if(divisor == 1)\n                        return INT_MIN;\n                    else if(divisor == -1)\n                        return INT_MAX;\n                else if(abs(divisor) == 1)\n                    return dividend*divisor;\n        \n                long dividendTemp = dividend;\n                long divisorTemp = divisor;     \n                int isNegative = 1;\n                if(dividendTemp < 0)    {\n                    dividendTemp = abs(dividendTemp);\n                    isNegative *= -1;\n                }\n                if(divisorTemp < 0) {\n                    divisorTemp = abs(divisorTemp);\n                    isNegative *= -1;\n                }\n        \n                int maxFactor = 0;\n                while(divisorTemp <= (dividendTemp>>1)) {\n                    divisorTemp <<= 1;\n                    ++maxFactor;\n                }\n        \n                long ans = 0;\n                while(maxFactor >= 0)   {\n                    if(dividendTemp >= divisorTemp) {\n                        ans += 1<<maxFactor;\n                        dividendTemp -= divisorTemp;\n                    }\n                    divisorTemp >>= 1;\n                    --maxFactor;\n                }\n        \n        \n                if(ans >= INT_MAX)\n                    return INT_MAX;\n                return ans*isNegative;\n            }\n        };","slug":"[Leetcode]_29  Divide Two Integers","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabhj001aveuevox3pxma","content":"<p>Leetcode_29  Divide Two Integers</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 29\n*  Title: Divide Two Integers\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>除法的模拟运算。<br>最简单的肯定是，除数一直减去被除数，直到除数小于被除数。</p>\n<pre><code>while(dividend &gt;= divisor)  {\n    dividend -= divisor;\n    ++ans;\n}\n</code></pre><p>这种方法肯定会超时（我不会说我试过。。。）<br>而且，显然题主不会是想让我们用这种方法来做，<br>题目中有明示了 division and mod operator（用位运算分解）</p>\n<p>任何一个数都可以用以2的幂为底的数字序列之和。<br>比如：17 = 2^4<em>1 + 2^3</em>0 + 2^2<em>0 + 2^1</em>0 + 2^0*1</p>\n<p>所以，就出现下面的这个解法，先找到最高可以减去的2的幂指数。<br>以17为例，找到4，<br>17 - 2^4*1 = 1<br>然后，再将1用3，用2，用1，用0，依次逐分。</p>\n<p>最最后，注意一下数据处理。<br>首先，就是最小值，最大值部分。<br>然后，就是最后答案的正负值。</p>\n<pre><code>class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN)\n            if(divisor == 1)\n                return INT_MIN;\n            else if(divisor == -1)\n                return INT_MAX;\n        else if(abs(divisor) == 1)\n            return dividend*divisor;\n\n        long dividendTemp = dividend;\n        long divisorTemp = divisor;     \n        int isNegative = 1;\n        if(dividendTemp &lt; 0)    {\n            dividendTemp = abs(dividendTemp);\n            isNegative *= -1;\n        }\n        if(divisorTemp &lt; 0) {\n            divisorTemp = abs(divisorTemp);\n            isNegative *= -1;\n        }\n\n        int maxFactor = 0;\n        while(divisorTemp &lt;= (dividendTemp&gt;&gt;1)) {\n            divisorTemp &lt;&lt;= 1;\n            ++maxFactor;\n        }\n\n        long ans = 0;\n        while(maxFactor &gt;= 0)   {\n            if(dividendTemp &gt;= divisorTemp) {\n                ans += 1&lt;&lt;maxFactor;\n                dividendTemp -= divisorTemp;\n            }\n            divisorTemp &gt;&gt;= 1;\n            --maxFactor;\n        }\n\n\n        if(ans &gt;= INT_MAX)\n            return INT_MAX;\n        return ans*isNegative;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_29  Divide Two Integers</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 29\n*  Title: Divide Two Integers\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>除法的模拟运算。<br>最简单的肯定是，除数一直减去被除数，直到除数小于被除数。</p>\n<pre><code>while(dividend &gt;= divisor)  {\n    dividend -= divisor;\n    ++ans;\n}\n</code></pre><p>这种方法肯定会超时（我不会说我试过。。。）<br>而且，显然题主不会是想让我们用这种方法来做，<br>题目中有明示了 division and mod operator（用位运算分解）</p>\n<p>任何一个数都可以用以2的幂为底的数字序列之和。<br>比如：17 = 2^4<em>1 + 2^3</em>0 + 2^2<em>0 + 2^1</em>0 + 2^0*1</p>\n<p>所以，就出现下面的这个解法，先找到最高可以减去的2的幂指数。<br>以17为例，找到4，<br>17 - 2^4*1 = 1<br>然后，再将1用3，用2，用1，用0，依次逐分。</p>\n<p>最最后，注意一下数据处理。<br>首先，就是最小值，最大值部分。<br>然后，就是最后答案的正负值。</p>\n<pre><code>class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN)\n            if(divisor == 1)\n                return INT_MIN;\n            else if(divisor == -1)\n                return INT_MAX;\n        else if(abs(divisor) == 1)\n            return dividend*divisor;\n\n        long dividendTemp = dividend;\n        long divisorTemp = divisor;     \n        int isNegative = 1;\n        if(dividendTemp &lt; 0)    {\n            dividendTemp = abs(dividendTemp);\n            isNegative *= -1;\n        }\n        if(divisorTemp &lt; 0) {\n            divisorTemp = abs(divisorTemp);\n            isNegative *= -1;\n        }\n\n        int maxFactor = 0;\n        while(divisorTemp &lt;= (dividendTemp&gt;&gt;1)) {\n            divisorTemp &lt;&lt;= 1;\n            ++maxFactor;\n        }\n\n        long ans = 0;\n        while(maxFactor &gt;= 0)   {\n            if(dividendTemp &gt;= divisorTemp) {\n                ans += 1&lt;&lt;maxFactor;\n                dividendTemp -= divisorTemp;\n            }\n            divisorTemp &gt;&gt;= 1;\n            --maxFactor;\n        }\n\n\n        if(ans &gt;= INT_MAX)\n            return INT_MAX;\n        return ans*isNegative;\n    }\n};\n</code></pre>"},{"title":"Leetcode_3  Longest Substring Without Repeating Characters","date":"2017-03-16T13:43:35.000Z","_content":"\nLeetcode_3  Longest Substring Without Repeating Characters\n简单题\n\n<!-- more -->\n<br/>\n\n\n一个checkMap来存储某字符是否出现过\n时间复杂度O(n^2), 空间复杂度O(n)\n\n\n    class Solution {\n    public:\n        int lengthOfLongestSubstring(string s) {\n            if(s.length() < 2)\n                return s.length();\n\n            int maxLen = 1;\n            for(int i = 0; i < s.length(); i++) {\n                int checkMap[300] = {0};\n                checkMap[s[i] - ' '] = 1;\n                for(int j = i + 1; j < s.length(); j++) {\n                    if(checkMap[s[j] - ' '] != 0)    {\n                        maxLen = max(maxLen, j - i);\n                        break;\n                    }\n                    else if( j == s.length() - 1)\n                        maxLen = max(maxLen, j - i + 1);\n                    checkMap[s[j] - ' '] = 1;\n                }\n            }\n            return maxLen;\n        }\n    };\n\n\n<br/>\n当然，还是要看一下大神们的解法。\n时间复杂度O(n), 空间复杂度O(1)\n\n设置一个checkMap 来存储，每个字符出现的位置。\n如果出现同一个字符，就重置子串启始位置。\n不忍看自己的代码了....\n\n\n\n    class Solution {\n    public:\n        int lengthOfLongestSubstring(string s) {\n            std::vector<int> checkMap(256, -1);\n            int maxLen = 0, start = -1;\n            for(int i = 0; i < s.length(); i++)    {\n                if(checkMap[s[i]] > start)\n                    start = checkMap[s[i]];\n                checkMap[s[i]] = i;\n                maxLen = max(maxLen, i - start);\n            }\n            return maxLen;\n        }\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[Leetcode]_3  Longest Substring Without Repeating Characters.md","raw":"---\ntitle: Leetcode_3  Longest Substring Without Repeating Characters\ndate: 2017-03-16 21:43:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_3  Longest Substring Without Repeating Characters\n简单题\n\n<!-- more -->\n<br/>\n\n\n一个checkMap来存储某字符是否出现过\n时间复杂度O(n^2), 空间复杂度O(n)\n\n\n    class Solution {\n    public:\n        int lengthOfLongestSubstring(string s) {\n            if(s.length() < 2)\n                return s.length();\n\n            int maxLen = 1;\n            for(int i = 0; i < s.length(); i++) {\n                int checkMap[300] = {0};\n                checkMap[s[i] - ' '] = 1;\n                for(int j = i + 1; j < s.length(); j++) {\n                    if(checkMap[s[j] - ' '] != 0)    {\n                        maxLen = max(maxLen, j - i);\n                        break;\n                    }\n                    else if( j == s.length() - 1)\n                        maxLen = max(maxLen, j - i + 1);\n                    checkMap[s[j] - ' '] = 1;\n                }\n            }\n            return maxLen;\n        }\n    };\n\n\n<br/>\n当然，还是要看一下大神们的解法。\n时间复杂度O(n), 空间复杂度O(1)\n\n设置一个checkMap 来存储，每个字符出现的位置。\n如果出现同一个字符，就重置子串启始位置。\n不忍看自己的代码了....\n\n\n\n    class Solution {\n    public:\n        int lengthOfLongestSubstring(string s) {\n            std::vector<int> checkMap(256, -1);\n            int maxLen = 0, start = -1;\n            for(int i = 0; i < s.length(); i++)    {\n                if(checkMap[s[i]] > start)\n                    start = checkMap[s[i]];\n                checkMap[s[i]] = i;\n                maxLen = max(maxLen, i - start);\n            }\n            return maxLen;\n        }\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[Leetcode]_3  Longest Substring Without Repeating Characters","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabhm001dveue3y553nby","content":"<p>Leetcode_3  Longest Substring Without Repeating Characters<br>简单题</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>一个checkMap来存储某字符是否出现过<br>时间复杂度O(n^2), 空间复杂度O(n)</p>\n<pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length() &lt; 2)\n            return s.length();\n\n        int maxLen = 1;\n        for(int i = 0; i &lt; s.length(); i++) {\n            int checkMap[300] = {0};\n            checkMap[s[i] - &apos; &apos;] = 1;\n            for(int j = i + 1; j &lt; s.length(); j++) {\n                if(checkMap[s[j] - &apos; &apos;] != 0)    {\n                    maxLen = max(maxLen, j - i);\n                    break;\n                }\n                else if( j == s.length() - 1)\n                    maxLen = max(maxLen, j - i + 1);\n                checkMap[s[j] - &apos; &apos;] = 1;\n            }\n        }\n        return maxLen;\n    }\n};\n</code></pre><p><br><br>当然，还是要看一下大神们的解法。<br>时间复杂度O(n), 空间复杂度O(1)</p>\n<p>设置一个checkMap 来存储，每个字符出现的位置。<br>如果出现同一个字符，就重置子串启始位置。<br>不忍看自己的代码了….</p>\n<pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        std::vector&lt;int&gt; checkMap(256, -1);\n        int maxLen = 0, start = -1;\n        for(int i = 0; i &lt; s.length(); i++)    {\n            if(checkMap[s[i]] &gt; start)\n                start = checkMap[s[i]];\n            checkMap[s[i]] = i;\n            maxLen = max(maxLen, i - start);\n        }\n        return maxLen;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_3  Longest Substring Without Repeating Characters<br>简单题</p>","more":"<p><br></p>\n<p>一个checkMap来存储某字符是否出现过<br>时间复杂度O(n^2), 空间复杂度O(n)</p>\n<pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length() &lt; 2)\n            return s.length();\n\n        int maxLen = 1;\n        for(int i = 0; i &lt; s.length(); i++) {\n            int checkMap[300] = {0};\n            checkMap[s[i] - &apos; &apos;] = 1;\n            for(int j = i + 1; j &lt; s.length(); j++) {\n                if(checkMap[s[j] - &apos; &apos;] != 0)    {\n                    maxLen = max(maxLen, j - i);\n                    break;\n                }\n                else if( j == s.length() - 1)\n                    maxLen = max(maxLen, j - i + 1);\n                checkMap[s[j] - &apos; &apos;] = 1;\n            }\n        }\n        return maxLen;\n    }\n};\n</code></pre><p><br><br>当然，还是要看一下大神们的解法。<br>时间复杂度O(n), 空间复杂度O(1)</p>\n<p>设置一个checkMap 来存储，每个字符出现的位置。<br>如果出现同一个字符，就重置子串启始位置。<br>不忍看自己的代码了….</p>\n<pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        std::vector&lt;int&gt; checkMap(256, -1);\n        int maxLen = 0, start = -1;\n        for(int i = 0; i &lt; s.length(); i++)    {\n            if(checkMap[s[i]] &gt; start)\n                start = checkMap[s[i]];\n            checkMap[s[i]] = i;\n            maxLen = max(maxLen, i - start);\n        }\n        return maxLen;\n    }\n};\n</code></pre>"},{"title":"Leetcode_30  Substring with Concatenation of All Words","date":"2017-05-30T14:40:00.000Z","_content":"\nLeetcode_30  Substring with Concatenation of All Words\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 30\n        *  Title: Substring with Concatenation of All Words\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题意就是求字符串s中是否有子串是全由容器words内字符串组成的。\n\n<br/>\n\n#### 模拟\n模拟求这个问题的方法：\n1.取原串一部分，然后看子串容器中是否有它，如果有往下看（跳到2）；如果没有则失败。（回到1）\n2.子串容器中有这部分，看用了几次，用的次数小于等于子串容器中拥有的个数，继续往下（跳到3），否则失败。（回到1）\n3.如果已经匹配完了所有子串，成功，记录序列值。（回到1）\n\n这里要注意一下，构建比较标准映射的值，不可以全置为固定值，而是要用递增。\n因为，子串可能有重复的值。\n\n\n\n        class Solution {\n        public:\n            vector<int> findSubstring(string s, vector<string>& words) {\n                int sLen = s.length(), wordsSize = words.size(), perWordLen = words[0].length();\n                map<string, int> baseMap;\n                for(int i = 0; i < wordsSize; i++)\n                    ++baseMap[words[i]];\n        \n                vector<int> ans;\n                for(int i = 0; i < sLen-wordsSize*perWordLen+1; i++)    {\n                    map<string, int> comparedMap;\n                    int j = 0;\n                    while(j < wordsSize)    {\n                        string word = s.substr(i+j*perWordLen, perWordLen);\n                        if(baseMap.find(word) != baseMap.end()) {\n                            ++comparedMap[word];\n                            if(comparedMap[word] > baseMap[word])\n                                break;\n                        }\n                        else    break;\n                        ++j;\n                    }\n                    if(j == wordsSize)\n                        ans.push_back(i);\n                }\n                return ans;\n            }\n        };\n","source":"_posts/[Leetcode]_30  Substring with Concatenation of All Words.md","raw":"---\ntitle: Leetcode_30  Substring with Concatenation of All Words\ndate: 2017-05-30 22:40:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_30  Substring with Concatenation of All Words\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 30\n        *  Title: Substring with Concatenation of All Words\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n题意就是求字符串s中是否有子串是全由容器words内字符串组成的。\n\n<br/>\n\n#### 模拟\n模拟求这个问题的方法：\n1.取原串一部分，然后看子串容器中是否有它，如果有往下看（跳到2）；如果没有则失败。（回到1）\n2.子串容器中有这部分，看用了几次，用的次数小于等于子串容器中拥有的个数，继续往下（跳到3），否则失败。（回到1）\n3.如果已经匹配完了所有子串，成功，记录序列值。（回到1）\n\n这里要注意一下，构建比较标准映射的值，不可以全置为固定值，而是要用递增。\n因为，子串可能有重复的值。\n\n\n\n        class Solution {\n        public:\n            vector<int> findSubstring(string s, vector<string>& words) {\n                int sLen = s.length(), wordsSize = words.size(), perWordLen = words[0].length();\n                map<string, int> baseMap;\n                for(int i = 0; i < wordsSize; i++)\n                    ++baseMap[words[i]];\n        \n                vector<int> ans;\n                for(int i = 0; i < sLen-wordsSize*perWordLen+1; i++)    {\n                    map<string, int> comparedMap;\n                    int j = 0;\n                    while(j < wordsSize)    {\n                        string word = s.substr(i+j*perWordLen, perWordLen);\n                        if(baseMap.find(word) != baseMap.end()) {\n                            ++comparedMap[word];\n                            if(comparedMap[word] > baseMap[word])\n                                break;\n                        }\n                        else    break;\n                        ++j;\n                    }\n                    if(j == wordsSize)\n                        ans.push_back(i);\n                }\n                return ans;\n            }\n        };\n","slug":"[Leetcode]_30  Substring with Concatenation of All Words","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabhq001fveue235916bu","content":"<p>Leetcode_30  Substring with Concatenation of All Words</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 30\n*  Title: Substring with Concatenation of All Words\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意就是求字符串s中是否有子串是全由容器words内字符串组成的。</p>\n<p><br></p>\n<h4 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h4><p>模拟求这个问题的方法：<br>1.取原串一部分，然后看子串容器中是否有它，如果有往下看（跳到2）；如果没有则失败。（回到1）<br>2.子串容器中有这部分，看用了几次，用的次数小于等于子串容器中拥有的个数，继续往下（跳到3），否则失败。（回到1）<br>3.如果已经匹配完了所有子串，成功，记录序列值。（回到1）</p>\n<p>这里要注意一下，构建比较标准映射的值，不可以全置为固定值，而是要用递增。<br>因为，子串可能有重复的值。</p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {\n        int sLen = s.length(), wordsSize = words.size(), perWordLen = words[0].length();\n        map&lt;string, int&gt; baseMap;\n        for(int i = 0; i &lt; wordsSize; i++)\n            ++baseMap[words[i]];\n\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; sLen-wordsSize*perWordLen+1; i++)    {\n            map&lt;string, int&gt; comparedMap;\n            int j = 0;\n            while(j &lt; wordsSize)    {\n                string word = s.substr(i+j*perWordLen, perWordLen);\n                if(baseMap.find(word) != baseMap.end()) {\n                    ++comparedMap[word];\n                    if(comparedMap[word] &gt; baseMap[word])\n                        break;\n                }\n                else    break;\n                ++j;\n            }\n            if(j == wordsSize)\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_30  Substring with Concatenation of All Words</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 30\n*  Title: Substring with Concatenation of All Words\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>题意就是求字符串s中是否有子串是全由容器words内字符串组成的。</p>\n<p><br></p>\n<h4 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h4><p>模拟求这个问题的方法：<br>1.取原串一部分，然后看子串容器中是否有它，如果有往下看（跳到2）；如果没有则失败。（回到1）<br>2.子串容器中有这部分，看用了几次，用的次数小于等于子串容器中拥有的个数，继续往下（跳到3），否则失败。（回到1）<br>3.如果已经匹配完了所有子串，成功，记录序列值。（回到1）</p>\n<p>这里要注意一下，构建比较标准映射的值，不可以全置为固定值，而是要用递增。<br>因为，子串可能有重复的值。</p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {\n        int sLen = s.length(), wordsSize = words.size(), perWordLen = words[0].length();\n        map&lt;string, int&gt; baseMap;\n        for(int i = 0; i &lt; wordsSize; i++)\n            ++baseMap[words[i]];\n\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; sLen-wordsSize*perWordLen+1; i++)    {\n            map&lt;string, int&gt; comparedMap;\n            int j = 0;\n            while(j &lt; wordsSize)    {\n                string word = s.substr(i+j*perWordLen, perWordLen);\n                if(baseMap.find(word) != baseMap.end()) {\n                    ++comparedMap[word];\n                    if(comparedMap[word] &gt; baseMap[word])\n                        break;\n                }\n                else    break;\n                ++j;\n            }\n            if(j == wordsSize)\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_4  Median of Two Sorted Arrays","date":"2017-03-20T14:17:35.000Z","_content":"\nLeetcode_4  Median of Two Sorted Arrays\n简单题, 分治法\n\n<!-- more -->\n<br/>\n\n本题是非常经典的一个题目，应该经常出现在面试题中。\n给两个有序数组，求他们所有数的中位数。\n\n<br/>\n\n第一种方法\n用merge函数，将两个vector合并起来，然后直接输出中位数...\n\n\n        class Solution {\n        public:\n            double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n            \tint allSize = nums1.size() + nums2.size();\n                std::vector<int> allNums(allSize);\n                merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), allNums.begin());\n        \n                allSize -= 1;\n                double medianNum = 0;\n                if((allSize+1) % 2 == 0){\n                \tmedianNum = (allNums[allSize/2] + allNums[allSize/2+1]) / 2.0;\n                }\n                else{\n                \tint tempNum = int(allSize/2.0 + 0.5);\n                \tmedianNum = allNums[tempNum];\n                }\n        \n                return medianNum;\n            }\n        };\n\n\n\n<br/>\n题目建议，时间复杂度最好为 O(log(m+n))\n按这个要求，用分治法应该是不错的。\n这种方法，\n1. 就是根据K值（一般取 K/2, 但也要注意数量，所以取 min(K/2, len) )，将 数组A 与 数组B 分别分成两部分： frontA, backA; frontB, backB;\n2. 然后比较 backA前一个数 与 backB前一个数，\n3. 因为两个数组分别有序，而且frontA 与 frontB所含数字数量均小于等于K；\n4. 所以必然可以抛弃 frontA 与 frontB中的一部分，\n5. 每次都抛弃一部分，直到找到第K个数。\n\n\n        class Solution {\n        private:\n            int findKthNum(vector<int>::iterator A, int lenA, vector<int>::iterator B, int lenB, int K)   {\n                if(lenA > lenB)\n                    return findKthNum(B, lenB, A, lenA, K);\n                if(lenA == 0)\n                    return B[K-1];\n                if(K == 1)\n                    return min(A[0], B[0]);\n        \n                int midA = min(K/2, lenA), midB = K - midA;\n                if(A[midA - 1] < B[midB - 1])\n                    return findKthNum(A + midA, lenA-midA, B, lenB, K-midA);\n                else if(A[midA - 1] > B[midB - 1])\n                    return findKthNum(A, lenA, B + midB, lenB-midB, K-midB);\n                else\n                    return A[midA - 1];\n            }\n        \n        public:\n            double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                int m = nums1.size(), n = nums2.size();\n                vector<int>::iterator A = nums1.begin();\n                vector<int>::iterator B = nums2.begin();\n        \n                int total = m + n;\n                if( total & 0x1 )\n                    return findKthNum(A, m, B, n, total/2+1);\n                else\n                    return (findKthNum(A, m, B, n, total/2) + findKthNum(A, m, B, n, total/2+1)) / 2.0;\n            }\n        };\n\n\n\n\n\n\n\n","source":"_posts/[Leetcode]_4  Median of Two Sorted Arrays.md","raw":"---\ntitle: Leetcode_4  Median of Two Sorted Arrays\ndate: 2017-03-20 22:17:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_4  Median of Two Sorted Arrays\n简单题, 分治法\n\n<!-- more -->\n<br/>\n\n本题是非常经典的一个题目，应该经常出现在面试题中。\n给两个有序数组，求他们所有数的中位数。\n\n<br/>\n\n第一种方法\n用merge函数，将两个vector合并起来，然后直接输出中位数...\n\n\n        class Solution {\n        public:\n            double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n            \tint allSize = nums1.size() + nums2.size();\n                std::vector<int> allNums(allSize);\n                merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), allNums.begin());\n        \n                allSize -= 1;\n                double medianNum = 0;\n                if((allSize+1) % 2 == 0){\n                \tmedianNum = (allNums[allSize/2] + allNums[allSize/2+1]) / 2.0;\n                }\n                else{\n                \tint tempNum = int(allSize/2.0 + 0.5);\n                \tmedianNum = allNums[tempNum];\n                }\n        \n                return medianNum;\n            }\n        };\n\n\n\n<br/>\n题目建议，时间复杂度最好为 O(log(m+n))\n按这个要求，用分治法应该是不错的。\n这种方法，\n1. 就是根据K值（一般取 K/2, 但也要注意数量，所以取 min(K/2, len) )，将 数组A 与 数组B 分别分成两部分： frontA, backA; frontB, backB;\n2. 然后比较 backA前一个数 与 backB前一个数，\n3. 因为两个数组分别有序，而且frontA 与 frontB所含数字数量均小于等于K；\n4. 所以必然可以抛弃 frontA 与 frontB中的一部分，\n5. 每次都抛弃一部分，直到找到第K个数。\n\n\n        class Solution {\n        private:\n            int findKthNum(vector<int>::iterator A, int lenA, vector<int>::iterator B, int lenB, int K)   {\n                if(lenA > lenB)\n                    return findKthNum(B, lenB, A, lenA, K);\n                if(lenA == 0)\n                    return B[K-1];\n                if(K == 1)\n                    return min(A[0], B[0]);\n        \n                int midA = min(K/2, lenA), midB = K - midA;\n                if(A[midA - 1] < B[midB - 1])\n                    return findKthNum(A + midA, lenA-midA, B, lenB, K-midA);\n                else if(A[midA - 1] > B[midB - 1])\n                    return findKthNum(A, lenA, B + midB, lenB-midB, K-midB);\n                else\n                    return A[midA - 1];\n            }\n        \n        public:\n            double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                int m = nums1.size(), n = nums2.size();\n                vector<int>::iterator A = nums1.begin();\n                vector<int>::iterator B = nums2.begin();\n        \n                int total = m + n;\n                if( total & 0x1 )\n                    return findKthNum(A, m, B, n, total/2+1);\n                else\n                    return (findKthNum(A, m, B, n, total/2) + findKthNum(A, m, B, n, total/2+1)) / 2.0;\n            }\n        };\n\n\n\n\n\n\n\n","slug":"[Leetcode]_4  Median of Two Sorted Arrays","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabhu001iveue0zsw9jek","content":"<p>Leetcode_4  Median of Two Sorted Arrays<br>简单题, 分治法</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>本题是非常经典的一个题目，应该经常出现在面试题中。<br>给两个有序数组，求他们所有数的中位数。</p>\n<p><br></p>\n<p>第一种方法<br>用merge函数，将两个vector合并起来，然后直接输出中位数…</p>\n<pre><code>class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int allSize = nums1.size() + nums2.size();\n        std::vector&lt;int&gt; allNums(allSize);\n        merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), allNums.begin());\n\n        allSize -= 1;\n        double medianNum = 0;\n        if((allSize+1) % 2 == 0){\n            medianNum = (allNums[allSize/2] + allNums[allSize/2+1]) / 2.0;\n        }\n        else{\n            int tempNum = int(allSize/2.0 + 0.5);\n            medianNum = allNums[tempNum];\n        }\n\n        return medianNum;\n    }\n};\n</code></pre><p><br><br>题目建议，时间复杂度最好为 O(log(m+n))<br>按这个要求，用分治法应该是不错的。<br>这种方法，</p>\n<ol>\n<li>就是根据K值（一般取 K/2, 但也要注意数量，所以取 min(K/2, len) )，将 数组A 与 数组B 分别分成两部分： frontA, backA; frontB, backB;</li>\n<li>然后比较 backA前一个数 与 backB前一个数，</li>\n<li>因为两个数组分别有序，而且frontA 与 frontB所含数字数量均小于等于K；</li>\n<li>所以必然可以抛弃 frontA 与 frontB中的一部分，</li>\n<li>每次都抛弃一部分，直到找到第K个数。</li>\n</ol>\n<pre><code>class Solution {\nprivate:\n    int findKthNum(vector&lt;int&gt;::iterator A, int lenA, vector&lt;int&gt;::iterator B, int lenB, int K)   {\n        if(lenA &gt; lenB)\n            return findKthNum(B, lenB, A, lenA, K);\n        if(lenA == 0)\n            return B[K-1];\n        if(K == 1)\n            return min(A[0], B[0]);\n\n        int midA = min(K/2, lenA), midB = K - midA;\n        if(A[midA - 1] &lt; B[midB - 1])\n            return findKthNum(A + midA, lenA-midA, B, lenB, K-midA);\n        else if(A[midA - 1] &gt; B[midB - 1])\n            return findKthNum(A, lenA, B + midB, lenB-midB, K-midB);\n        else\n            return A[midA - 1];\n    }\n\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int m = nums1.size(), n = nums2.size();\n        vector&lt;int&gt;::iterator A = nums1.begin();\n        vector&lt;int&gt;::iterator B = nums2.begin();\n\n        int total = m + n;\n        if( total &amp; 0x1 )\n            return findKthNum(A, m, B, n, total/2+1);\n        else\n            return (findKthNum(A, m, B, n, total/2) + findKthNum(A, m, B, n, total/2+1)) / 2.0;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_4  Median of Two Sorted Arrays<br>简单题, 分治法</p>","more":"<p><br></p>\n<p>本题是非常经典的一个题目，应该经常出现在面试题中。<br>给两个有序数组，求他们所有数的中位数。</p>\n<p><br></p>\n<p>第一种方法<br>用merge函数，将两个vector合并起来，然后直接输出中位数…</p>\n<pre><code>class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int allSize = nums1.size() + nums2.size();\n        std::vector&lt;int&gt; allNums(allSize);\n        merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), allNums.begin());\n\n        allSize -= 1;\n        double medianNum = 0;\n        if((allSize+1) % 2 == 0){\n            medianNum = (allNums[allSize/2] + allNums[allSize/2+1]) / 2.0;\n        }\n        else{\n            int tempNum = int(allSize/2.0 + 0.5);\n            medianNum = allNums[tempNum];\n        }\n\n        return medianNum;\n    }\n};\n</code></pre><p><br><br>题目建议，时间复杂度最好为 O(log(m+n))<br>按这个要求，用分治法应该是不错的。<br>这种方法，</p>\n<ol>\n<li>就是根据K值（一般取 K/2, 但也要注意数量，所以取 min(K/2, len) )，将 数组A 与 数组B 分别分成两部分： frontA, backA; frontB, backB;</li>\n<li>然后比较 backA前一个数 与 backB前一个数，</li>\n<li>因为两个数组分别有序，而且frontA 与 frontB所含数字数量均小于等于K；</li>\n<li>所以必然可以抛弃 frontA 与 frontB中的一部分，</li>\n<li>每次都抛弃一部分，直到找到第K个数。</li>\n</ol>\n<pre><code>class Solution {\nprivate:\n    int findKthNum(vector&lt;int&gt;::iterator A, int lenA, vector&lt;int&gt;::iterator B, int lenB, int K)   {\n        if(lenA &gt; lenB)\n            return findKthNum(B, lenB, A, lenA, K);\n        if(lenA == 0)\n            return B[K-1];\n        if(K == 1)\n            return min(A[0], B[0]);\n\n        int midA = min(K/2, lenA), midB = K - midA;\n        if(A[midA - 1] &lt; B[midB - 1])\n            return findKthNum(A + midA, lenA-midA, B, lenB, K-midA);\n        else if(A[midA - 1] &gt; B[midB - 1])\n            return findKthNum(A, lenA, B + midB, lenB-midB, K-midB);\n        else\n            return A[midA - 1];\n    }\n\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int m = nums1.size(), n = nums2.size();\n        vector&lt;int&gt;::iterator A = nums1.begin();\n        vector&lt;int&gt;::iterator B = nums2.begin();\n\n        int total = m + n;\n        if( total &amp; 0x1 )\n            return findKthNum(A, m, B, n, total/2+1);\n        else\n            return (findKthNum(A, m, B, n, total/2) + findKthNum(A, m, B, n, total/2+1)) / 2.0;\n    }\n};\n</code></pre>"},{"title":"Leetcode_31  Next Permutation","date":"2017-06-04T15:54:00.000Z","_content":"\nLeetcode_31  Next Permutation\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 31\n        *  Title: Next Permutation\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n有必要说一下题意，我当时都没看明白这题。\n\n先了解一下几个定义\n\n1. 全排列，\n1,2,3 三个数的全排列有：（字典序）\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n6种（对于n个不同数的全排列有 f(n) = n! 种）\n\n2. 字典序\n字典序就是对给定的字符集中的字符规定一个先后关系。这里的数字可以看做小数在大数前面。\n还有一种理解方法，你给上面每个数值相应位置定一个权值。\n比如第一个位置（最前面的）权值最大，为100；第二个为10；第三个为1。\n1 2 3 = 123\n1 3 2 = 132\n2 1 3 = 213\n2 3 1 = 231\n3 1 2 = 312\n3 2 1 = 321\n字典序，就可以看做是相应位置的数字乘以权值的和，按照最后得数的由小到大的顺序。\n\n<br/>\n\n这道题，是求下一个字典序的全排列。（因为题目中对于全排列规定了顺序，所以就可以求前一个或者后一个）\n可以看出 1 2 3 下一个 就是 1 3 2 再下一个就是 2 1 3。\n\n\n<br/>\n\n#### 模拟法\n\n从后向前，先比较前后大小，如果有前面的小于后面的，那就以那个位置为中心，可以进行修改。\n以 1 2 4 3 2 为例\n第二个位置 小于 第三个位置。\n找后面有没有比第二个数字大的最小的数（有点绕，就是找所有比2大的数，在这些里面取最小的）\n然后将 第二个位置的数 与 上面找到的数 替换位置。\n最后，对第二个位置右面的数列进行有小到大排序。\n\n1. 从后向前比较大小，如果前面的数小于后面，进入第2步；否则，逆序输出。\n2. 从当前数字及向右的序列中找出比左面数字大的最小数字及序列号\n3. 交换数值\n4. 对当前数字及向右的序列进行由小到大排序\n\n\n        class Solution {\n        private:\n            void findNextNumIndexFromRight(std::vector<int> nums, int& index, int& minDerta)    {\n                int standIndex = index-1;\n                for(int i = index; i < nums.size(); i++)    {\n                    int derta = nums[i] - nums[standIndex];\n                    if(derta > 0 && (derta < minDerta || minDerta <= 0))    {\n                        index = i;\n                        minDerta = derta;\n                    }\n                }\n            }\n        \n            void swapNum(int& a, int& b)    {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n        public:\n            void nextPermutation(vector<int>& nums) {\n                int len = nums.size();\n                for(int i = len-1; i > 0; i--)  {\n                    if(nums[i-1] < nums[i]) {\n                        int minIndex = i, minDerta = nums[i] - nums[i-1];\n                        findNextNumIndexFromRight(nums, minIndex, minDerta);\n                        swapNum(nums[i-1], nums[minIndex]); \n        \n                        // 此处用的冒泡排序\n                        for(int j = i; j < len; j++)\n                            for(int k = len-1; k > j; k--)\n                                if(nums[k] < nums[k-1]) \n                                    swapNum(nums[k-1], nums[k]);\n        \n                        return;\n                    }\n                }\n        \n                reverse(nums.begin(), nums.end());\n                return;\n            }\n        };\n\n\n<br/>\n\n#### 稍微改进一下\n\n\n        class Solution {\n        private:\n            int findNextNumIndexFromRight(std::vector<int> nums, int index) {\n                for(int i = nums.size()-1; i > index; i--)\n                    if(nums[i] > nums[index])\n                        return i;\n            }\n        \n            void swapNum(int& a, int& b)    {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n        public:\n            void nextPermutation(vector<int>& nums) {\n                int len = nums.size();\n                for(int i = len-1; i > 0; i--)  {\n                    if(nums[i-1] < nums[i]) {\n                        int minIndex = findNextNumIndexFromRight(nums, i-1);\n                        swapNum(nums[i-1], nums[minIndex]); \n                        reverse(nums.begin()+i, nums.end());\n                        return;\n                    }\n                }\n        \n                reverse(nums.begin(), nums.end());\n                return;\n            }\n        };\n\n\n<br/>\n\n##### 来几组测试数据吧\n\n\n        [1,2,3]\n        [1,3,2]\n        [1,1,5]\n        [3,2,1]\n        [1,2,3,2,1]\n        [5,4,7,5,3,2]\n        [5,4,7,4,3,2]","source":"_posts/[Leetcode]_31  Next Permutation.md","raw":"---\ntitle: Leetcode_31  Next Permutation\ndate: 2017-06-04 23:54:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_31  Next Permutation\n\n\n<!-- more -->\n<br/>\n\n\n        /**\n        *  Index: 31\n        *  Title: Next Permutation\n        *  Author: ltree98\n        **/\n\n\n<br/>\n\n\n有必要说一下题意，我当时都没看明白这题。\n\n先了解一下几个定义\n\n1. 全排列，\n1,2,3 三个数的全排列有：（字典序）\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n6种（对于n个不同数的全排列有 f(n) = n! 种）\n\n2. 字典序\n字典序就是对给定的字符集中的字符规定一个先后关系。这里的数字可以看做小数在大数前面。\n还有一种理解方法，你给上面每个数值相应位置定一个权值。\n比如第一个位置（最前面的）权值最大，为100；第二个为10；第三个为1。\n1 2 3 = 123\n1 3 2 = 132\n2 1 3 = 213\n2 3 1 = 231\n3 1 2 = 312\n3 2 1 = 321\n字典序，就可以看做是相应位置的数字乘以权值的和，按照最后得数的由小到大的顺序。\n\n<br/>\n\n这道题，是求下一个字典序的全排列。（因为题目中对于全排列规定了顺序，所以就可以求前一个或者后一个）\n可以看出 1 2 3 下一个 就是 1 3 2 再下一个就是 2 1 3。\n\n\n<br/>\n\n#### 模拟法\n\n从后向前，先比较前后大小，如果有前面的小于后面的，那就以那个位置为中心，可以进行修改。\n以 1 2 4 3 2 为例\n第二个位置 小于 第三个位置。\n找后面有没有比第二个数字大的最小的数（有点绕，就是找所有比2大的数，在这些里面取最小的）\n然后将 第二个位置的数 与 上面找到的数 替换位置。\n最后，对第二个位置右面的数列进行有小到大排序。\n\n1. 从后向前比较大小，如果前面的数小于后面，进入第2步；否则，逆序输出。\n2. 从当前数字及向右的序列中找出比左面数字大的最小数字及序列号\n3. 交换数值\n4. 对当前数字及向右的序列进行由小到大排序\n\n\n        class Solution {\n        private:\n            void findNextNumIndexFromRight(std::vector<int> nums, int& index, int& minDerta)    {\n                int standIndex = index-1;\n                for(int i = index; i < nums.size(); i++)    {\n                    int derta = nums[i] - nums[standIndex];\n                    if(derta > 0 && (derta < minDerta || minDerta <= 0))    {\n                        index = i;\n                        minDerta = derta;\n                    }\n                }\n            }\n        \n            void swapNum(int& a, int& b)    {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n        public:\n            void nextPermutation(vector<int>& nums) {\n                int len = nums.size();\n                for(int i = len-1; i > 0; i--)  {\n                    if(nums[i-1] < nums[i]) {\n                        int minIndex = i, minDerta = nums[i] - nums[i-1];\n                        findNextNumIndexFromRight(nums, minIndex, minDerta);\n                        swapNum(nums[i-1], nums[minIndex]); \n        \n                        // 此处用的冒泡排序\n                        for(int j = i; j < len; j++)\n                            for(int k = len-1; k > j; k--)\n                                if(nums[k] < nums[k-1]) \n                                    swapNum(nums[k-1], nums[k]);\n        \n                        return;\n                    }\n                }\n        \n                reverse(nums.begin(), nums.end());\n                return;\n            }\n        };\n\n\n<br/>\n\n#### 稍微改进一下\n\n\n        class Solution {\n        private:\n            int findNextNumIndexFromRight(std::vector<int> nums, int index) {\n                for(int i = nums.size()-1; i > index; i--)\n                    if(nums[i] > nums[index])\n                        return i;\n            }\n        \n            void swapNum(int& a, int& b)    {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n        public:\n            void nextPermutation(vector<int>& nums) {\n                int len = nums.size();\n                for(int i = len-1; i > 0; i--)  {\n                    if(nums[i-1] < nums[i]) {\n                        int minIndex = findNextNumIndexFromRight(nums, i-1);\n                        swapNum(nums[i-1], nums[minIndex]); \n                        reverse(nums.begin()+i, nums.end());\n                        return;\n                    }\n                }\n        \n                reverse(nums.begin(), nums.end());\n                return;\n            }\n        };\n\n\n<br/>\n\n##### 来几组测试数据吧\n\n\n        [1,2,3]\n        [1,3,2]\n        [1,1,5]\n        [3,2,1]\n        [1,2,3,2,1]\n        [5,4,7,5,3,2]\n        [5,4,7,4,3,2]","slug":"[Leetcode]_31  Next Permutation","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabi7001kveuexmsixgk8","content":"<p>Leetcode_31  Next Permutation</p>\n<a id=\"more\"></a>\n<p><br></p>\n<pre><code>/**\n*  Index: 31\n*  Title: Next Permutation\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>有必要说一下题意，我当时都没看明白这题。</p>\n<p>先了解一下几个定义</p>\n<ol>\n<li><p>全排列，<br>1,2,3 三个数的全排列有：（字典序）<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br>6种（对于n个不同数的全排列有 f(n) = n! 种）</p>\n</li>\n<li><p>字典序<br>字典序就是对给定的字符集中的字符规定一个先后关系。这里的数字可以看做小数在大数前面。<br>还有一种理解方法，你给上面每个数值相应位置定一个权值。<br>比如第一个位置（最前面的）权值最大，为100；第二个为10；第三个为1。<br>1 2 3 = 123<br>1 3 2 = 132<br>2 1 3 = 213<br>2 3 1 = 231<br>3 1 2 = 312<br>3 2 1 = 321<br>字典序，就可以看做是相应位置的数字乘以权值的和，按照最后得数的由小到大的顺序。</p>\n</li>\n</ol>\n<p><br></p>\n<p>这道题，是求下一个字典序的全排列。（因为题目中对于全排列规定了顺序，所以就可以求前一个或者后一个）<br>可以看出 1 2 3 下一个 就是 1 3 2 再下一个就是 2 1 3。</p>\n<p><br></p>\n<h4 id=\"模拟法\"><a href=\"#模拟法\" class=\"headerlink\" title=\"模拟法\"></a>模拟法</h4><p>从后向前，先比较前后大小，如果有前面的小于后面的，那就以那个位置为中心，可以进行修改。<br>以 1 2 4 3 2 为例<br>第二个位置 小于 第三个位置。<br>找后面有没有比第二个数字大的最小的数（有点绕，就是找所有比2大的数，在这些里面取最小的）<br>然后将 第二个位置的数 与 上面找到的数 替换位置。<br>最后，对第二个位置右面的数列进行有小到大排序。</p>\n<ol>\n<li>从后向前比较大小，如果前面的数小于后面，进入第2步；否则，逆序输出。</li>\n<li>从当前数字及向右的序列中找出比左面数字大的最小数字及序列号</li>\n<li>交换数值</li>\n<li>对当前数字及向右的序列进行由小到大排序</li>\n</ol>\n<pre><code>class Solution {\nprivate:\n    void findNextNumIndexFromRight(std::vector&lt;int&gt; nums, int&amp; index, int&amp; minDerta)    {\n        int standIndex = index-1;\n        for(int i = index; i &lt; nums.size(); i++)    {\n            int derta = nums[i] - nums[standIndex];\n            if(derta &gt; 0 &amp;&amp; (derta &lt; minDerta || minDerta &lt;= 0))    {\n                index = i;\n                minDerta = derta;\n            }\n        }\n    }\n\n    void swapNum(int&amp; a, int&amp; b)    {\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        for(int i = len-1; i &gt; 0; i--)  {\n            if(nums[i-1] &lt; nums[i]) {\n                int minIndex = i, minDerta = nums[i] - nums[i-1];\n                findNextNumIndexFromRight(nums, minIndex, minDerta);\n                swapNum(nums[i-1], nums[minIndex]); \n\n                // 此处用的冒泡排序\n                for(int j = i; j &lt; len; j++)\n                    for(int k = len-1; k &gt; j; k--)\n                        if(nums[k] &lt; nums[k-1]) \n                            swapNum(nums[k-1], nums[k]);\n\n                return;\n            }\n        }\n\n        reverse(nums.begin(), nums.end());\n        return;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"稍微改进一下\"><a href=\"#稍微改进一下\" class=\"headerlink\" title=\"稍微改进一下\"></a>稍微改进一下</h4><pre><code>class Solution {\nprivate:\n    int findNextNumIndexFromRight(std::vector&lt;int&gt; nums, int index) {\n        for(int i = nums.size()-1; i &gt; index; i--)\n            if(nums[i] &gt; nums[index])\n                return i;\n    }\n\n    void swapNum(int&amp; a, int&amp; b)    {\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        for(int i = len-1; i &gt; 0; i--)  {\n            if(nums[i-1] &lt; nums[i]) {\n                int minIndex = findNextNumIndexFromRight(nums, i-1);\n                swapNum(nums[i-1], nums[minIndex]); \n                reverse(nums.begin()+i, nums.end());\n                return;\n            }\n        }\n\n        reverse(nums.begin(), nums.end());\n        return;\n    }\n};\n</code></pre><p><br></p>\n<h5 id=\"来几组测试数据吧\"><a href=\"#来几组测试数据吧\" class=\"headerlink\" title=\"来几组测试数据吧\"></a>来几组测试数据吧</h5><pre><code>[1,2,3]\n[1,3,2]\n[1,1,5]\n[3,2,1]\n[1,2,3,2,1]\n[5,4,7,5,3,2]\n[5,4,7,4,3,2]\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_31  Next Permutation</p>","more":"<p><br></p>\n<pre><code>/**\n*  Index: 31\n*  Title: Next Permutation\n*  Author: ltree98\n**/\n</code></pre><p><br></p>\n<p>有必要说一下题意，我当时都没看明白这题。</p>\n<p>先了解一下几个定义</p>\n<ol>\n<li><p>全排列，<br>1,2,3 三个数的全排列有：（字典序）<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br>6种（对于n个不同数的全排列有 f(n) = n! 种）</p>\n</li>\n<li><p>字典序<br>字典序就是对给定的字符集中的字符规定一个先后关系。这里的数字可以看做小数在大数前面。<br>还有一种理解方法，你给上面每个数值相应位置定一个权值。<br>比如第一个位置（最前面的）权值最大，为100；第二个为10；第三个为1。<br>1 2 3 = 123<br>1 3 2 = 132<br>2 1 3 = 213<br>2 3 1 = 231<br>3 1 2 = 312<br>3 2 1 = 321<br>字典序，就可以看做是相应位置的数字乘以权值的和，按照最后得数的由小到大的顺序。</p>\n</li>\n</ol>\n<p><br></p>\n<p>这道题，是求下一个字典序的全排列。（因为题目中对于全排列规定了顺序，所以就可以求前一个或者后一个）<br>可以看出 1 2 3 下一个 就是 1 3 2 再下一个就是 2 1 3。</p>\n<p><br></p>\n<h4 id=\"模拟法\"><a href=\"#模拟法\" class=\"headerlink\" title=\"模拟法\"></a>模拟法</h4><p>从后向前，先比较前后大小，如果有前面的小于后面的，那就以那个位置为中心，可以进行修改。<br>以 1 2 4 3 2 为例<br>第二个位置 小于 第三个位置。<br>找后面有没有比第二个数字大的最小的数（有点绕，就是找所有比2大的数，在这些里面取最小的）<br>然后将 第二个位置的数 与 上面找到的数 替换位置。<br>最后，对第二个位置右面的数列进行有小到大排序。</p>\n<ol>\n<li>从后向前比较大小，如果前面的数小于后面，进入第2步；否则，逆序输出。</li>\n<li>从当前数字及向右的序列中找出比左面数字大的最小数字及序列号</li>\n<li>交换数值</li>\n<li>对当前数字及向右的序列进行由小到大排序</li>\n</ol>\n<pre><code>class Solution {\nprivate:\n    void findNextNumIndexFromRight(std::vector&lt;int&gt; nums, int&amp; index, int&amp; minDerta)    {\n        int standIndex = index-1;\n        for(int i = index; i &lt; nums.size(); i++)    {\n            int derta = nums[i] - nums[standIndex];\n            if(derta &gt; 0 &amp;&amp; (derta &lt; minDerta || minDerta &lt;= 0))    {\n                index = i;\n                minDerta = derta;\n            }\n        }\n    }\n\n    void swapNum(int&amp; a, int&amp; b)    {\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        for(int i = len-1; i &gt; 0; i--)  {\n            if(nums[i-1] &lt; nums[i]) {\n                int minIndex = i, minDerta = nums[i] - nums[i-1];\n                findNextNumIndexFromRight(nums, minIndex, minDerta);\n                swapNum(nums[i-1], nums[minIndex]); \n\n                // 此处用的冒泡排序\n                for(int j = i; j &lt; len; j++)\n                    for(int k = len-1; k &gt; j; k--)\n                        if(nums[k] &lt; nums[k-1]) \n                            swapNum(nums[k-1], nums[k]);\n\n                return;\n            }\n        }\n\n        reverse(nums.begin(), nums.end());\n        return;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"稍微改进一下\"><a href=\"#稍微改进一下\" class=\"headerlink\" title=\"稍微改进一下\"></a>稍微改进一下</h4><pre><code>class Solution {\nprivate:\n    int findNextNumIndexFromRight(std::vector&lt;int&gt; nums, int index) {\n        for(int i = nums.size()-1; i &gt; index; i--)\n            if(nums[i] &gt; nums[index])\n                return i;\n    }\n\n    void swapNum(int&amp; a, int&amp; b)    {\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        for(int i = len-1; i &gt; 0; i--)  {\n            if(nums[i-1] &lt; nums[i]) {\n                int minIndex = findNextNumIndexFromRight(nums, i-1);\n                swapNum(nums[i-1], nums[minIndex]); \n                reverse(nums.begin()+i, nums.end());\n                return;\n            }\n        }\n\n        reverse(nums.begin(), nums.end());\n        return;\n    }\n};\n</code></pre><p><br></p>\n<h5 id=\"来几组测试数据吧\"><a href=\"#来几组测试数据吧\" class=\"headerlink\" title=\"来几组测试数据吧\"></a>来几组测试数据吧</h5><pre><code>[1,2,3]\n[1,3,2]\n[1,1,5]\n[3,2,1]\n[1,2,3,2,1]\n[5,4,7,5,3,2]\n[5,4,7,4,3,2]\n</code></pre>"},{"title":"Leetcode_5  Longest Palindromic Substring","date":"2017-03-21T14:39:35.000Z","_content":"\nLeetcode_5  Longest Palindromic Substring\nDP\n\n<!-- more -->\n<br/>\n\n如果，str 是一个回文串，那么去掉str的头和尾，它也是一个回文串：\n比如 abcba -> bcb -> c \n所以，这题可通过动态规划来解。\n<br/>\n\n\n        class Solution {\n        public:\n            string longestPalindrome(string s) { \n                int len = s.length();\n                bool temp[1001][1001] = {0};\n        \n                int startSPos = 0;\n                int longestPaliLen = 1;\n        \n                for(int i = len - 1 ; i >= 0 ; i--)    {\n                    temp[i][i] = true;\n                    if( i > 0 and s[i - 1] == s[i] )    {\n                        temp[i-1][i] = true;\n                        startSPos = i - 1;\n                        longestPaliLen = 2;\n                    }\n                }\n        \n                for(int pLen = 3 ; pLen <= len ; pLen++) {\n                    for(int j = len - 1; j >= 0 ; j--)  {\n                        int i = j - pLen + 1;\n                        if(i < 0)\n                            break;\n        \n                        if( temp[i+1][j-1] == true and s[i] == s[j] )   {\n                            temp[i][j] = true;\n                            startSPos = i;\n                            longestPaliLen = pLen;\n                        }\n                    }\n                }\n        \n                return s.substr(startSPos, longestPaliLen);\n            }\n        };\n\n\n<br/>\n下面这种解法的亮点在于标记 key 的那部分；\n它将重复的字母跳过（因为他们一定是回文），\n并且能找到以这段重复字母为中心的的最长回文串，\n之后，\n还让下一个查找坐标直接拉到这段重复的回文串之后。\n\n<br/>\n\n\n        class Solution {\n        public:\n            string longestPalindrome(string s) { \n                int len = s.length();\n                if(len == 1)    \n                    return s;\n                \n                int startPos = 0, longestPaliLen = 1;\n                for(int i = 0; i < len; )    {\n                    int sPos = i, ePos = i;\n        \n                    // key\n                    while(ePos < len-1 && s[ePos+1] == s[ePos])\n                        ePos++;\n        \n                    i = ePos+1;\n                    while(ePos < len-1 && sPos > 0 && s[ePos+1] == s[sPos-1])   {\n                        sPos--;\n                        ePos++;\n                    }\n        \n                    int newLen = ePos - sPos + 1;\n                    if(newLen > longestPaliLen) {\n                        startPos = sPos;\n                        longestPaliLen = newLen;\n                    }\n                }\n        \n                return s.substr(startPos, longestPaliLen);\n            }\n        };\n","source":"_posts/[Leetcode]_5  Longest Palindromic Substring.md","raw":"---\ntitle: Leetcode_5  Longest Palindromic Substring\ndate: 2017-03-21 22:39:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_5  Longest Palindromic Substring\nDP\n\n<!-- more -->\n<br/>\n\n如果，str 是一个回文串，那么去掉str的头和尾，它也是一个回文串：\n比如 abcba -> bcb -> c \n所以，这题可通过动态规划来解。\n<br/>\n\n\n        class Solution {\n        public:\n            string longestPalindrome(string s) { \n                int len = s.length();\n                bool temp[1001][1001] = {0};\n        \n                int startSPos = 0;\n                int longestPaliLen = 1;\n        \n                for(int i = len - 1 ; i >= 0 ; i--)    {\n                    temp[i][i] = true;\n                    if( i > 0 and s[i - 1] == s[i] )    {\n                        temp[i-1][i] = true;\n                        startSPos = i - 1;\n                        longestPaliLen = 2;\n                    }\n                }\n        \n                for(int pLen = 3 ; pLen <= len ; pLen++) {\n                    for(int j = len - 1; j >= 0 ; j--)  {\n                        int i = j - pLen + 1;\n                        if(i < 0)\n                            break;\n        \n                        if( temp[i+1][j-1] == true and s[i] == s[j] )   {\n                            temp[i][j] = true;\n                            startSPos = i;\n                            longestPaliLen = pLen;\n                        }\n                    }\n                }\n        \n                return s.substr(startSPos, longestPaliLen);\n            }\n        };\n\n\n<br/>\n下面这种解法的亮点在于标记 key 的那部分；\n它将重复的字母跳过（因为他们一定是回文），\n并且能找到以这段重复字母为中心的的最长回文串，\n之后，\n还让下一个查找坐标直接拉到这段重复的回文串之后。\n\n<br/>\n\n\n        class Solution {\n        public:\n            string longestPalindrome(string s) { \n                int len = s.length();\n                if(len == 1)    \n                    return s;\n                \n                int startPos = 0, longestPaliLen = 1;\n                for(int i = 0; i < len; )    {\n                    int sPos = i, ePos = i;\n        \n                    // key\n                    while(ePos < len-1 && s[ePos+1] == s[ePos])\n                        ePos++;\n        \n                    i = ePos+1;\n                    while(ePos < len-1 && sPos > 0 && s[ePos+1] == s[sPos-1])   {\n                        sPos--;\n                        ePos++;\n                    }\n        \n                    int newLen = ePos - sPos + 1;\n                    if(newLen > longestPaliLen) {\n                        startPos = sPos;\n                        longestPaliLen = newLen;\n                    }\n                }\n        \n                return s.substr(startPos, longestPaliLen);\n            }\n        };\n","slug":"[Leetcode]_5  Longest Palindromic Substring","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabib001nveueqsnmmtnr","content":"<p>Leetcode_5  Longest Palindromic Substring<br>DP</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>如果，str 是一个回文串，那么去掉str的头和尾，它也是一个回文串：<br>比如 abcba -&gt; bcb -&gt; c<br>所以，这题可通过动态规划来解。<br><br></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) { \n        int len = s.length();\n        bool temp[1001][1001] = {0};\n\n        int startSPos = 0;\n        int longestPaliLen = 1;\n\n        for(int i = len - 1 ; i &gt;= 0 ; i--)    {\n            temp[i][i] = true;\n            if( i &gt; 0 and s[i - 1] == s[i] )    {\n                temp[i-1][i] = true;\n                startSPos = i - 1;\n                longestPaliLen = 2;\n            }\n        }\n\n        for(int pLen = 3 ; pLen &lt;= len ; pLen++) {\n            for(int j = len - 1; j &gt;= 0 ; j--)  {\n                int i = j - pLen + 1;\n                if(i &lt; 0)\n                    break;\n\n                if( temp[i+1][j-1] == true and s[i] == s[j] )   {\n                    temp[i][j] = true;\n                    startSPos = i;\n                    longestPaliLen = pLen;\n                }\n            }\n        }\n\n        return s.substr(startSPos, longestPaliLen);\n    }\n};\n</code></pre><p><br><br>下面这种解法的亮点在于标记 key 的那部分；<br>它将重复的字母跳过（因为他们一定是回文），<br>并且能找到以这段重复字母为中心的的最长回文串，<br>之后，<br>还让下一个查找坐标直接拉到这段重复的回文串之后。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) { \n        int len = s.length();\n        if(len == 1)    \n            return s;\n\n        int startPos = 0, longestPaliLen = 1;\n        for(int i = 0; i &lt; len; )    {\n            int sPos = i, ePos = i;\n\n            // key\n            while(ePos &lt; len-1 &amp;&amp; s[ePos+1] == s[ePos])\n                ePos++;\n\n            i = ePos+1;\n            while(ePos &lt; len-1 &amp;&amp; sPos &gt; 0 &amp;&amp; s[ePos+1] == s[sPos-1])   {\n                sPos--;\n                ePos++;\n            }\n\n            int newLen = ePos - sPos + 1;\n            if(newLen &gt; longestPaliLen) {\n                startPos = sPos;\n                longestPaliLen = newLen;\n            }\n        }\n\n        return s.substr(startPos, longestPaliLen);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_5  Longest Palindromic Substring<br>DP</p>","more":"<p><br></p>\n<p>如果，str 是一个回文串，那么去掉str的头和尾，它也是一个回文串：<br>比如 abcba -&gt; bcb -&gt; c<br>所以，这题可通过动态规划来解。<br><br></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) { \n        int len = s.length();\n        bool temp[1001][1001] = {0};\n\n        int startSPos = 0;\n        int longestPaliLen = 1;\n\n        for(int i = len - 1 ; i &gt;= 0 ; i--)    {\n            temp[i][i] = true;\n            if( i &gt; 0 and s[i - 1] == s[i] )    {\n                temp[i-1][i] = true;\n                startSPos = i - 1;\n                longestPaliLen = 2;\n            }\n        }\n\n        for(int pLen = 3 ; pLen &lt;= len ; pLen++) {\n            for(int j = len - 1; j &gt;= 0 ; j--)  {\n                int i = j - pLen + 1;\n                if(i &lt; 0)\n                    break;\n\n                if( temp[i+1][j-1] == true and s[i] == s[j] )   {\n                    temp[i][j] = true;\n                    startSPos = i;\n                    longestPaliLen = pLen;\n                }\n            }\n        }\n\n        return s.substr(startSPos, longestPaliLen);\n    }\n};\n</code></pre><p><br><br>下面这种解法的亮点在于标记 key 的那部分；<br>它将重复的字母跳过（因为他们一定是回文），<br>并且能找到以这段重复字母为中心的的最长回文串，<br>之后，<br>还让下一个查找坐标直接拉到这段重复的回文串之后。</p>\n<p><br></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) { \n        int len = s.length();\n        if(len == 1)    \n            return s;\n\n        int startPos = 0, longestPaliLen = 1;\n        for(int i = 0; i &lt; len; )    {\n            int sPos = i, ePos = i;\n\n            // key\n            while(ePos &lt; len-1 &amp;&amp; s[ePos+1] == s[ePos])\n                ePos++;\n\n            i = ePos+1;\n            while(ePos &lt; len-1 &amp;&amp; sPos &gt; 0 &amp;&amp; s[ePos+1] == s[sPos-1])   {\n                sPos--;\n                ePos++;\n            }\n\n            int newLen = ePos - sPos + 1;\n            if(newLen &gt; longestPaliLen) {\n                startPos = sPos;\n                longestPaliLen = newLen;\n            }\n        }\n\n        return s.substr(startPos, longestPaliLen);\n    }\n};\n</code></pre>"},{"title":"Leetcode_6  ZigZag Conversion","date":"2017-03-27T14:48:00.000Z","_content":"\nLeetcode_6  ZigZag Conversion\n模拟法，找规律\n\n\n<!-- more -->\n<br/>\n\n其实，这题本质上应该算是找规律的题目。\n按特定的要求输出字符串。\n\n<br/>\n\n#### 1.模拟法\n\n将一长串字符，分成n行，可以根据要求，把每行分别求出来，最后合并成一行输出。\n也就是说 ABCDEFGHIJKLMN 分成4行。\n模拟它的之字形走位，4行将分别为:\n        \n\n        A   G     M\n        B  F H   L N\n        C E   I K\n        D      J\n\n\n也就是:\n\n\n        AGM\n        BFHLN\n        CEIK\n        DJ\n\n\n按照它的走位，可以定一个头部，到特定位置，让头部改变方向（此题方向只有两个，上和下），最后合并即可。\n\n\n        class Solution {\n        public:\n            string convert(string s, int numRows) {\n                int len = s.length();\n                if( numRows == 1 or len <= numRows )\n                    return s;\n        \n                string temp[10001];\n                int dir = 1;\n                int tIndex = 0;\n                int index = 0;\n        \n                while( index < len ) {\n                    temp[tIndex] += s[index];\n                    if( dir == 1 and tIndex >= numRows-1 )    {\n                        dir = -1;\n                    }\n                    else if( dir == -1 and tIndex <= 0 ) {\n                        dir = 1;\n                    }\n                    tIndex = tIndex + dir;\n                    index++;\n                }\n        \n                string ans = \"\";\n                for(int i = 0; i < numRows; i++)    {\n                    ans += temp[i];\n                }\n        \n                return ans;\n            }\n        };\n\n<br/>\n\n\n#### 2.找规律\n\n这种题，模拟法一般都能过，如果有更好的方法，那就是找规律。\n这题，一看就觉得是有规律的，最简单的最上面和最下面一行，间隔数基本是固定的： 2\\*n-2(n 就是要求列的行数)\n最主要的是第一行和最后一行中间部分的规律。\n中间部分的规律是: 2\\*n-2-2\\*i\n具体如何找规律?\n其实我也没啥窍门，可以试试多划拉划拉，多找几个例子....\n\n\n\n        class Solution {\n        public:\n            string convert(string s, int numRows) {\n                int len = s.length();\n                if( len == 0 || numRows < 2 )\n                    return s;\n\n                string ans = \"\";\n                int rtrn = 2 * numRows - 2;\n                for(int tIndex = 0; tIndex < numRows; tIndex++)    {\n                    for(int index = tIndex; index < len; index+=rtrn)   {\n                        ans += s[index];\n\n                        if(tIndex > 0 && tIndex < numRows-1)    {\n                            int midIndex = index + rtrn - 2*tIndex;\n                            if(midIndex < len)\n                                ans += s[midIndex];\n                        }\n                    }\n                }\n                return ans;\n            }\n        };\n","source":"_posts/[Leetcode]_6  ZigZag Conversion.md","raw":"---\ntitle: Leetcode_6  ZigZag Conversion\ndate: 2017-03-27 22:48:00\ntags: [Leetcode, 算法]\n---\n\nLeetcode_6  ZigZag Conversion\n模拟法，找规律\n\n\n<!-- more -->\n<br/>\n\n其实，这题本质上应该算是找规律的题目。\n按特定的要求输出字符串。\n\n<br/>\n\n#### 1.模拟法\n\n将一长串字符，分成n行，可以根据要求，把每行分别求出来，最后合并成一行输出。\n也就是说 ABCDEFGHIJKLMN 分成4行。\n模拟它的之字形走位，4行将分别为:\n        \n\n        A   G     M\n        B  F H   L N\n        C E   I K\n        D      J\n\n\n也就是:\n\n\n        AGM\n        BFHLN\n        CEIK\n        DJ\n\n\n按照它的走位，可以定一个头部，到特定位置，让头部改变方向（此题方向只有两个，上和下），最后合并即可。\n\n\n        class Solution {\n        public:\n            string convert(string s, int numRows) {\n                int len = s.length();\n                if( numRows == 1 or len <= numRows )\n                    return s;\n        \n                string temp[10001];\n                int dir = 1;\n                int tIndex = 0;\n                int index = 0;\n        \n                while( index < len ) {\n                    temp[tIndex] += s[index];\n                    if( dir == 1 and tIndex >= numRows-1 )    {\n                        dir = -1;\n                    }\n                    else if( dir == -1 and tIndex <= 0 ) {\n                        dir = 1;\n                    }\n                    tIndex = tIndex + dir;\n                    index++;\n                }\n        \n                string ans = \"\";\n                for(int i = 0; i < numRows; i++)    {\n                    ans += temp[i];\n                }\n        \n                return ans;\n            }\n        };\n\n<br/>\n\n\n#### 2.找规律\n\n这种题，模拟法一般都能过，如果有更好的方法，那就是找规律。\n这题，一看就觉得是有规律的，最简单的最上面和最下面一行，间隔数基本是固定的： 2\\*n-2(n 就是要求列的行数)\n最主要的是第一行和最后一行中间部分的规律。\n中间部分的规律是: 2\\*n-2-2\\*i\n具体如何找规律?\n其实我也没啥窍门，可以试试多划拉划拉，多找几个例子....\n\n\n\n        class Solution {\n        public:\n            string convert(string s, int numRows) {\n                int len = s.length();\n                if( len == 0 || numRows < 2 )\n                    return s;\n\n                string ans = \"\";\n                int rtrn = 2 * numRows - 2;\n                for(int tIndex = 0; tIndex < numRows; tIndex++)    {\n                    for(int index = tIndex; index < len; index+=rtrn)   {\n                        ans += s[index];\n\n                        if(tIndex > 0 && tIndex < numRows-1)    {\n                            int midIndex = index + rtrn - 2*tIndex;\n                            if(midIndex < len)\n                                ans += s[midIndex];\n                        }\n                    }\n                }\n                return ans;\n            }\n        };\n","slug":"[Leetcode]_6  ZigZag Conversion","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabid001pveuegyy4g5dm","content":"<p>Leetcode_6  ZigZag Conversion<br>模拟法，找规律</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>其实，这题本质上应该算是找规律的题目。<br>按特定的要求输出字符串。</p>\n<p><br></p>\n<h4 id=\"1-模拟法\"><a href=\"#1-模拟法\" class=\"headerlink\" title=\"1.模拟法\"></a>1.模拟法</h4><p>将一长串字符，分成n行，可以根据要求，把每行分别求出来，最后合并成一行输出。<br>也就是说 ABCDEFGHIJKLMN 分成4行。<br>模拟它的之字形走位，4行将分别为:</p>\n<pre><code>A   G     M\nB  F H   L N\nC E   I K\nD      J\n</code></pre><p>也就是:</p>\n<pre><code>AGM\nBFHLN\nCEIK\nDJ\n</code></pre><p>按照它的走位，可以定一个头部，到特定位置，让头部改变方向（此题方向只有两个，上和下），最后合并即可。</p>\n<pre><code>class Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        if( numRows == 1 or len &lt;= numRows )\n            return s;\n\n        string temp[10001];\n        int dir = 1;\n        int tIndex = 0;\n        int index = 0;\n\n        while( index &lt; len ) {\n            temp[tIndex] += s[index];\n            if( dir == 1 and tIndex &gt;= numRows-1 )    {\n                dir = -1;\n            }\n            else if( dir == -1 and tIndex &lt;= 0 ) {\n                dir = 1;\n            }\n            tIndex = tIndex + dir;\n            index++;\n        }\n\n        string ans = &quot;&quot;;\n        for(int i = 0; i &lt; numRows; i++)    {\n            ans += temp[i];\n        }\n\n        return ans;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2-找规律\"><a href=\"#2-找规律\" class=\"headerlink\" title=\"2.找规律\"></a>2.找规律</h4><p>这种题，模拟法一般都能过，如果有更好的方法，那就是找规律。<br>这题，一看就觉得是有规律的，最简单的最上面和最下面一行，间隔数基本是固定的： 2*n-2(n 就是要求列的行数)<br>最主要的是第一行和最后一行中间部分的规律。<br>中间部分的规律是: 2*n-2-2*i<br>具体如何找规律?<br>其实我也没啥窍门，可以试试多划拉划拉，多找几个例子….</p>\n<pre><code>class Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        if( len == 0 || numRows &lt; 2 )\n            return s;\n\n        string ans = &quot;&quot;;\n        int rtrn = 2 * numRows - 2;\n        for(int tIndex = 0; tIndex &lt; numRows; tIndex++)    {\n            for(int index = tIndex; index &lt; len; index+=rtrn)   {\n                ans += s[index];\n\n                if(tIndex &gt; 0 &amp;&amp; tIndex &lt; numRows-1)    {\n                    int midIndex = index + rtrn - 2*tIndex;\n                    if(midIndex &lt; len)\n                        ans += s[midIndex];\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_6  ZigZag Conversion<br>模拟法，找规律</p>","more":"<p><br></p>\n<p>其实，这题本质上应该算是找规律的题目。<br>按特定的要求输出字符串。</p>\n<p><br></p>\n<h4 id=\"1-模拟法\"><a href=\"#1-模拟法\" class=\"headerlink\" title=\"1.模拟法\"></a>1.模拟法</h4><p>将一长串字符，分成n行，可以根据要求，把每行分别求出来，最后合并成一行输出。<br>也就是说 ABCDEFGHIJKLMN 分成4行。<br>模拟它的之字形走位，4行将分别为:</p>\n<pre><code>A   G     M\nB  F H   L N\nC E   I K\nD      J\n</code></pre><p>也就是:</p>\n<pre><code>AGM\nBFHLN\nCEIK\nDJ\n</code></pre><p>按照它的走位，可以定一个头部，到特定位置，让头部改变方向（此题方向只有两个，上和下），最后合并即可。</p>\n<pre><code>class Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        if( numRows == 1 or len &lt;= numRows )\n            return s;\n\n        string temp[10001];\n        int dir = 1;\n        int tIndex = 0;\n        int index = 0;\n\n        while( index &lt; len ) {\n            temp[tIndex] += s[index];\n            if( dir == 1 and tIndex &gt;= numRows-1 )    {\n                dir = -1;\n            }\n            else if( dir == -1 and tIndex &lt;= 0 ) {\n                dir = 1;\n            }\n            tIndex = tIndex + dir;\n            index++;\n        }\n\n        string ans = &quot;&quot;;\n        for(int i = 0; i &lt; numRows; i++)    {\n            ans += temp[i];\n        }\n\n        return ans;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2-找规律\"><a href=\"#2-找规律\" class=\"headerlink\" title=\"2.找规律\"></a>2.找规律</h4><p>这种题，模拟法一般都能过，如果有更好的方法，那就是找规律。<br>这题，一看就觉得是有规律的，最简单的最上面和最下面一行，间隔数基本是固定的： 2*n-2(n 就是要求列的行数)<br>最主要的是第一行和最后一行中间部分的规律。<br>中间部分的规律是: 2*n-2-2*i<br>具体如何找规律?<br>其实我也没啥窍门，可以试试多划拉划拉，多找几个例子….</p>\n<pre><code>class Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        if( len == 0 || numRows &lt; 2 )\n            return s;\n\n        string ans = &quot;&quot;;\n        int rtrn = 2 * numRows - 2;\n        for(int tIndex = 0; tIndex &lt; numRows; tIndex++)    {\n            for(int index = tIndex; index &lt; len; index+=rtrn)   {\n                ans += s[index];\n\n                if(tIndex &gt; 0 &amp;&amp; tIndex &lt; numRows-1)    {\n                    int midIndex = index + rtrn - 2*tIndex;\n                    if(midIndex &lt; len)\n                        ans += s[midIndex];\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_7  Reverse Integer","date":"2017-03-23T14:55:35.000Z","_content":"\nLeetcode_7  Reverse Integer\n\n\n<!-- more -->\n<br/>\n\n注意值范围\n然后，就没了。\n\n\n\n        /**\n        *  Index: 7\n        *  Title: Reverse Integer\n        *  Author: ltree98\n        **/\n\n        class Solution {\n        public:\n            int reverse(int x) {    \n                long long ans = 0;\n                while( x != 0 ) {\n                    int temp = x % 10;\n                    ans = ans*10 + temp;\n                    x /= 10;\n                }\n        \n                if(ans > INT_MAX || ans < INT_MIN)\n                    return 0;        \n                return int(ans);\n            }\n        };","source":"_posts/[Leetcode]_7  Reverse Integer.md","raw":"---\ntitle: Leetcode_7  Reverse Integer\ndate: 2017-03-23 22:55:35\ntags: [Leetcode, 算法]\n---\n\nLeetcode_7  Reverse Integer\n\n\n<!-- more -->\n<br/>\n\n注意值范围\n然后，就没了。\n\n\n\n        /**\n        *  Index: 7\n        *  Title: Reverse Integer\n        *  Author: ltree98\n        **/\n\n        class Solution {\n        public:\n            int reverse(int x) {    \n                long long ans = 0;\n                while( x != 0 ) {\n                    int temp = x % 10;\n                    ans = ans*10 + temp;\n                    x /= 10;\n                }\n        \n                if(ans > INT_MAX || ans < INT_MIN)\n                    return 0;        \n                return int(ans);\n            }\n        };","slug":"[Leetcode]_7  Reverse Integer","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabih001sveuedn0p6hg8","content":"<p>Leetcode_7  Reverse Integer</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>注意值范围<br>然后，就没了。</p>\n<pre><code>/**\n*  Index: 7\n*  Title: Reverse Integer\n*  Author: ltree98\n**/\n\nclass Solution {\npublic:\n    int reverse(int x) {    \n        long long ans = 0;\n        while( x != 0 ) {\n            int temp = x % 10;\n            ans = ans*10 + temp;\n            x /= 10;\n        }\n\n        if(ans &gt; INT_MAX || ans &lt; INT_MIN)\n            return 0;        \n        return int(ans);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_7  Reverse Integer</p>","more":"<p><br></p>\n<p>注意值范围<br>然后，就没了。</p>\n<pre><code>/**\n*  Index: 7\n*  Title: Reverse Integer\n*  Author: ltree98\n**/\n\nclass Solution {\npublic:\n    int reverse(int x) {    \n        long long ans = 0;\n        while( x != 0 ) {\n            int temp = x % 10;\n            ans = ans*10 + temp;\n            x /= 10;\n        }\n\n        if(ans &gt; INT_MAX || ans &lt; INT_MIN)\n            return 0;        \n        return int(ans);\n    }\n};\n</code></pre>"},{"title":"Leetcode_8  String to Integer(atoi)","date":"2017-03-28T14:20:11.000Z","_content":"\nLeetcode_8  String to Integer(atoi)\n\n\n<!-- more -->\n<br/>\n\n注意处理一些细节东西，\n提供一下我的测试数据吧。\n\n\n\n        /**\n        -- test case:\n        \"\"\n        \"abc\"\n        \"01234\"\n        \"0.2\"\n        \"-123\"\n        \"123.a\"\n        \"12a23\"\n        \"abc12\"\n        \"-123a\"\n        \"-12-\"\n        \".\"\n        \"+1\"\n        \"-+1\"\n        \"+-1\"\n        \"      33\"\n        \"-      33\"\n        \"      003\"\n        \"+     22\"\n        \"     +004500\"\n        \"13+-1\"\n        \"123   3\"\n        \"3147483647\"\n        \"-3147483648\"\n        \"9223372036854775809\"\n        \"1234             3746813578\"\n        **/\n\n\n\n\n        class Solution {\n        public:\n            int myAtoi(string str) {\n                int flg = 0;\n                long long ans = 0;\n                int len = str.length();\n                for(int index = 0; index < len; index++)    {\n                    int num = str[index] - '0';\n                    if(str[index] == '-' or str[index] == '+')  {\n                        if(flg == 0)\n                            flg = ',' - str[index];\n                        else\n                            break;\n                    }\n                    else if (str[index] == ' ' and flg == 0)\n                    {\n                        continue;\n                    }\n                    else if( num >= 0 && num <= 9 ) {\n                        if(flg == 0)    {\n                            flg = 1;\n                        }\n                        ans = ans*10 + num;\n                        if( ans > INT_MAX )\n                            break;\n                    }\n                    else\n                        break;\n                }\n        \n                ans = ans * flg;\n                if(ans < INT_MIN)\n                    ans = INT_MIN;\n                else if(ans > INT_MAX)\n                    ans = INT_MAX;\n                return ans;\n            }\n        };","source":"_posts/[Leetcode]_8  String to Integer(atoi).md","raw":"---\ntitle: Leetcode_8  String to Integer(atoi)\ndate: 2017-03-28 22:20:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_8  String to Integer(atoi)\n\n\n<!-- more -->\n<br/>\n\n注意处理一些细节东西，\n提供一下我的测试数据吧。\n\n\n\n        /**\n        -- test case:\n        \"\"\n        \"abc\"\n        \"01234\"\n        \"0.2\"\n        \"-123\"\n        \"123.a\"\n        \"12a23\"\n        \"abc12\"\n        \"-123a\"\n        \"-12-\"\n        \".\"\n        \"+1\"\n        \"-+1\"\n        \"+-1\"\n        \"      33\"\n        \"-      33\"\n        \"      003\"\n        \"+     22\"\n        \"     +004500\"\n        \"13+-1\"\n        \"123   3\"\n        \"3147483647\"\n        \"-3147483648\"\n        \"9223372036854775809\"\n        \"1234             3746813578\"\n        **/\n\n\n\n\n        class Solution {\n        public:\n            int myAtoi(string str) {\n                int flg = 0;\n                long long ans = 0;\n                int len = str.length();\n                for(int index = 0; index < len; index++)    {\n                    int num = str[index] - '0';\n                    if(str[index] == '-' or str[index] == '+')  {\n                        if(flg == 0)\n                            flg = ',' - str[index];\n                        else\n                            break;\n                    }\n                    else if (str[index] == ' ' and flg == 0)\n                    {\n                        continue;\n                    }\n                    else if( num >= 0 && num <= 9 ) {\n                        if(flg == 0)    {\n                            flg = 1;\n                        }\n                        ans = ans*10 + num;\n                        if( ans > INT_MAX )\n                            break;\n                    }\n                    else\n                        break;\n                }\n        \n                ans = ans * flg;\n                if(ans < INT_MIN)\n                    ans = INT_MIN;\n                else if(ans > INT_MAX)\n                    ans = INT_MAX;\n                return ans;\n            }\n        };","slug":"[Leetcode]_8  String to Integer(atoi)","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabin001uveueckr3719c","content":"<p>Leetcode_8  String to Integer(atoi)</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>注意处理一些细节东西，<br>提供一下我的测试数据吧。</p>\n<pre><code>/**\n-- test case:\n&quot;&quot;\n&quot;abc&quot;\n&quot;01234&quot;\n&quot;0.2&quot;\n&quot;-123&quot;\n&quot;123.a&quot;\n&quot;12a23&quot;\n&quot;abc12&quot;\n&quot;-123a&quot;\n&quot;-12-&quot;\n&quot;.&quot;\n&quot;+1&quot;\n&quot;-+1&quot;\n&quot;+-1&quot;\n&quot;      33&quot;\n&quot;-      33&quot;\n&quot;      003&quot;\n&quot;+     22&quot;\n&quot;     +004500&quot;\n&quot;13+-1&quot;\n&quot;123   3&quot;\n&quot;3147483647&quot;\n&quot;-3147483648&quot;\n&quot;9223372036854775809&quot;\n&quot;1234             3746813578&quot;\n**/\n\n\n\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        int flg = 0;\n        long long ans = 0;\n        int len = str.length();\n        for(int index = 0; index &lt; len; index++)    {\n            int num = str[index] - &apos;0&apos;;\n            if(str[index] == &apos;-&apos; or str[index] == &apos;+&apos;)  {\n                if(flg == 0)\n                    flg = &apos;,&apos; - str[index];\n                else\n                    break;\n            }\n            else if (str[index] == &apos; &apos; and flg == 0)\n            {\n                continue;\n            }\n            else if( num &gt;= 0 &amp;&amp; num &lt;= 9 ) {\n                if(flg == 0)    {\n                    flg = 1;\n                }\n                ans = ans*10 + num;\n                if( ans &gt; INT_MAX )\n                    break;\n            }\n            else\n                break;\n        }\n\n        ans = ans * flg;\n        if(ans &lt; INT_MIN)\n            ans = INT_MIN;\n        else if(ans &gt; INT_MAX)\n            ans = INT_MAX;\n        return ans;\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_8  String to Integer(atoi)</p>","more":"<p><br></p>\n<p>注意处理一些细节东西，<br>提供一下我的测试数据吧。</p>\n<pre><code>/**\n-- test case:\n&quot;&quot;\n&quot;abc&quot;\n&quot;01234&quot;\n&quot;0.2&quot;\n&quot;-123&quot;\n&quot;123.a&quot;\n&quot;12a23&quot;\n&quot;abc12&quot;\n&quot;-123a&quot;\n&quot;-12-&quot;\n&quot;.&quot;\n&quot;+1&quot;\n&quot;-+1&quot;\n&quot;+-1&quot;\n&quot;      33&quot;\n&quot;-      33&quot;\n&quot;      003&quot;\n&quot;+     22&quot;\n&quot;     +004500&quot;\n&quot;13+-1&quot;\n&quot;123   3&quot;\n&quot;3147483647&quot;\n&quot;-3147483648&quot;\n&quot;9223372036854775809&quot;\n&quot;1234             3746813578&quot;\n**/\n\n\n\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        int flg = 0;\n        long long ans = 0;\n        int len = str.length();\n        for(int index = 0; index &lt; len; index++)    {\n            int num = str[index] - &apos;0&apos;;\n            if(str[index] == &apos;-&apos; or str[index] == &apos;+&apos;)  {\n                if(flg == 0)\n                    flg = &apos;,&apos; - str[index];\n                else\n                    break;\n            }\n            else if (str[index] == &apos; &apos; and flg == 0)\n            {\n                continue;\n            }\n            else if( num &gt;= 0 &amp;&amp; num &lt;= 9 ) {\n                if(flg == 0)    {\n                    flg = 1;\n                }\n                ans = ans*10 + num;\n                if( ans &gt; INT_MAX )\n                    break;\n            }\n            else\n                break;\n        }\n\n        ans = ans * flg;\n        if(ans &lt; INT_MIN)\n            ans = INT_MIN;\n        else if(ans &gt; INT_MAX)\n            ans = INT_MAX;\n        return ans;\n    }\n};\n</code></pre>"},{"title":"Leetcode_9  Palindrome Number","date":"2017-03-30T14:39:11.000Z","_content":"\nLeetcode_9  Palindrome Number\n\n\n<!-- more -->\n<br/>\n\n之前做过回文字符串了，这次是回文数。\n很简单的一道题，但是，要求不用额外的空间。（PS：这里指不用额外空间，空间复杂度O(1)就可以了，感觉就是表明，不让用字符数组）\n\n<br/>\n\n#### 1\n\n我第一个想法就是，每次比较头尾两个数，一直向中间逼近。\n事实证明，还是可以的，就是感觉速度好慢，而且代码冗长。\n\n\n\n        class Solution {\n        public:\n            bool isPalindrome(int x) {\n                if( x < 0 ) \n                    return false;\n        \n                int len = 0;\n                int num = x;\n                do\n                {\n                    num /= 10;\n                    ++len;\n                }while (num); \n        \n                while( x )  {\n                    int fj = pow(10, --len);\n                    int f = x / fj;\n                    int b = x % 10;\n                    if( f != b )    {\n                        return false;\n                    }\n        \n                    x = (x - fj*f - b)/10;\n                    --len;\n                }\n        \n                return true;\n            }\n        };\n\n\n\n<br/>\n\n#### 2\n\n看了看solution里的大神们，\n发现一个特别短的代码，惊了个天...\n就是求这个数字的逆序，然后在比较到一半的时候进行判断。\n照顾到数字位数是奇数的情况，还判断了palNum/10与前半段的大小。\n\n噢，对了；\n这种方法无法判断多位数且个位是0的情况，可以在判断负数时顺便处理。\n\n\n        class Solution {\n        public:\n            bool isPalindrome(int x) {\n                if( x < 0 || ( x!=0 && x%10 == 0) )\n                    return false;\n        \n                int palNum = 0;\n                while( x > palNum ) {\n                    palNum = palNum * 10 + x%10;\n                    x /= 10;\n                }\n        \n                return (x == palNum || x == palNum/10);\n            }\n        };\n","source":"_posts/[Leetcode]_9  Palindrome Number.md","raw":"---\ntitle: Leetcode_9  Palindrome Number\ndate: 2017-03-30 22:39:11\ntags: [Leetcode, 算法]\n---\n\nLeetcode_9  Palindrome Number\n\n\n<!-- more -->\n<br/>\n\n之前做过回文字符串了，这次是回文数。\n很简单的一道题，但是，要求不用额外的空间。（PS：这里指不用额外空间，空间复杂度O(1)就可以了，感觉就是表明，不让用字符数组）\n\n<br/>\n\n#### 1\n\n我第一个想法就是，每次比较头尾两个数，一直向中间逼近。\n事实证明，还是可以的，就是感觉速度好慢，而且代码冗长。\n\n\n\n        class Solution {\n        public:\n            bool isPalindrome(int x) {\n                if( x < 0 ) \n                    return false;\n        \n                int len = 0;\n                int num = x;\n                do\n                {\n                    num /= 10;\n                    ++len;\n                }while (num); \n        \n                while( x )  {\n                    int fj = pow(10, --len);\n                    int f = x / fj;\n                    int b = x % 10;\n                    if( f != b )    {\n                        return false;\n                    }\n        \n                    x = (x - fj*f - b)/10;\n                    --len;\n                }\n        \n                return true;\n            }\n        };\n\n\n\n<br/>\n\n#### 2\n\n看了看solution里的大神们，\n发现一个特别短的代码，惊了个天...\n就是求这个数字的逆序，然后在比较到一半的时候进行判断。\n照顾到数字位数是奇数的情况，还判断了palNum/10与前半段的大小。\n\n噢，对了；\n这种方法无法判断多位数且个位是0的情况，可以在判断负数时顺便处理。\n\n\n        class Solution {\n        public:\n            bool isPalindrome(int x) {\n                if( x < 0 || ( x!=0 && x%10 == 0) )\n                    return false;\n        \n                int palNum = 0;\n                while( x > palNum ) {\n                    palNum = palNum * 10 + x%10;\n                    x /= 10;\n                }\n        \n                return (x == palNum || x == palNum/10);\n            }\n        };\n","slug":"[Leetcode]_9  Palindrome Number","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabir001xveueqgy5tuwa","content":"<p>Leetcode_9  Palindrome Number</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>之前做过回文字符串了，这次是回文数。<br>很简单的一道题，但是，要求不用额外的空间。（PS：这里指不用额外空间，空间复杂度O(1)就可以了，感觉就是表明，不让用字符数组）</p>\n<p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p>我第一个想法就是，每次比较头尾两个数，一直向中间逼近。<br>事实证明，还是可以的，就是感觉速度好慢，而且代码冗长。</p>\n<pre><code>class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if( x &lt; 0 ) \n            return false;\n\n        int len = 0;\n        int num = x;\n        do\n        {\n            num /= 10;\n            ++len;\n        }while (num); \n\n        while( x )  {\n            int fj = pow(10, --len);\n            int f = x / fj;\n            int b = x % 10;\n            if( f != b )    {\n                return false;\n            }\n\n            x = (x - fj*f - b)/10;\n            --len;\n        }\n\n        return true;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p>看了看solution里的大神们，<br>发现一个特别短的代码，惊了个天…<br>就是求这个数字的逆序，然后在比较到一半的时候进行判断。<br>照顾到数字位数是奇数的情况，还判断了palNum/10与前半段的大小。</p>\n<p>噢，对了；<br>这种方法无法判断多位数且个位是0的情况，可以在判断负数时顺便处理。</p>\n<pre><code>class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if( x &lt; 0 || ( x!=0 &amp;&amp; x%10 == 0) )\n            return false;\n\n        int palNum = 0;\n        while( x &gt; palNum ) {\n            palNum = palNum * 10 + x%10;\n            x /= 10;\n        }\n\n        return (x == palNum || x == palNum/10);\n    }\n};\n</code></pre>","site":{"data":{}},"excerpt":"<p>Leetcode_9  Palindrome Number</p>","more":"<p><br></p>\n<p>之前做过回文字符串了，这次是回文数。<br>很简单的一道题，但是，要求不用额外的空间。（PS：这里指不用额外空间，空间复杂度O(1)就可以了，感觉就是表明，不让用字符数组）</p>\n<p><br></p>\n<h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h4><p>我第一个想法就是，每次比较头尾两个数，一直向中间逼近。<br>事实证明，还是可以的，就是感觉速度好慢，而且代码冗长。</p>\n<pre><code>class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if( x &lt; 0 ) \n            return false;\n\n        int len = 0;\n        int num = x;\n        do\n        {\n            num /= 10;\n            ++len;\n        }while (num); \n\n        while( x )  {\n            int fj = pow(10, --len);\n            int f = x / fj;\n            int b = x % 10;\n            if( f != b )    {\n                return false;\n            }\n\n            x = (x - fj*f - b)/10;\n            --len;\n        }\n\n        return true;\n    }\n};\n</code></pre><p><br></p>\n<h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h4><p>看了看solution里的大神们，<br>发现一个特别短的代码，惊了个天…<br>就是求这个数字的逆序，然后在比较到一半的时候进行判断。<br>照顾到数字位数是奇数的情况，还判断了palNum/10与前半段的大小。</p>\n<p>噢，对了；<br>这种方法无法判断多位数且个位是0的情况，可以在判断负数时顺便处理。</p>\n<pre><code>class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if( x &lt; 0 || ( x!=0 &amp;&amp; x%10 == 0) )\n            return false;\n\n        int palNum = 0;\n        while( x &gt; palNum ) {\n            palNum = palNum * 10 + x%10;\n            x /= 10;\n        }\n\n        return (x == palNum || x == palNum/10);\n    }\n};\n</code></pre>"},{"title":"cocos2d-x 接入 GameCenter 排行榜与成就","date":"2017-04-29T04:13:11.000Z","_content":"\ncocos2d-x 接入 GameCenter 排行榜与成就\n[mac - XCode 8.3 - cocos2d-x lua]\n\n\n<!-- more -->\n### 前言\n\n要求接入GameCenter的排行榜和成就。\n\nGameCenter 是苹果推出的一个社交平台，\n它主要提供了以下几个功能：\n- 排行榜\n- 成就\n- 挑战\n而且，苹果同时提供了GameKit框架来让GameCenter更易集成。\n\n\n可能是因为GameCenter的热度过去了吧，相关的东西都比较早期。\n整理总结了一下，希望对他人有所帮助。\n\n我的环境：\n\nmac - XCode 8.3 - cocos2d-x lua\n\n<br/>\n<br/>\n<br/>\n\n### 1. 公共的处理\n<br/>\n\n##### 1.1 配置 iTunes Connect 排行榜与成就的位置。\n登录iTunes Connect, 找到要处理的APP。\n选择 功能->GameCenter\n可以看到三个大项：\n- 移动群组\n- 排行榜\n- 成就\n\n<br/>\n\n##### 1.2 添加GameKit框架\n打开项目工程，将 Capabilities 的 GameCenter 打开。\n这样，XCode就会将GameKit框架加到我们的工程中。\n\n<br/>\n\n##### 1.3 登录GameCenter\n登录GameCenter:  【这个步骤在我们加载完游戏时进行即可】\n\n\n        -(void) authenticateLocalPlayer {\n            // 获取本地用户\n            GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n        \n            // 认证登录\n            localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n                [self setLastError:error];\n        \n                if (localPlayer.authenticated) {                        // 本地用户已经登录\n                    _gameCenterFeaturesEnabled = YES;                   // 此变量是判断是否已经登录上GameCenter\n                } else if(viewController) {                             // 没有用户，弹出登录界面\n                    [self presentViewController:viewController];        \n                } else {                                                // 没有用户，并且没有登录界面\n                    _gameCenterFeaturesEnabled = NO;\n                }\n            };\n        }\n\n\n<br/>\n\n##### 1.4 关于lua调用object-c\n因为我的环境是 cocos2d-x lua，所以，用通过lua来调用object-c。\ncocos2d-x其实已经有相关的调用结构 —— LuaObjcBridge, 可以直接用 callStaticMethod来调用：\n\n\n        LuaObjcBridge.callStaticMethod(methodName className,args)\n\n\n<br/>\n\n##### 1.5 GameKit辅助处理类\nGameKitHelper.h:\n\n\n\n        #import <GameKit/GameKit.h>\n        #import \"cocos2d.h\"\n        \n        // 方便lua调用\n        #include \"CCLuaEngine.h\"\n        #include \"CCLuaBridge.h\"\n        \n        @interface GameKitHelper : NSObject\n        // 处理错误\n        @property (nonatomic, readonly) NSError* lastError;\n        \n        // 初始化\n        + (id) sharedGameKitHelper;\n        \n        // Player authentication, info\n        -(void) authenticateLocalPlayer;\n        @end\n\n\n\nGameKitHelper.mm\n\n        #import \"GameKitHelper.h\"\n        \n        @interface GameKitHelper ()\n                <GKGameCenterControllerDelegate> {\n            BOOL _gameCenterFeaturesEnabled;\n        }\n        @end\n        \n        @implementation GameKitHelper\n        \n        #pragma mark Singleton stuff\n        \n        +(id) sharedGameKitHelper {\n            static GameKitHelper *sharedGameKitHelper;\n            static dispatch_once_t onceToken;\n            dispatch_once(&onceToken, ^{\n                sharedGameKitHelper =\n                        [[GameKitHelper alloc] init];\n            });\n            return sharedGameKitHelper;\n        }\n        \n        #pragma mark Player Authentication\n        \n        -(void) authenticateLocalPlayer {\n            GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n        \n            localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n                [self setLastError:error];\n                if (localPlayer.authenticated) {\n                    _gameCenterFeaturesEnabled = YES;\n                } else if(viewController) {\n                    [self presentViewController:viewController];\n                } else {\n                    _gameCenterFeaturesEnabled = NO;\n                }\n            };\n        }\n        \n        #pragma mark Property setters\n        \n        -(void) setLastError:(NSError*)error {\n            _lastError = [error copy];\n            if (_lastError) {\n                NSLog(@\"GameCenter -- setLastError -- ERROR: %@\", [[_lastError userInfo] \n                  description]);\n            }\n        }\n        \n        #pragma mark UIViewController stuff\n        \n        -(UIViewController*) getRootViewController {\n            return [UIApplication \n              sharedApplication].keyWindow.rootViewController;\n        }\n        \n        -(void)presentViewController:(UIViewController*)vc {\n            UIViewController* rootVC = [self getRootViewController];\n            [rootVC presentViewController:vc animated:YES \n              completion:nil];\n        }\n        \n        @end\n\n\n\n<br/>\n\n##### 1.6 登录GameCenter时机\n由你决定，可以放在 AppDelegate 中 applicationDidFinishLaunching时。\n\n<br/>\n<br/>\n<br/>\n\n### 2. 关于排行榜\n<br/>\n\n#### 2.1 配置 iTunes Connect\n\n在iTunes Connect 找到 排行榜。\n\n简单说一下流程吧：\n配置排行榜的结构，然后我们在游戏中将数据上传到这个结构，最后显示到GameCenter中。\n\n排行榜分为 单个排行榜 与 组合排行榜。(顾名思义，区别就不需要解释了吧？)\n里面需要配置的相应属性，可参考本文末尾的关于。\n\n要注意两点：\n1. 排行榜ID，因为只有它是在创建后无法更改的。（而且，要记住这个ID，因为后面程序要用到）\n2. 排行榜只要发布了（经过审批发布），就无法删除了。\n\n接下来就看属性去配置它吧。\n\n<br/>\n<br/>\n\n#### 2.2 XCode工程配置\n\n模拟这个流程：登录GameCenter -> 提交排行榜数据 ( -> 如果需要，弹出GameCenter排行榜)\n\n\n提交排行榜数据:\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category {       // 这里两个参数 score是数据， category是ID，就是我们创建排行榜以后，不可更改的那个ID。\n            // 检查是否在登录状态\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitScore -- Player not authenticated\");\n                return;\n            }\n        \n            // 创建一个分数对象\n            GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n        \n            // 设置分数对象的值\n            gkScore.value = score;\n        \n            // 向GameCenter提交数据\n            [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n                [self setLastError:error];\n            }];\n        }\n\n\n\n<br/>\n<br/>\n\n#### 2.3 实践使用\n\n在公用部分，已经添加了GameCenter的登录验证相关的东西了。\n\n* 将排行榜数据提交的函数\n\nGameKitHelper.h\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category;\n\n\nGameKitHelper.mm\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category {\n        \n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitScore -- Player not authenticated\");\n                return;\n            }\n        \n            GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n        \n            gkScore.value = score;\n        \n            [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n                [self setLastError:error];\n            }];\n        }\n\n\n* 给lua调用的函数\n\nGameKitHelper.h\n\n\n        +(void) getScore:(NSDictionary *)dict;\n\n\nGameKitHelper.mm\n\n\n        +(void) getScore:(NSDictionary *)dict {\n            NSString* rID = [dict objectForKey:@\"id\"];\n            int score = [[dict objectForKey:@\"score\"] intValue];\n            \n            [[GameKitHelper sharedGameKitHelper] submitScore:(int64_t)score category:rID];\n        }\n\n\n\n* lua调用\n\n\n        LuaObjcBridge.callStaticMethod(\"GameKitHelper\", \"getScore\", {id = 排行榜的ID, score = 分数值})\n\n\n\n<br/>\n<br/>\n<br/>\n\n### 3. 关于成就\n\n<br/>\n\n#### 3.1 配置 iTunes Connect\n\n还是老位置，之前看的排行榜，这次点成就。\n还是老样子，成就的ID，创建后不可修改，成就发布后不可删除。\n但是，成就还要多一点，就是每个游戏总共有2000点成就分（为什么是2000？你问老乔去。。），你可以给每个成就分配一些成就分。\n成就还有是否隐藏的选项，但是它的隐藏并不是看不到这个成就了，而是有一个成就名称为隐藏的成就显示在列表中。\n还有，它的进度是一个顺时针扇形来表示，就是你的图标刚开始是被遮掩的，随着进度的增加，会逐渐显现出图标，方向是顺时针扇形。\n\n其他相关参数，可参考本文末尾的关于。\n\n\n<br/>\n<br/>\n\n#### 3.2 XCode工程配置\n\n流程与排行榜的一样，但是这次提交的不是分数了，而是成就完成的百分比。\n\n\n        // 提交成就数据\n        -(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {          // identifier 成就ID, percentComplete: 成就完成百分比\n            // 判断登录认证\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitAchievment -- Player not authenticated\");\n                return;\n            }\n        \n            // 创建成就结构，注入成就ID\n            GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n            \n            // 设置成就百分比\n            [achievement setPercentComplete:percentComplete];  \n            \n            // 提交成就数据\n            [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n                if(error != nil){  \n                    NSLog(@\"GameCenter -- submitAchievment --  error:%@\", [error localizedDescription]);  \n                }else{  \n                    NSLog(@\"GameCenter -- submitAchievment --  提交成就成功\");  \n                }  \n            }];  \n        } \n\n\n\n<br/>\n<br/>\n\n#### 3.3 实践使用\n\n同排行榜一样。\n\n\n* 将成就数据提交的函数\n\nGameKitHelper.h\n\n\n        - (void)submitAchievment:(NSString *)identifier percent:(double)percentComplete;\n\n\nGameKitHelper.mm\n\n\n        -(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitAchievment -- Player not authenticated\");\n                return;\n            }\n        \n            GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n              \n            [achievement setPercentComplete:percentComplete];  \n              \n            [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n                if(error != nil){  \n                    NSLog(@\"GameCenter -- submitAchievment --  error:%@\", [error localizedDescription]);  \n                }else{  \n                    NSLog(@\"GameCenter -- submitAchievment --  提交成就成功\");  \n                }  \n            }];  \n        } \n\n\n* 给lua调用的函数\n\nGameKitHelper.h\n\n\n        +(void) getAchievement:(NSDictionary *)dict;\n\n\nGameKitHelper.mm\n\n\n        +(void) getAchievement:(NSDictionary *)dict {\n            NSString* aID = [dict objectForKey:@\"id\"];\n            double percent = [[dict objectForKey:@\"percent\"] doubleValue];\n            \n            [[GameKitHelper sharedGameKitHelper] submitAchievment:(NSString *)aID percent:percent];\n        }\n\n\n\n* lua调用\n\n        \n        LuaObjcBridge.callStaticMethod(\"GameKitHelper\", \"getAchievement\", {id = 成就ID, percent = 成就百分比})\n\n\n\n<br/>\n<br/>\n<br/>\n\n### 4. 最后\nGameCenter还是挺好的一个东西。\n它还有一个好友挑战功能，但这个主要适合之前 Flappy Bird，别踩白块 那些游戏来弄。\n或许，这也是这个平台没落了的原因吧。\n\n\n<br/>\n<br/>\n<br/>\n\n### 关于\n\n- [关于 LuaObjcBridge](http://www.cocos2d-x.org/reference/native-cpp/V3.5/d6/d59/classcocos2d_1_1_lua_objc_bridge.html)\n- [关于 iTunes Connect](https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/About.html#//apple_ref/doc/uid/TP40016325-CH1-SW1)\n- [中文版 排行榜及成就 配置属性](https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnectGameCenter_Guide_SCh/Chapters/Leaderboards.html#//apple_ref/doc/uid/TP40014490-CH2-SW1)\n\n\n<br/>\n<br/>\n<br/>\n\n### 参考\n\n- https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6\n- http://www.jianshu.com/p/4279f84d8340\n- http://blog.csdn.net/shenjie12345678/article/details/45025403/\n","source":"_posts/cocos2d-x 接入 GameCenter 排行榜与成就.md","raw":"---\ntitle: cocos2d-x 接入 GameCenter 排行榜与成就\ndate: 2017-04-29 12:13:11\ntags: [cocos2d-x]\n---\n\ncocos2d-x 接入 GameCenter 排行榜与成就\n[mac - XCode 8.3 - cocos2d-x lua]\n\n\n<!-- more -->\n### 前言\n\n要求接入GameCenter的排行榜和成就。\n\nGameCenter 是苹果推出的一个社交平台，\n它主要提供了以下几个功能：\n- 排行榜\n- 成就\n- 挑战\n而且，苹果同时提供了GameKit框架来让GameCenter更易集成。\n\n\n可能是因为GameCenter的热度过去了吧，相关的东西都比较早期。\n整理总结了一下，希望对他人有所帮助。\n\n我的环境：\n\nmac - XCode 8.3 - cocos2d-x lua\n\n<br/>\n<br/>\n<br/>\n\n### 1. 公共的处理\n<br/>\n\n##### 1.1 配置 iTunes Connect 排行榜与成就的位置。\n登录iTunes Connect, 找到要处理的APP。\n选择 功能->GameCenter\n可以看到三个大项：\n- 移动群组\n- 排行榜\n- 成就\n\n<br/>\n\n##### 1.2 添加GameKit框架\n打开项目工程，将 Capabilities 的 GameCenter 打开。\n这样，XCode就会将GameKit框架加到我们的工程中。\n\n<br/>\n\n##### 1.3 登录GameCenter\n登录GameCenter:  【这个步骤在我们加载完游戏时进行即可】\n\n\n        -(void) authenticateLocalPlayer {\n            // 获取本地用户\n            GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n        \n            // 认证登录\n            localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n                [self setLastError:error];\n        \n                if (localPlayer.authenticated) {                        // 本地用户已经登录\n                    _gameCenterFeaturesEnabled = YES;                   // 此变量是判断是否已经登录上GameCenter\n                } else if(viewController) {                             // 没有用户，弹出登录界面\n                    [self presentViewController:viewController];        \n                } else {                                                // 没有用户，并且没有登录界面\n                    _gameCenterFeaturesEnabled = NO;\n                }\n            };\n        }\n\n\n<br/>\n\n##### 1.4 关于lua调用object-c\n因为我的环境是 cocos2d-x lua，所以，用通过lua来调用object-c。\ncocos2d-x其实已经有相关的调用结构 —— LuaObjcBridge, 可以直接用 callStaticMethod来调用：\n\n\n        LuaObjcBridge.callStaticMethod(methodName className,args)\n\n\n<br/>\n\n##### 1.5 GameKit辅助处理类\nGameKitHelper.h:\n\n\n\n        #import <GameKit/GameKit.h>\n        #import \"cocos2d.h\"\n        \n        // 方便lua调用\n        #include \"CCLuaEngine.h\"\n        #include \"CCLuaBridge.h\"\n        \n        @interface GameKitHelper : NSObject\n        // 处理错误\n        @property (nonatomic, readonly) NSError* lastError;\n        \n        // 初始化\n        + (id) sharedGameKitHelper;\n        \n        // Player authentication, info\n        -(void) authenticateLocalPlayer;\n        @end\n\n\n\nGameKitHelper.mm\n\n        #import \"GameKitHelper.h\"\n        \n        @interface GameKitHelper ()\n                <GKGameCenterControllerDelegate> {\n            BOOL _gameCenterFeaturesEnabled;\n        }\n        @end\n        \n        @implementation GameKitHelper\n        \n        #pragma mark Singleton stuff\n        \n        +(id) sharedGameKitHelper {\n            static GameKitHelper *sharedGameKitHelper;\n            static dispatch_once_t onceToken;\n            dispatch_once(&onceToken, ^{\n                sharedGameKitHelper =\n                        [[GameKitHelper alloc] init];\n            });\n            return sharedGameKitHelper;\n        }\n        \n        #pragma mark Player Authentication\n        \n        -(void) authenticateLocalPlayer {\n            GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n        \n            localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n                [self setLastError:error];\n                if (localPlayer.authenticated) {\n                    _gameCenterFeaturesEnabled = YES;\n                } else if(viewController) {\n                    [self presentViewController:viewController];\n                } else {\n                    _gameCenterFeaturesEnabled = NO;\n                }\n            };\n        }\n        \n        #pragma mark Property setters\n        \n        -(void) setLastError:(NSError*)error {\n            _lastError = [error copy];\n            if (_lastError) {\n                NSLog(@\"GameCenter -- setLastError -- ERROR: %@\", [[_lastError userInfo] \n                  description]);\n            }\n        }\n        \n        #pragma mark UIViewController stuff\n        \n        -(UIViewController*) getRootViewController {\n            return [UIApplication \n              sharedApplication].keyWindow.rootViewController;\n        }\n        \n        -(void)presentViewController:(UIViewController*)vc {\n            UIViewController* rootVC = [self getRootViewController];\n            [rootVC presentViewController:vc animated:YES \n              completion:nil];\n        }\n        \n        @end\n\n\n\n<br/>\n\n##### 1.6 登录GameCenter时机\n由你决定，可以放在 AppDelegate 中 applicationDidFinishLaunching时。\n\n<br/>\n<br/>\n<br/>\n\n### 2. 关于排行榜\n<br/>\n\n#### 2.1 配置 iTunes Connect\n\n在iTunes Connect 找到 排行榜。\n\n简单说一下流程吧：\n配置排行榜的结构，然后我们在游戏中将数据上传到这个结构，最后显示到GameCenter中。\n\n排行榜分为 单个排行榜 与 组合排行榜。(顾名思义，区别就不需要解释了吧？)\n里面需要配置的相应属性，可参考本文末尾的关于。\n\n要注意两点：\n1. 排行榜ID，因为只有它是在创建后无法更改的。（而且，要记住这个ID，因为后面程序要用到）\n2. 排行榜只要发布了（经过审批发布），就无法删除了。\n\n接下来就看属性去配置它吧。\n\n<br/>\n<br/>\n\n#### 2.2 XCode工程配置\n\n模拟这个流程：登录GameCenter -> 提交排行榜数据 ( -> 如果需要，弹出GameCenter排行榜)\n\n\n提交排行榜数据:\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category {       // 这里两个参数 score是数据， category是ID，就是我们创建排行榜以后，不可更改的那个ID。\n            // 检查是否在登录状态\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitScore -- Player not authenticated\");\n                return;\n            }\n        \n            // 创建一个分数对象\n            GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n        \n            // 设置分数对象的值\n            gkScore.value = score;\n        \n            // 向GameCenter提交数据\n            [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n                [self setLastError:error];\n            }];\n        }\n\n\n\n<br/>\n<br/>\n\n#### 2.3 实践使用\n\n在公用部分，已经添加了GameCenter的登录验证相关的东西了。\n\n* 将排行榜数据提交的函数\n\nGameKitHelper.h\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category;\n\n\nGameKitHelper.mm\n\n\n        -(void) submitScore:(int64_t)score category:(NSString*)category {\n        \n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitScore -- Player not authenticated\");\n                return;\n            }\n        \n            GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n        \n            gkScore.value = score;\n        \n            [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n                [self setLastError:error];\n            }];\n        }\n\n\n* 给lua调用的函数\n\nGameKitHelper.h\n\n\n        +(void) getScore:(NSDictionary *)dict;\n\n\nGameKitHelper.mm\n\n\n        +(void) getScore:(NSDictionary *)dict {\n            NSString* rID = [dict objectForKey:@\"id\"];\n            int score = [[dict objectForKey:@\"score\"] intValue];\n            \n            [[GameKitHelper sharedGameKitHelper] submitScore:(int64_t)score category:rID];\n        }\n\n\n\n* lua调用\n\n\n        LuaObjcBridge.callStaticMethod(\"GameKitHelper\", \"getScore\", {id = 排行榜的ID, score = 分数值})\n\n\n\n<br/>\n<br/>\n<br/>\n\n### 3. 关于成就\n\n<br/>\n\n#### 3.1 配置 iTunes Connect\n\n还是老位置，之前看的排行榜，这次点成就。\n还是老样子，成就的ID，创建后不可修改，成就发布后不可删除。\n但是，成就还要多一点，就是每个游戏总共有2000点成就分（为什么是2000？你问老乔去。。），你可以给每个成就分配一些成就分。\n成就还有是否隐藏的选项，但是它的隐藏并不是看不到这个成就了，而是有一个成就名称为隐藏的成就显示在列表中。\n还有，它的进度是一个顺时针扇形来表示，就是你的图标刚开始是被遮掩的，随着进度的增加，会逐渐显现出图标，方向是顺时针扇形。\n\n其他相关参数，可参考本文末尾的关于。\n\n\n<br/>\n<br/>\n\n#### 3.2 XCode工程配置\n\n流程与排行榜的一样，但是这次提交的不是分数了，而是成就完成的百分比。\n\n\n        // 提交成就数据\n        -(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {          // identifier 成就ID, percentComplete: 成就完成百分比\n            // 判断登录认证\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitAchievment -- Player not authenticated\");\n                return;\n            }\n        \n            // 创建成就结构，注入成就ID\n            GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n            \n            // 设置成就百分比\n            [achievement setPercentComplete:percentComplete];  \n            \n            // 提交成就数据\n            [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n                if(error != nil){  \n                    NSLog(@\"GameCenter -- submitAchievment --  error:%@\", [error localizedDescription]);  \n                }else{  \n                    NSLog(@\"GameCenter -- submitAchievment --  提交成就成功\");  \n                }  \n            }];  \n        } \n\n\n\n<br/>\n<br/>\n\n#### 3.3 实践使用\n\n同排行榜一样。\n\n\n* 将成就数据提交的函数\n\nGameKitHelper.h\n\n\n        - (void)submitAchievment:(NSString *)identifier percent:(double)percentComplete;\n\n\nGameKitHelper.mm\n\n\n        -(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {\n            if (!_gameCenterFeaturesEnabled)    {\n                NSLog(@\"GameCenter -- submitAchievment -- Player not authenticated\");\n                return;\n            }\n        \n            GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n              \n            [achievement setPercentComplete:percentComplete];  \n              \n            [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n                if(error != nil){  \n                    NSLog(@\"GameCenter -- submitAchievment --  error:%@\", [error localizedDescription]);  \n                }else{  \n                    NSLog(@\"GameCenter -- submitAchievment --  提交成就成功\");  \n                }  \n            }];  \n        } \n\n\n* 给lua调用的函数\n\nGameKitHelper.h\n\n\n        +(void) getAchievement:(NSDictionary *)dict;\n\n\nGameKitHelper.mm\n\n\n        +(void) getAchievement:(NSDictionary *)dict {\n            NSString* aID = [dict objectForKey:@\"id\"];\n            double percent = [[dict objectForKey:@\"percent\"] doubleValue];\n            \n            [[GameKitHelper sharedGameKitHelper] submitAchievment:(NSString *)aID percent:percent];\n        }\n\n\n\n* lua调用\n\n        \n        LuaObjcBridge.callStaticMethod(\"GameKitHelper\", \"getAchievement\", {id = 成就ID, percent = 成就百分比})\n\n\n\n<br/>\n<br/>\n<br/>\n\n### 4. 最后\nGameCenter还是挺好的一个东西。\n它还有一个好友挑战功能，但这个主要适合之前 Flappy Bird，别踩白块 那些游戏来弄。\n或许，这也是这个平台没落了的原因吧。\n\n\n<br/>\n<br/>\n<br/>\n\n### 关于\n\n- [关于 LuaObjcBridge](http://www.cocos2d-x.org/reference/native-cpp/V3.5/d6/d59/classcocos2d_1_1_lua_objc_bridge.html)\n- [关于 iTunes Connect](https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/About.html#//apple_ref/doc/uid/TP40016325-CH1-SW1)\n- [中文版 排行榜及成就 配置属性](https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnectGameCenter_Guide_SCh/Chapters/Leaderboards.html#//apple_ref/doc/uid/TP40014490-CH2-SW1)\n\n\n<br/>\n<br/>\n<br/>\n\n### 参考\n\n- https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6\n- http://www.jianshu.com/p/4279f84d8340\n- http://blog.csdn.net/shenjie12345678/article/details/45025403/\n","slug":"cocos2d-x 接入 GameCenter 排行榜与成就","published":1,"updated":"2018-04-01T17:12:54.000Z","_id":"cjfbbabiu001zveue84smn040","comments":1,"layout":"post","photos":[],"link":"","content":"<p>cocos2d-x 接入 GameCenter 排行榜与成就<br>[mac - XCode 8.3 - cocos2d-x lua]</p>\n<a id=\"more\"></a>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>要求接入GameCenter的排行榜和成就。</p>\n<p>GameCenter 是苹果推出的一个社交平台，<br>它主要提供了以下几个功能：</p>\n<ul>\n<li>排行榜</li>\n<li>成就</li>\n<li>挑战<br>而且，苹果同时提供了GameKit框架来让GameCenter更易集成。</li>\n</ul>\n<p>可能是因为GameCenter的热度过去了吧，相关的东西都比较早期。<br>整理总结了一下，希望对他人有所帮助。</p>\n<p>我的环境：</p>\n<p>mac - XCode 8.3 - cocos2d-x lua</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"1-公共的处理\"><a href=\"#1-公共的处理\" class=\"headerlink\" title=\"1. 公共的处理\"></a>1. 公共的处理</h3><p><br></p>\n<h5 id=\"1-1-配置-iTunes-Connect-排行榜与成就的位置。\"><a href=\"#1-1-配置-iTunes-Connect-排行榜与成就的位置。\" class=\"headerlink\" title=\"1.1 配置 iTunes Connect 排行榜与成就的位置。\"></a>1.1 配置 iTunes Connect 排行榜与成就的位置。</h5><p>登录iTunes Connect, 找到要处理的APP。<br>选择 功能-&gt;GameCenter<br>可以看到三个大项：</p>\n<ul>\n<li>移动群组</li>\n<li>排行榜</li>\n<li>成就</li>\n</ul>\n<p><br></p>\n<h5 id=\"1-2-添加GameKit框架\"><a href=\"#1-2-添加GameKit框架\" class=\"headerlink\" title=\"1.2 添加GameKit框架\"></a>1.2 添加GameKit框架</h5><p>打开项目工程，将 Capabilities 的 GameCenter 打开。<br>这样，XCode就会将GameKit框架加到我们的工程中。</p>\n<p><br></p>\n<h5 id=\"1-3-登录GameCenter\"><a href=\"#1-3-登录GameCenter\" class=\"headerlink\" title=\"1.3 登录GameCenter\"></a>1.3 登录GameCenter</h5><p>登录GameCenter:  【这个步骤在我们加载完游戏时进行即可】</p>\n<pre><code>-(void) authenticateLocalPlayer {\n    // 获取本地用户\n    GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n\n    // 认证登录\n    localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n        [self setLastError:error];\n\n        if (localPlayer.authenticated) {                        // 本地用户已经登录\n            _gameCenterFeaturesEnabled = YES;                   // 此变量是判断是否已经登录上GameCenter\n        } else if(viewController) {                             // 没有用户，弹出登录界面\n            [self presentViewController:viewController];        \n        } else {                                                // 没有用户，并且没有登录界面\n            _gameCenterFeaturesEnabled = NO;\n        }\n    };\n}\n</code></pre><p><br></p>\n<h5 id=\"1-4-关于lua调用object-c\"><a href=\"#1-4-关于lua调用object-c\" class=\"headerlink\" title=\"1.4 关于lua调用object-c\"></a>1.4 关于lua调用object-c</h5><p>因为我的环境是 cocos2d-x lua，所以，用通过lua来调用object-c。<br>cocos2d-x其实已经有相关的调用结构 —— LuaObjcBridge, 可以直接用 callStaticMethod来调用：</p>\n<pre><code>LuaObjcBridge.callStaticMethod(methodName className,args)\n</code></pre><p><br></p>\n<h5 id=\"1-5-GameKit辅助处理类\"><a href=\"#1-5-GameKit辅助处理类\" class=\"headerlink\" title=\"1.5 GameKit辅助处理类\"></a>1.5 GameKit辅助处理类</h5><p>GameKitHelper.h:</p>\n<pre><code>#import &lt;GameKit/GameKit.h&gt;\n#import &quot;cocos2d.h&quot;\n\n// 方便lua调用\n#include &quot;CCLuaEngine.h&quot;\n#include &quot;CCLuaBridge.h&quot;\n\n@interface GameKitHelper : NSObject\n// 处理错误\n@property (nonatomic, readonly) NSError* lastError;\n\n// 初始化\n+ (id) sharedGameKitHelper;\n\n// Player authentication, info\n-(void) authenticateLocalPlayer;\n@end\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>#import &quot;GameKitHelper.h&quot;\n\n@interface GameKitHelper ()\n        &lt;GKGameCenterControllerDelegate&gt; {\n    BOOL _gameCenterFeaturesEnabled;\n}\n@end\n\n@implementation GameKitHelper\n\n#pragma mark Singleton stuff\n\n+(id) sharedGameKitHelper {\n    static GameKitHelper *sharedGameKitHelper;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        sharedGameKitHelper =\n                [[GameKitHelper alloc] init];\n    });\n    return sharedGameKitHelper;\n}\n\n#pragma mark Player Authentication\n\n-(void) authenticateLocalPlayer {\n    GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n\n    localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n        [self setLastError:error];\n        if (localPlayer.authenticated) {\n            _gameCenterFeaturesEnabled = YES;\n        } else if(viewController) {\n            [self presentViewController:viewController];\n        } else {\n            _gameCenterFeaturesEnabled = NO;\n        }\n    };\n}\n\n#pragma mark Property setters\n\n-(void) setLastError:(NSError*)error {\n    _lastError = [error copy];\n    if (_lastError) {\n        NSLog(@&quot;GameCenter -- setLastError -- ERROR: %@&quot;, [[_lastError userInfo] \n          description]);\n    }\n}\n\n#pragma mark UIViewController stuff\n\n-(UIViewController*) getRootViewController {\n    return [UIApplication \n      sharedApplication].keyWindow.rootViewController;\n}\n\n-(void)presentViewController:(UIViewController*)vc {\n    UIViewController* rootVC = [self getRootViewController];\n    [rootVC presentViewController:vc animated:YES \n      completion:nil];\n}\n\n@end\n</code></pre><p><br></p>\n<h5 id=\"1-6-登录GameCenter时机\"><a href=\"#1-6-登录GameCenter时机\" class=\"headerlink\" title=\"1.6 登录GameCenter时机\"></a>1.6 登录GameCenter时机</h5><p>由你决定，可以放在 AppDelegate 中 applicationDidFinishLaunching时。</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"2-关于排行榜\"><a href=\"#2-关于排行榜\" class=\"headerlink\" title=\"2. 关于排行榜\"></a>2. 关于排行榜</h3><p><br></p>\n<h4 id=\"2-1-配置-iTunes-Connect\"><a href=\"#2-1-配置-iTunes-Connect\" class=\"headerlink\" title=\"2.1 配置 iTunes Connect\"></a>2.1 配置 iTunes Connect</h4><p>在iTunes Connect 找到 排行榜。</p>\n<p>简单说一下流程吧：<br>配置排行榜的结构，然后我们在游戏中将数据上传到这个结构，最后显示到GameCenter中。</p>\n<p>排行榜分为 单个排行榜 与 组合排行榜。(顾名思义，区别就不需要解释了吧？)<br>里面需要配置的相应属性，可参考本文末尾的关于。</p>\n<p>要注意两点：</p>\n<ol>\n<li>排行榜ID，因为只有它是在创建后无法更改的。（而且，要记住这个ID，因为后面程序要用到）</li>\n<li>排行榜只要发布了（经过审批发布），就无法删除了。</li>\n</ol>\n<p>接下来就看属性去配置它吧。</p>\n<p><br><br><br></p>\n<h4 id=\"2-2-XCode工程配置\"><a href=\"#2-2-XCode工程配置\" class=\"headerlink\" title=\"2.2 XCode工程配置\"></a>2.2 XCode工程配置</h4><p>模拟这个流程：登录GameCenter -&gt; 提交排行榜数据 ( -&gt; 如果需要，弹出GameCenter排行榜)</p>\n<p>提交排行榜数据:</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category {       // 这里两个参数 score是数据， category是ID，就是我们创建排行榜以后，不可更改的那个ID。\n    // 检查是否在登录状态\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitScore -- Player not authenticated&quot;);\n        return;\n    }\n\n    // 创建一个分数对象\n    GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n\n    // 设置分数对象的值\n    gkScore.value = score;\n\n    // 向GameCenter提交数据\n    [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n        [self setLastError:error];\n    }];\n}\n</code></pre><p><br><br><br></p>\n<h4 id=\"2-3-实践使用\"><a href=\"#2-3-实践使用\" class=\"headerlink\" title=\"2.3 实践使用\"></a>2.3 实践使用</h4><p>在公用部分，已经添加了GameCenter的登录验证相关的东西了。</p>\n<ul>\n<li>将排行榜数据提交的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category {\n\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitScore -- Player not authenticated&quot;);\n        return;\n    }\n\n    GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n\n    gkScore.value = score;\n\n    [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n        [self setLastError:error];\n    }];\n}\n</code></pre><ul>\n<li>给lua调用的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>+(void) getScore:(NSDictionary *)dict;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>+(void) getScore:(NSDictionary *)dict {\n    NSString* rID = [dict objectForKey:@&quot;id&quot;];\n    int score = [[dict objectForKey:@&quot;score&quot;] intValue];\n\n    [[GameKitHelper sharedGameKitHelper] submitScore:(int64_t)score category:rID];\n}\n</code></pre><ul>\n<li>lua调用</li>\n</ul>\n<pre><code>LuaObjcBridge.callStaticMethod(&quot;GameKitHelper&quot;, &quot;getScore&quot;, {id = 排行榜的ID, score = 分数值})\n</code></pre><p><br><br><br><br><br></p>\n<h3 id=\"3-关于成就\"><a href=\"#3-关于成就\" class=\"headerlink\" title=\"3. 关于成就\"></a>3. 关于成就</h3><p><br></p>\n<h4 id=\"3-1-配置-iTunes-Connect\"><a href=\"#3-1-配置-iTunes-Connect\" class=\"headerlink\" title=\"3.1 配置 iTunes Connect\"></a>3.1 配置 iTunes Connect</h4><p>还是老位置，之前看的排行榜，这次点成就。<br>还是老样子，成就的ID，创建后不可修改，成就发布后不可删除。<br>但是，成就还要多一点，就是每个游戏总共有2000点成就分（为什么是2000？你问老乔去。。），你可以给每个成就分配一些成就分。<br>成就还有是否隐藏的选项，但是它的隐藏并不是看不到这个成就了，而是有一个成就名称为隐藏的成就显示在列表中。<br>还有，它的进度是一个顺时针扇形来表示，就是你的图标刚开始是被遮掩的，随着进度的增加，会逐渐显现出图标，方向是顺时针扇形。</p>\n<p>其他相关参数，可参考本文末尾的关于。</p>\n<p><br><br><br></p>\n<h4 id=\"3-2-XCode工程配置\"><a href=\"#3-2-XCode工程配置\" class=\"headerlink\" title=\"3.2 XCode工程配置\"></a>3.2 XCode工程配置</h4><p>流程与排行榜的一样，但是这次提交的不是分数了，而是成就完成的百分比。</p>\n<pre><code>// 提交成就数据\n-(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {          // identifier 成就ID, percentComplete: 成就完成百分比\n    // 判断登录认证\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitAchievment -- Player not authenticated&quot;);\n        return;\n    }\n\n    // 创建成就结构，注入成就ID\n    GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n\n    // 设置成就百分比\n    [achievement setPercentComplete:percentComplete];  \n\n    // 提交成就数据\n    [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n        if(error != nil){  \n            NSLog(@&quot;GameCenter -- submitAchievment --  error:%@&quot;, [error localizedDescription]);  \n        }else{  \n            NSLog(@&quot;GameCenter -- submitAchievment --  提交成就成功&quot;);  \n        }  \n    }];  \n} \n</code></pre><p><br><br><br></p>\n<h4 id=\"3-3-实践使用\"><a href=\"#3-3-实践使用\" class=\"headerlink\" title=\"3.3 实践使用\"></a>3.3 实践使用</h4><p>同排行榜一样。</p>\n<ul>\n<li>将成就数据提交的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>- (void)submitAchievment:(NSString *)identifier percent:(double)percentComplete;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>-(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitAchievment -- Player not authenticated&quot;);\n        return;\n    }\n\n    GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n\n    [achievement setPercentComplete:percentComplete];  \n\n    [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n        if(error != nil){  \n            NSLog(@&quot;GameCenter -- submitAchievment --  error:%@&quot;, [error localizedDescription]);  \n        }else{  \n            NSLog(@&quot;GameCenter -- submitAchievment --  提交成就成功&quot;);  \n        }  \n    }];  \n} \n</code></pre><ul>\n<li>给lua调用的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>+(void) getAchievement:(NSDictionary *)dict;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>+(void) getAchievement:(NSDictionary *)dict {\n    NSString* aID = [dict objectForKey:@&quot;id&quot;];\n    double percent = [[dict objectForKey:@&quot;percent&quot;] doubleValue];\n\n    [[GameKitHelper sharedGameKitHelper] submitAchievment:(NSString *)aID percent:percent];\n}\n</code></pre><ul>\n<li>lua调用</li>\n</ul>\n<pre><code>LuaObjcBridge.callStaticMethod(&quot;GameKitHelper&quot;, &quot;getAchievement&quot;, {id = 成就ID, percent = 成就百分比})\n</code></pre><p><br><br><br><br><br></p>\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4. 最后\"></a>4. 最后</h3><p>GameCenter还是挺好的一个东西。<br>它还有一个好友挑战功能，但这个主要适合之前 Flappy Bird，别踩白块 那些游戏来弄。<br>或许，这也是这个平台没落了的原因吧。</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h3><ul>\n<li><a href=\"http://www.cocos2d-x.org/reference/native-cpp/V3.5/d6/d59/classcocos2d_1_1_lua_objc_bridge.html\" target=\"_blank\" rel=\"noopener\">关于 LuaObjcBridge</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/About.html#//apple_ref/doc/uid/TP40016325-CH1-SW1\" target=\"_blank\" rel=\"noopener\">关于 iTunes Connect</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnectGameCenter_Guide_SCh/Chapters/Leaderboards.html#//apple_ref/doc/uid/TP40014490-CH2-SW1\" target=\"_blank\" rel=\"noopener\">中文版 排行榜及成就 配置属性</a></li>\n</ul>\n<p><br><br><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6\" target=\"_blank\" rel=\"noopener\">https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6</a></li>\n<li><a href=\"http://www.jianshu.com/p/4279f84d8340\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/4279f84d8340</a></li>\n<li><a href=\"http://blog.csdn.net/shenjie12345678/article/details/45025403/\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/shenjie12345678/article/details/45025403/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>cocos2d-x 接入 GameCenter 排行榜与成就<br>[mac - XCode 8.3 - cocos2d-x lua]</p>","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>要求接入GameCenter的排行榜和成就。</p>\n<p>GameCenter 是苹果推出的一个社交平台，<br>它主要提供了以下几个功能：</p>\n<ul>\n<li>排行榜</li>\n<li>成就</li>\n<li>挑战<br>而且，苹果同时提供了GameKit框架来让GameCenter更易集成。</li>\n</ul>\n<p>可能是因为GameCenter的热度过去了吧，相关的东西都比较早期。<br>整理总结了一下，希望对他人有所帮助。</p>\n<p>我的环境：</p>\n<p>mac - XCode 8.3 - cocos2d-x lua</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"1-公共的处理\"><a href=\"#1-公共的处理\" class=\"headerlink\" title=\"1. 公共的处理\"></a>1. 公共的处理</h3><p><br></p>\n<h5 id=\"1-1-配置-iTunes-Connect-排行榜与成就的位置。\"><a href=\"#1-1-配置-iTunes-Connect-排行榜与成就的位置。\" class=\"headerlink\" title=\"1.1 配置 iTunes Connect 排行榜与成就的位置。\"></a>1.1 配置 iTunes Connect 排行榜与成就的位置。</h5><p>登录iTunes Connect, 找到要处理的APP。<br>选择 功能-&gt;GameCenter<br>可以看到三个大项：</p>\n<ul>\n<li>移动群组</li>\n<li>排行榜</li>\n<li>成就</li>\n</ul>\n<p><br></p>\n<h5 id=\"1-2-添加GameKit框架\"><a href=\"#1-2-添加GameKit框架\" class=\"headerlink\" title=\"1.2 添加GameKit框架\"></a>1.2 添加GameKit框架</h5><p>打开项目工程，将 Capabilities 的 GameCenter 打开。<br>这样，XCode就会将GameKit框架加到我们的工程中。</p>\n<p><br></p>\n<h5 id=\"1-3-登录GameCenter\"><a href=\"#1-3-登录GameCenter\" class=\"headerlink\" title=\"1.3 登录GameCenter\"></a>1.3 登录GameCenter</h5><p>登录GameCenter:  【这个步骤在我们加载完游戏时进行即可】</p>\n<pre><code>-(void) authenticateLocalPlayer {\n    // 获取本地用户\n    GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n\n    // 认证登录\n    localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n        [self setLastError:error];\n\n        if (localPlayer.authenticated) {                        // 本地用户已经登录\n            _gameCenterFeaturesEnabled = YES;                   // 此变量是判断是否已经登录上GameCenter\n        } else if(viewController) {                             // 没有用户，弹出登录界面\n            [self presentViewController:viewController];        \n        } else {                                                // 没有用户，并且没有登录界面\n            _gameCenterFeaturesEnabled = NO;\n        }\n    };\n}\n</code></pre><p><br></p>\n<h5 id=\"1-4-关于lua调用object-c\"><a href=\"#1-4-关于lua调用object-c\" class=\"headerlink\" title=\"1.4 关于lua调用object-c\"></a>1.4 关于lua调用object-c</h5><p>因为我的环境是 cocos2d-x lua，所以，用通过lua来调用object-c。<br>cocos2d-x其实已经有相关的调用结构 —— LuaObjcBridge, 可以直接用 callStaticMethod来调用：</p>\n<pre><code>LuaObjcBridge.callStaticMethod(methodName className,args)\n</code></pre><p><br></p>\n<h5 id=\"1-5-GameKit辅助处理类\"><a href=\"#1-5-GameKit辅助处理类\" class=\"headerlink\" title=\"1.5 GameKit辅助处理类\"></a>1.5 GameKit辅助处理类</h5><p>GameKitHelper.h:</p>\n<pre><code>#import &lt;GameKit/GameKit.h&gt;\n#import &quot;cocos2d.h&quot;\n\n// 方便lua调用\n#include &quot;CCLuaEngine.h&quot;\n#include &quot;CCLuaBridge.h&quot;\n\n@interface GameKitHelper : NSObject\n// 处理错误\n@property (nonatomic, readonly) NSError* lastError;\n\n// 初始化\n+ (id) sharedGameKitHelper;\n\n// Player authentication, info\n-(void) authenticateLocalPlayer;\n@end\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>#import &quot;GameKitHelper.h&quot;\n\n@interface GameKitHelper ()\n        &lt;GKGameCenterControllerDelegate&gt; {\n    BOOL _gameCenterFeaturesEnabled;\n}\n@end\n\n@implementation GameKitHelper\n\n#pragma mark Singleton stuff\n\n+(id) sharedGameKitHelper {\n    static GameKitHelper *sharedGameKitHelper;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        sharedGameKitHelper =\n                [[GameKitHelper alloc] init];\n    });\n    return sharedGameKitHelper;\n}\n\n#pragma mark Player Authentication\n\n-(void) authenticateLocalPlayer {\n    GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer];\n\n    localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) {\n        [self setLastError:error];\n        if (localPlayer.authenticated) {\n            _gameCenterFeaturesEnabled = YES;\n        } else if(viewController) {\n            [self presentViewController:viewController];\n        } else {\n            _gameCenterFeaturesEnabled = NO;\n        }\n    };\n}\n\n#pragma mark Property setters\n\n-(void) setLastError:(NSError*)error {\n    _lastError = [error copy];\n    if (_lastError) {\n        NSLog(@&quot;GameCenter -- setLastError -- ERROR: %@&quot;, [[_lastError userInfo] \n          description]);\n    }\n}\n\n#pragma mark UIViewController stuff\n\n-(UIViewController*) getRootViewController {\n    return [UIApplication \n      sharedApplication].keyWindow.rootViewController;\n}\n\n-(void)presentViewController:(UIViewController*)vc {\n    UIViewController* rootVC = [self getRootViewController];\n    [rootVC presentViewController:vc animated:YES \n      completion:nil];\n}\n\n@end\n</code></pre><p><br></p>\n<h5 id=\"1-6-登录GameCenter时机\"><a href=\"#1-6-登录GameCenter时机\" class=\"headerlink\" title=\"1.6 登录GameCenter时机\"></a>1.6 登录GameCenter时机</h5><p>由你决定，可以放在 AppDelegate 中 applicationDidFinishLaunching时。</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"2-关于排行榜\"><a href=\"#2-关于排行榜\" class=\"headerlink\" title=\"2. 关于排行榜\"></a>2. 关于排行榜</h3><p><br></p>\n<h4 id=\"2-1-配置-iTunes-Connect\"><a href=\"#2-1-配置-iTunes-Connect\" class=\"headerlink\" title=\"2.1 配置 iTunes Connect\"></a>2.1 配置 iTunes Connect</h4><p>在iTunes Connect 找到 排行榜。</p>\n<p>简单说一下流程吧：<br>配置排行榜的结构，然后我们在游戏中将数据上传到这个结构，最后显示到GameCenter中。</p>\n<p>排行榜分为 单个排行榜 与 组合排行榜。(顾名思义，区别就不需要解释了吧？)<br>里面需要配置的相应属性，可参考本文末尾的关于。</p>\n<p>要注意两点：</p>\n<ol>\n<li>排行榜ID，因为只有它是在创建后无法更改的。（而且，要记住这个ID，因为后面程序要用到）</li>\n<li>排行榜只要发布了（经过审批发布），就无法删除了。</li>\n</ol>\n<p>接下来就看属性去配置它吧。</p>\n<p><br><br><br></p>\n<h4 id=\"2-2-XCode工程配置\"><a href=\"#2-2-XCode工程配置\" class=\"headerlink\" title=\"2.2 XCode工程配置\"></a>2.2 XCode工程配置</h4><p>模拟这个流程：登录GameCenter -&gt; 提交排行榜数据 ( -&gt; 如果需要，弹出GameCenter排行榜)</p>\n<p>提交排行榜数据:</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category {       // 这里两个参数 score是数据， category是ID，就是我们创建排行榜以后，不可更改的那个ID。\n    // 检查是否在登录状态\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitScore -- Player not authenticated&quot;);\n        return;\n    }\n\n    // 创建一个分数对象\n    GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n\n    // 设置分数对象的值\n    gkScore.value = score;\n\n    // 向GameCenter提交数据\n    [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n        [self setLastError:error];\n    }];\n}\n</code></pre><p><br><br><br></p>\n<h4 id=\"2-3-实践使用\"><a href=\"#2-3-实践使用\" class=\"headerlink\" title=\"2.3 实践使用\"></a>2.3 实践使用</h4><p>在公用部分，已经添加了GameCenter的登录验证相关的东西了。</p>\n<ul>\n<li>将排行榜数据提交的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>-(void) submitScore:(int64_t)score category:(NSString*)category {\n\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitScore -- Player not authenticated&quot;);\n        return;\n    }\n\n    GKScore* gkScore = [[GKScore alloc] initWithCategory:category];\n\n    gkScore.value = score;\n\n    [gkScore reportScoreWithCompletionHandler: ^(NSError* error)    {\n        [self setLastError:error];\n    }];\n}\n</code></pre><ul>\n<li>给lua调用的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>+(void) getScore:(NSDictionary *)dict;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>+(void) getScore:(NSDictionary *)dict {\n    NSString* rID = [dict objectForKey:@&quot;id&quot;];\n    int score = [[dict objectForKey:@&quot;score&quot;] intValue];\n\n    [[GameKitHelper sharedGameKitHelper] submitScore:(int64_t)score category:rID];\n}\n</code></pre><ul>\n<li>lua调用</li>\n</ul>\n<pre><code>LuaObjcBridge.callStaticMethod(&quot;GameKitHelper&quot;, &quot;getScore&quot;, {id = 排行榜的ID, score = 分数值})\n</code></pre><p><br><br><br><br><br></p>\n<h3 id=\"3-关于成就\"><a href=\"#3-关于成就\" class=\"headerlink\" title=\"3. 关于成就\"></a>3. 关于成就</h3><p><br></p>\n<h4 id=\"3-1-配置-iTunes-Connect\"><a href=\"#3-1-配置-iTunes-Connect\" class=\"headerlink\" title=\"3.1 配置 iTunes Connect\"></a>3.1 配置 iTunes Connect</h4><p>还是老位置，之前看的排行榜，这次点成就。<br>还是老样子，成就的ID，创建后不可修改，成就发布后不可删除。<br>但是，成就还要多一点，就是每个游戏总共有2000点成就分（为什么是2000？你问老乔去。。），你可以给每个成就分配一些成就分。<br>成就还有是否隐藏的选项，但是它的隐藏并不是看不到这个成就了，而是有一个成就名称为隐藏的成就显示在列表中。<br>还有，它的进度是一个顺时针扇形来表示，就是你的图标刚开始是被遮掩的，随着进度的增加，会逐渐显现出图标，方向是顺时针扇形。</p>\n<p>其他相关参数，可参考本文末尾的关于。</p>\n<p><br><br><br></p>\n<h4 id=\"3-2-XCode工程配置\"><a href=\"#3-2-XCode工程配置\" class=\"headerlink\" title=\"3.2 XCode工程配置\"></a>3.2 XCode工程配置</h4><p>流程与排行榜的一样，但是这次提交的不是分数了，而是成就完成的百分比。</p>\n<pre><code>// 提交成就数据\n-(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {          // identifier 成就ID, percentComplete: 成就完成百分比\n    // 判断登录认证\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitAchievment -- Player not authenticated&quot;);\n        return;\n    }\n\n    // 创建成就结构，注入成就ID\n    GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n\n    // 设置成就百分比\n    [achievement setPercentComplete:percentComplete];  \n\n    // 提交成就数据\n    [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n        if(error != nil){  \n            NSLog(@&quot;GameCenter -- submitAchievment --  error:%@&quot;, [error localizedDescription]);  \n        }else{  \n            NSLog(@&quot;GameCenter -- submitAchievment --  提交成就成功&quot;);  \n        }  \n    }];  \n} \n</code></pre><p><br><br><br></p>\n<h4 id=\"3-3-实践使用\"><a href=\"#3-3-实践使用\" class=\"headerlink\" title=\"3.3 实践使用\"></a>3.3 实践使用</h4><p>同排行榜一样。</p>\n<ul>\n<li>将成就数据提交的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>- (void)submitAchievment:(NSString *)identifier percent:(double)percentComplete;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>-(void) submitAchievment:(NSString *)identifier percent:(double) percentComplete {\n    if (!_gameCenterFeaturesEnabled)    {\n        NSLog(@&quot;GameCenter -- submitAchievment -- Player not authenticated&quot;);\n        return;\n    }\n\n    GKAchievement *achievement = [[GKAchievement alloc] initWithIdentifier:identifier];  \n\n    [achievement setPercentComplete:percentComplete];  \n\n    [achievement reportAchievementWithCompletionHandler:^(NSError *error) {  \n        if(error != nil){  \n            NSLog(@&quot;GameCenter -- submitAchievment --  error:%@&quot;, [error localizedDescription]);  \n        }else{  \n            NSLog(@&quot;GameCenter -- submitAchievment --  提交成就成功&quot;);  \n        }  \n    }];  \n} \n</code></pre><ul>\n<li>给lua调用的函数</li>\n</ul>\n<p>GameKitHelper.h</p>\n<pre><code>+(void) getAchievement:(NSDictionary *)dict;\n</code></pre><p>GameKitHelper.mm</p>\n<pre><code>+(void) getAchievement:(NSDictionary *)dict {\n    NSString* aID = [dict objectForKey:@&quot;id&quot;];\n    double percent = [[dict objectForKey:@&quot;percent&quot;] doubleValue];\n\n    [[GameKitHelper sharedGameKitHelper] submitAchievment:(NSString *)aID percent:percent];\n}\n</code></pre><ul>\n<li>lua调用</li>\n</ul>\n<pre><code>LuaObjcBridge.callStaticMethod(&quot;GameKitHelper&quot;, &quot;getAchievement&quot;, {id = 成就ID, percent = 成就百分比})\n</code></pre><p><br><br><br><br><br></p>\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4. 最后\"></a>4. 最后</h3><p>GameCenter还是挺好的一个东西。<br>它还有一个好友挑战功能，但这个主要适合之前 Flappy Bird，别踩白块 那些游戏来弄。<br>或许，这也是这个平台没落了的原因吧。</p>\n<p><br><br><br><br><br></p>\n<h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h3><ul>\n<li><a href=\"http://www.cocos2d-x.org/reference/native-cpp/V3.5/d6/d59/classcocos2d_1_1_lua_objc_bridge.html\" target=\"_blank\" rel=\"noopener\">关于 LuaObjcBridge</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/About.html#//apple_ref/doc/uid/TP40016325-CH1-SW1\" target=\"_blank\" rel=\"noopener\">关于 iTunes Connect</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnectGameCenter_Guide_SCh/Chapters/Leaderboards.html#//apple_ref/doc/uid/TP40014490-CH2-SW1\" target=\"_blank\" rel=\"noopener\">中文版 排行榜及成就 配置属性</a></li>\n</ul>\n<p><br><br><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6\" target=\"_blank\" rel=\"noopener\">https://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6</a></li>\n<li><a href=\"http://www.jianshu.com/p/4279f84d8340\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/4279f84d8340</a></li>\n<li><a href=\"http://blog.csdn.net/shenjie12345678/article/details/45025403/\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/shenjie12345678/article/details/45025403/</a></li>\n</ul>"},{"title":"python学习笔记","date":"2016-11-22T13:00:00.000Z","_content":"\n----------\n\npython脚本学习\n\n\n<!-- more -->\n<br/>\n<br/>\n\n动机：\n脚本可以省很多事情，\n开发游戏用了lua，\n但是，\n真正日常要做一些东西脚本的时候，\n发现用lua还是比较麻烦些，\n所以，\n就瞄上了python，\n恩，\n说学就学。\n\n注意：\n- 用的是python3\n- 适合有一定脚本语言基础的人看（很多脚本语言的共性没有记录）\n\n<br/>\n<br/>\n----------\n\nRound 1: 基础\n<br/>\n\n- 输出语句 print\n** 注意多个参数的格式 **\n\n\n\t\tprint('hello python!')\n\t\tx = 100\n\t\ty = 'hello'\n\t\tprint('%s user, your score is %d' % (y, x))\n\t\tprint(r'')\t\t\t\t\t\t\t# 在''内的字符不转义\n\n\n- list、tuple、dict、set\n1. list\t列表，有序的集合，随时添加删除元素\nL = []\n常用方法:\t\t\n访问元素 - L[index] - index支持负数\n末尾加入元素 - L.append(val)\n某位置插入元素 - L.insert(index, val)\n删除末尾元素 - L.pop()\n删除某位置元素 - del L[index]\n\n2. tuple 元组，初始化后不可修改 **[ 初始化一个元素的元组时，元素后要加, : t = (1, ) ]**\nT = ()\n**list 与 tuple 可相互嵌套，tuple中的list可以增删，因为存的是地址**\n\t\t\n3. dict 字典（你也可以叫它map)\nD = {'key': value, }\n\n4. set 集合，无序不重复\nS = set([])\n\n\n- 条件 与 循环\npython的语法很简单，通过缩进来显示。\n最重要的是**:**\n\n\n\t\tif <条件>:\n\t\t\tcontinue\n\t\telif <条件>:\n\t\t\tbreak\n\t\telse:\n\t\t\tpass\n\n\t\tfor < > in <对象集合>:\n\t\t\tpass\n\t\t\n\t\twhile <条件>:\n\t\t\tpass\n\n\n- 函数\n\t\t\n\n\t\t# 定义\n\t\tdef function_name(parameters):\n\t\t\tpass\t\t\t\t\t\t\t\t# 一旦定义一个函数，不可以什么都不写，但可以像这样\n\t\t\t\t\t\t\t\t\t\t\t\t# 用pass来占位，先让代码运行起来。\n\n\n当然，默认参数值，返回多个值，都是支持的\n额外要注意的应该是 **参数** 部分，包括：必选参数、默认参数、可变参数、命名关键字参数、关键字参数。\n可变参数允许传入0个或任意个参数，这些会被自动组装为一个tuple；\n关键字参数允许传入0个或任意个含参数名的参数，这些被自动组装为1个dict。\n\n\t\t\n\t\tdef book(name, author, **kw):\n\t\t\tif 'language' in kw: \t\t\t\t\t\t# 判断关键字参数中是否有 language 字段\n\t\t\t\tpass\n\n\t\t\tprint('name: ', name, 'author: ', author, 'other: ', kw)\n\n\t\t# methon1\n\t\tbook('From Grass To Tree', 'ltree98', language = 'CHN')\n\t\tbook('How To Study Python', 'ltree98', language = 'ENG', pages = 100)\n\n\t\t# method2\n\t\textra = {'language': 'KOR', 'class': 'novel'}\n\t\tbook('lalala', 'tree', **extra)\n\n\nPS：如果参数中已经有了一个可变参数，那么后面的命名关键字参数就不需要特殊分隔符'\\*'了。\n**参数顺序： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数。**\n\n\t\t\n\t\tdef f(a, b = 0, *args, **kw):\t\t# 必选参数、默认参数、可变参数、关键字参数\n\t\t\tpass\n\t\tdef f2(a, b = 0, *, d, **kw):\t\t# 必选参数、默认参数、可变参数、命名关键字参数、关键字参数\n\t\t\tpass\n\n\n**对于任意函数，都可以通过func(\\*args, \\*\\*kw)的形式来调用它，无论参数是如何定义的。**\n\n\n- others:\n\t- range([start = 0,] stop, [, step = 1]]), 生成从start开始（默认为0）到stop（不等于stop）,步长为step（默认为1）的整数序列；\n\tstart 与 step都是可选参数。\n\n\n<br/>\n<br/>\n<br/>\n----------\n\nRound 2: 进阶\n<br/>\n<br/>\n\n1.  一些特性（切片、迭代、列表生成式、生成器）\n\n- 切片\n针对截取操作\nL[start: stop: step]  \n截取从start序号开始到stop序号，步长为step的值成一个list返回。\n\n\n\t\t>>> L = list(range(10))\n\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\t\t>>> L1 = L[:5]\n\t\t[0, 1, 2, 3, 4]\n\n\t\t>>> L2 = L[2:7]\n\t\t[2, 3, 4, 5, 6]\n\n\t\t>>> L3 = L[:-1:2]\n\t\t[0, 2, 4, 6, 8]\n\n\t\t>>> L4 = L[:]\n\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\t\t\n\n- 迭代\n给定一个list或tuple，通过for循环来遍历它，这种遍历叫做 迭代（iteration）\n很多语言的迭代是通过下标来进行的，但python里，并不是。\n当然，顺序可能就不是你当初定义它时的顺序了。\n\t\t\n\n\t\tweekday = {'Mon': 1, 'Tue': 2, 'Wed': 3}\n\t\t\n\t\tif isinstance(weekday, Iterable):\n\t\t\tfor w in weekday:\n\t\t\t\tprint(w)\n\n\nisinstance(..., Iterable) 判断一个数据类型是否可迭代\n一般可以可迭代对象是 集合数据类型（如 list、tuple、dict、set、str等），他们都是Iterable类型。\n\n\n- 列表生成式\n顾名思义，就是一个创建list的方式，\n通过这种方式创建list比较便捷\n\n\n\t\t[x + y for x in 'ABC' for y in 'XYZ' if x != 'B']\n\t\t\n\t\t# 其实上面那个等价于下面\n\n\t\tL = []\n\t\tfor x in 'ABC':\n\t\t\tfor y in 'XYZ':\n\t\t\t\tif x != 'B':\n\t\t\t\t\tL.append(x+y)\n\n\n- 生成器\n针对于列表容量有限的缺陷，\n生成器就是一边循环一边计算。\n与列表生成式的区别是，列表生成时最外层是 []，而生成器最外层是 ()\n而且，得到的generator，需要不停next得到下一个元素。（一般会通过for循环来迭代获取）\n\t\t\n\n\t\tg = (x + y for x in 'ABC' for y in 'XYZ' if x != 'B')\n\t\tfor v in g:\n\t\t\tprint(v)\n\n\n可以作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。\nIterator类型主要就两种，一种就是这个生成器，还有就是含yield的generator function\n\n\n<br/>\n\n2.  关于函数式编程 （ lambda、map、reduce、filter、 装饰器）\n\n\n- lambda [arg1 [, arg2, arg3, ...]]: expression\n也叫匿名函数，通过它可以非常方便快捷的定义使用一个函数。\n具体效果，下面会给出。\n\n\n- map(func, seq1[, seq2...])\n将func作用于seq中的每一个元素，并用一个列表给出返回值。\n\n\t\n\t\tdef f(x):\n\t\t\treturn x * x\n\t\tm = map(f, [1, 2, 3, 4, 5])\n\t\t# m 将会是一个列表 [1, 4, 9, 16, 25]\n\n其实，用lambda更方便简洁\n\n\n\t\tm = map(lambda x: x*x, range(1, 6))\n\n\n- reduce(func, seq[, init])\n这是一个二元操作函数，它用来将一个集合中所有数据进行从前到后的二元操作。\n\n\n\t\tfrom fuctools import reduce\n\t\tdef specialAdd(x, y):\n\t\t\treturn x*10 + y\n\t\tval = reduce(specialAdd, [1, 2, 3, 4, 5])\n\t\t# val将会是一个数字 12345\n\n\nreduce要提前导入，\n当然，也可以用lambda\n\n\n\t\tval = reduce(lambda x, y: x*10 + y, range(1, 6))\n\n\n- filter(func, seq)\n可以当做过滤器，将集合中的每个数都传入函数，根据函数返回的bool变量来决定是否留下。\n\n\t\n\t\tdef bigger_than_five(n):\n\t\t\treturn n > 5\n\t\tf = list(filter(bigger_than_five, [3, 4, 5, 6, 7, 8]))\n\t\t# f 将会是一个列表 [6, 7, 8]\n\n\t\tf2 = list(filter(lambda n: n > 5, range(3, 9)))\n\n\n- 装饰器\n装饰器的作用就像它名字一样，给函数以装饰，做一个更大一范围的修饰。\n比如，有A、B、C三个果汁工厂，现在要在每瓶果汁上印一个小商标。\n我们可以在每个工厂内建立一个流水线来印商标，\n也可以专门建立一个工厂D来印商标。\n装饰器，就像后者，工厂D。\n\n\n\t\tdef myLog(func):\n\t\t\tdef wrapper(*args, **kw):\n\t\t\t\tprint('--- this is my log')\n\t\t\t\treturn func(*args, **kw)\n\t\t\treturn wrapper\n\t\t\n\t\t@myLog\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\n注意要加语法糖 @装饰器函数\n本装饰器的作用是在函数调用前输出一段log。\n\n如果想让装饰器函数带参数，那就要进行三层嵌套。\n\n\t\t\n\t\tdef myLog(logText):\n\t\t\tdef decorator(func):\n\t\t\t\tdef wrapper(*args, **kw):\n\t\t\t\t\tprint(logText)\n\t\t\t\t\treturn func(*args, **kw)\n\t\t\t\treturn wrapper\n\t\t\treturn decorator\n\n\t\t@myLog(\"hello log\")\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\n但是，这里的函数名已经发生了更改，demo名称其实已经发生了更改，\ndemo.\\_\\_name\\_\\_ 是 wrapper\n可以通过加\nwrapper.\\_\\_name\\_\\_ = func.\\_\\_name\\_\\_\n来改回来，\n但是，过于繁琐，python提供了更好的方法\n\n\n\t\timport functools\n\t\t\n\t\tdef myLog(logText):\n\t\t\tdef decorator(func):\n\t\t\t\t@functools.wraps(func)\n\t\t\t\tdef wrapper(*args, **kw):\n\t\t\t\t\tprint(logText)\n\t\t\t\t\treturn func(*args, **kw)\n\t\t\t\treturn wrapper\n\t\t\treturn decorator\n\t\t\n\t\t@myLog(\"hello log\")\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\t\tprint(demo.__name__)\n\n\n<br/>\n\n3.  关于面向对象编程\n\npython中是有类这个结构的。\n还有一些命名规则：\n变量名以 \\_  开头，代表私有变量（非强制）\n变量名以 \\_\\_ 开头，代表私有变量 （强制）\n变量名以 \\_\\_ 开头，并且以 \\_\\_ 结尾，代表特殊变量\n\n\n\t\tclass Person(object):\n\t\t\tdef __init__(self, name, age):\n\t\t\t\tself.__name = name\n\t\t\t\tself.age = age\n\t\t\tdef eat(self):\n\t\t\t\tprint('Person Eating...')\n\n\n\t\tclass Student(Person):\n\t\t\tdef eat(self):\n\t\t\t\tprint('Student Eating...')\n\t\t\tdef study(self):\n\t\t\t\tprint('Student Study...')\n\n\n也可以对实例进行一些属性的绑定，当然，不会对类造成影响。\n当然也可以对类进行方法绑定，其所有的实例均受影响\n\t\t\n\t\tdef set_height(self, height):\n\t\t\tself.height = height\n\t\tclass Person(object):\n\t\t\tname = 'tree'\n\t\t\n\t\tp = Person()\n\t\tprint('p name is: ', p.name)\n\t\tprint('person name is: ', Person.name)\n\t\t\n\t\tp.age = 20\n\t\tprint('p age is: ', p.age)\n\t\tprint('person age is: ', Person.age\n\t\t\n\t\tPerson.set_height = set_height\n\t\tp.set_height(180)\n\t\tprint(p.height)\n\n\n最后，可以通过在类内设置一些函数来使类更加完善:\n- \\_\\_init\\_\\_ \t\t\t\t\n初始化方法\n- \\_\\_slots\\_\\_ \t\t\t\t\n设定允许绑定的变量名（子类会继承父类）\n- \\_\\_len\\_\\_\n让类可以作用于len函数，设定计算类大小的方法\n- \\_\\_str\\_\\_ 与 \\_\\_repr\\_\\_\n都是用来当 print实例对象时 显示出来的字符串。\n\\_\\_str\\_\\_是给用户看的，\\_\\_repr\\_\\_是给开发者看的（但一般都一样）\n- \\_\\_iter\\_\\_ 与 \\_\\_next\\_\\_\n可以让类作用于 for...in 循环\n- \\_\\_getitem\\_\\_\n可以像list一样实现按照下标取元素\n- \\_\\_getattr\\_\\_\n预设某属性默认值\n- \\_\\_call\\_\\_\n实现在实例本身的调用方法。\n- 装饰器实现get/set方法\t\t\n\n\t\t\n\t\tclass Person(object):\n\t\t\t@property\n\t\t\tdef age(self):\n\t\t\t    return self._age\n\t\t\t@age.setter\n\t\t\tdef age(self, value):\n\t\t\t    self._age = value\n\n\n<br/>\n<br/>\n<br/>\n----------\n\nFinal : 归纳\n<br/>\n\npython的一些基础东西，基本就这些了。\n接下来，就可以去做一些东西来边练手边加深理解。\n最后， \n工具是死的，\n人是活得，\n不要局限自己，\n放飞思维，\n大胆去做。\n\n\n<br/>\n<br/>\n<br/>\n<br/>\n\n\n\n\n参考：\n着重推荐： http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 \nhttp://www.pythoner.com/46.html","source":"_posts/python学习笔记.md","raw":"---\ntitle: python学习笔记\ndate: 2016-11-22 21:00:00\ntags: 学习笔记\n---\n\n----------\n\npython脚本学习\n\n\n<!-- more -->\n<br/>\n<br/>\n\n动机：\n脚本可以省很多事情，\n开发游戏用了lua，\n但是，\n真正日常要做一些东西脚本的时候，\n发现用lua还是比较麻烦些，\n所以，\n就瞄上了python，\n恩，\n说学就学。\n\n注意：\n- 用的是python3\n- 适合有一定脚本语言基础的人看（很多脚本语言的共性没有记录）\n\n<br/>\n<br/>\n----------\n\nRound 1: 基础\n<br/>\n\n- 输出语句 print\n** 注意多个参数的格式 **\n\n\n\t\tprint('hello python!')\n\t\tx = 100\n\t\ty = 'hello'\n\t\tprint('%s user, your score is %d' % (y, x))\n\t\tprint(r'')\t\t\t\t\t\t\t# 在''内的字符不转义\n\n\n- list、tuple、dict、set\n1. list\t列表，有序的集合，随时添加删除元素\nL = []\n常用方法:\t\t\n访问元素 - L[index] - index支持负数\n末尾加入元素 - L.append(val)\n某位置插入元素 - L.insert(index, val)\n删除末尾元素 - L.pop()\n删除某位置元素 - del L[index]\n\n2. tuple 元组，初始化后不可修改 **[ 初始化一个元素的元组时，元素后要加, : t = (1, ) ]**\nT = ()\n**list 与 tuple 可相互嵌套，tuple中的list可以增删，因为存的是地址**\n\t\t\n3. dict 字典（你也可以叫它map)\nD = {'key': value, }\n\n4. set 集合，无序不重复\nS = set([])\n\n\n- 条件 与 循环\npython的语法很简单，通过缩进来显示。\n最重要的是**:**\n\n\n\t\tif <条件>:\n\t\t\tcontinue\n\t\telif <条件>:\n\t\t\tbreak\n\t\telse:\n\t\t\tpass\n\n\t\tfor < > in <对象集合>:\n\t\t\tpass\n\t\t\n\t\twhile <条件>:\n\t\t\tpass\n\n\n- 函数\n\t\t\n\n\t\t# 定义\n\t\tdef function_name(parameters):\n\t\t\tpass\t\t\t\t\t\t\t\t# 一旦定义一个函数，不可以什么都不写，但可以像这样\n\t\t\t\t\t\t\t\t\t\t\t\t# 用pass来占位，先让代码运行起来。\n\n\n当然，默认参数值，返回多个值，都是支持的\n额外要注意的应该是 **参数** 部分，包括：必选参数、默认参数、可变参数、命名关键字参数、关键字参数。\n可变参数允许传入0个或任意个参数，这些会被自动组装为一个tuple；\n关键字参数允许传入0个或任意个含参数名的参数，这些被自动组装为1个dict。\n\n\t\t\n\t\tdef book(name, author, **kw):\n\t\t\tif 'language' in kw: \t\t\t\t\t\t# 判断关键字参数中是否有 language 字段\n\t\t\t\tpass\n\n\t\t\tprint('name: ', name, 'author: ', author, 'other: ', kw)\n\n\t\t# methon1\n\t\tbook('From Grass To Tree', 'ltree98', language = 'CHN')\n\t\tbook('How To Study Python', 'ltree98', language = 'ENG', pages = 100)\n\n\t\t# method2\n\t\textra = {'language': 'KOR', 'class': 'novel'}\n\t\tbook('lalala', 'tree', **extra)\n\n\nPS：如果参数中已经有了一个可变参数，那么后面的命名关键字参数就不需要特殊分隔符'\\*'了。\n**参数顺序： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数。**\n\n\t\t\n\t\tdef f(a, b = 0, *args, **kw):\t\t# 必选参数、默认参数、可变参数、关键字参数\n\t\t\tpass\n\t\tdef f2(a, b = 0, *, d, **kw):\t\t# 必选参数、默认参数、可变参数、命名关键字参数、关键字参数\n\t\t\tpass\n\n\n**对于任意函数，都可以通过func(\\*args, \\*\\*kw)的形式来调用它，无论参数是如何定义的。**\n\n\n- others:\n\t- range([start = 0,] stop, [, step = 1]]), 生成从start开始（默认为0）到stop（不等于stop）,步长为step（默认为1）的整数序列；\n\tstart 与 step都是可选参数。\n\n\n<br/>\n<br/>\n<br/>\n----------\n\nRound 2: 进阶\n<br/>\n<br/>\n\n1.  一些特性（切片、迭代、列表生成式、生成器）\n\n- 切片\n针对截取操作\nL[start: stop: step]  \n截取从start序号开始到stop序号，步长为step的值成一个list返回。\n\n\n\t\t>>> L = list(range(10))\n\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\t\t>>> L1 = L[:5]\n\t\t[0, 1, 2, 3, 4]\n\n\t\t>>> L2 = L[2:7]\n\t\t[2, 3, 4, 5, 6]\n\n\t\t>>> L3 = L[:-1:2]\n\t\t[0, 2, 4, 6, 8]\n\n\t\t>>> L4 = L[:]\n\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\t\t\n\n- 迭代\n给定一个list或tuple，通过for循环来遍历它，这种遍历叫做 迭代（iteration）\n很多语言的迭代是通过下标来进行的，但python里，并不是。\n当然，顺序可能就不是你当初定义它时的顺序了。\n\t\t\n\n\t\tweekday = {'Mon': 1, 'Tue': 2, 'Wed': 3}\n\t\t\n\t\tif isinstance(weekday, Iterable):\n\t\t\tfor w in weekday:\n\t\t\t\tprint(w)\n\n\nisinstance(..., Iterable) 判断一个数据类型是否可迭代\n一般可以可迭代对象是 集合数据类型（如 list、tuple、dict、set、str等），他们都是Iterable类型。\n\n\n- 列表生成式\n顾名思义，就是一个创建list的方式，\n通过这种方式创建list比较便捷\n\n\n\t\t[x + y for x in 'ABC' for y in 'XYZ' if x != 'B']\n\t\t\n\t\t# 其实上面那个等价于下面\n\n\t\tL = []\n\t\tfor x in 'ABC':\n\t\t\tfor y in 'XYZ':\n\t\t\t\tif x != 'B':\n\t\t\t\t\tL.append(x+y)\n\n\n- 生成器\n针对于列表容量有限的缺陷，\n生成器就是一边循环一边计算。\n与列表生成式的区别是，列表生成时最外层是 []，而生成器最外层是 ()\n而且，得到的generator，需要不停next得到下一个元素。（一般会通过for循环来迭代获取）\n\t\t\n\n\t\tg = (x + y for x in 'ABC' for y in 'XYZ' if x != 'B')\n\t\tfor v in g:\n\t\t\tprint(v)\n\n\n可以作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。\nIterator类型主要就两种，一种就是这个生成器，还有就是含yield的generator function\n\n\n<br/>\n\n2.  关于函数式编程 （ lambda、map、reduce、filter、 装饰器）\n\n\n- lambda [arg1 [, arg2, arg3, ...]]: expression\n也叫匿名函数，通过它可以非常方便快捷的定义使用一个函数。\n具体效果，下面会给出。\n\n\n- map(func, seq1[, seq2...])\n将func作用于seq中的每一个元素，并用一个列表给出返回值。\n\n\t\n\t\tdef f(x):\n\t\t\treturn x * x\n\t\tm = map(f, [1, 2, 3, 4, 5])\n\t\t# m 将会是一个列表 [1, 4, 9, 16, 25]\n\n其实，用lambda更方便简洁\n\n\n\t\tm = map(lambda x: x*x, range(1, 6))\n\n\n- reduce(func, seq[, init])\n这是一个二元操作函数，它用来将一个集合中所有数据进行从前到后的二元操作。\n\n\n\t\tfrom fuctools import reduce\n\t\tdef specialAdd(x, y):\n\t\t\treturn x*10 + y\n\t\tval = reduce(specialAdd, [1, 2, 3, 4, 5])\n\t\t# val将会是一个数字 12345\n\n\nreduce要提前导入，\n当然，也可以用lambda\n\n\n\t\tval = reduce(lambda x, y: x*10 + y, range(1, 6))\n\n\n- filter(func, seq)\n可以当做过滤器，将集合中的每个数都传入函数，根据函数返回的bool变量来决定是否留下。\n\n\t\n\t\tdef bigger_than_five(n):\n\t\t\treturn n > 5\n\t\tf = list(filter(bigger_than_five, [3, 4, 5, 6, 7, 8]))\n\t\t# f 将会是一个列表 [6, 7, 8]\n\n\t\tf2 = list(filter(lambda n: n > 5, range(3, 9)))\n\n\n- 装饰器\n装饰器的作用就像它名字一样，给函数以装饰，做一个更大一范围的修饰。\n比如，有A、B、C三个果汁工厂，现在要在每瓶果汁上印一个小商标。\n我们可以在每个工厂内建立一个流水线来印商标，\n也可以专门建立一个工厂D来印商标。\n装饰器，就像后者，工厂D。\n\n\n\t\tdef myLog(func):\n\t\t\tdef wrapper(*args, **kw):\n\t\t\t\tprint('--- this is my log')\n\t\t\t\treturn func(*args, **kw)\n\t\t\treturn wrapper\n\t\t\n\t\t@myLog\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\n注意要加语法糖 @装饰器函数\n本装饰器的作用是在函数调用前输出一段log。\n\n如果想让装饰器函数带参数，那就要进行三层嵌套。\n\n\t\t\n\t\tdef myLog(logText):\n\t\t\tdef decorator(func):\n\t\t\t\tdef wrapper(*args, **kw):\n\t\t\t\t\tprint(logText)\n\t\t\t\t\treturn func(*args, **kw)\n\t\t\t\treturn wrapper\n\t\t\treturn decorator\n\n\t\t@myLog(\"hello log\")\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\n但是，这里的函数名已经发生了更改，demo名称其实已经发生了更改，\ndemo.\\_\\_name\\_\\_ 是 wrapper\n可以通过加\nwrapper.\\_\\_name\\_\\_ = func.\\_\\_name\\_\\_\n来改回来，\n但是，过于繁琐，python提供了更好的方法\n\n\n\t\timport functools\n\t\t\n\t\tdef myLog(logText):\n\t\t\tdef decorator(func):\n\t\t\t\t@functools.wraps(func)\n\t\t\t\tdef wrapper(*args, **kw):\n\t\t\t\t\tprint(logText)\n\t\t\t\t\treturn func(*args, **kw)\n\t\t\t\treturn wrapper\n\t\t\treturn decorator\n\t\t\n\t\t@myLog(\"hello log\")\n\t\tdef demo():\n\t\t\tprint('\\n\\ndemo is running\\n\\n')\n\t\t\n\t\tdemo()\n\t\tprint(demo.__name__)\n\n\n<br/>\n\n3.  关于面向对象编程\n\npython中是有类这个结构的。\n还有一些命名规则：\n变量名以 \\_  开头，代表私有变量（非强制）\n变量名以 \\_\\_ 开头，代表私有变量 （强制）\n变量名以 \\_\\_ 开头，并且以 \\_\\_ 结尾，代表特殊变量\n\n\n\t\tclass Person(object):\n\t\t\tdef __init__(self, name, age):\n\t\t\t\tself.__name = name\n\t\t\t\tself.age = age\n\t\t\tdef eat(self):\n\t\t\t\tprint('Person Eating...')\n\n\n\t\tclass Student(Person):\n\t\t\tdef eat(self):\n\t\t\t\tprint('Student Eating...')\n\t\t\tdef study(self):\n\t\t\t\tprint('Student Study...')\n\n\n也可以对实例进行一些属性的绑定，当然，不会对类造成影响。\n当然也可以对类进行方法绑定，其所有的实例均受影响\n\t\t\n\t\tdef set_height(self, height):\n\t\t\tself.height = height\n\t\tclass Person(object):\n\t\t\tname = 'tree'\n\t\t\n\t\tp = Person()\n\t\tprint('p name is: ', p.name)\n\t\tprint('person name is: ', Person.name)\n\t\t\n\t\tp.age = 20\n\t\tprint('p age is: ', p.age)\n\t\tprint('person age is: ', Person.age\n\t\t\n\t\tPerson.set_height = set_height\n\t\tp.set_height(180)\n\t\tprint(p.height)\n\n\n最后，可以通过在类内设置一些函数来使类更加完善:\n- \\_\\_init\\_\\_ \t\t\t\t\n初始化方法\n- \\_\\_slots\\_\\_ \t\t\t\t\n设定允许绑定的变量名（子类会继承父类）\n- \\_\\_len\\_\\_\n让类可以作用于len函数，设定计算类大小的方法\n- \\_\\_str\\_\\_ 与 \\_\\_repr\\_\\_\n都是用来当 print实例对象时 显示出来的字符串。\n\\_\\_str\\_\\_是给用户看的，\\_\\_repr\\_\\_是给开发者看的（但一般都一样）\n- \\_\\_iter\\_\\_ 与 \\_\\_next\\_\\_\n可以让类作用于 for...in 循环\n- \\_\\_getitem\\_\\_\n可以像list一样实现按照下标取元素\n- \\_\\_getattr\\_\\_\n预设某属性默认值\n- \\_\\_call\\_\\_\n实现在实例本身的调用方法。\n- 装饰器实现get/set方法\t\t\n\n\t\t\n\t\tclass Person(object):\n\t\t\t@property\n\t\t\tdef age(self):\n\t\t\t    return self._age\n\t\t\t@age.setter\n\t\t\tdef age(self, value):\n\t\t\t    self._age = value\n\n\n<br/>\n<br/>\n<br/>\n----------\n\nFinal : 归纳\n<br/>\n\npython的一些基础东西，基本就这些了。\n接下来，就可以去做一些东西来边练手边加深理解。\n最后， \n工具是死的，\n人是活得，\n不要局限自己，\n放飞思维，\n大胆去做。\n\n\n<br/>\n<br/>\n<br/>\n<br/>\n\n\n\n\n参考：\n着重推荐： http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 \nhttp://www.pythoner.com/46.html","slug":"python学习笔记","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabix0022veuehdjeod1x","content":"<hr>\n<p>python脚本学习</p>\n<a id=\"more\"></a>\n<p><br><br><br></p>\n<p>动机：<br>脚本可以省很多事情，<br>开发游戏用了lua，<br>但是，<br>真正日常要做一些东西脚本的时候，<br>发现用lua还是比较麻烦些，<br>所以，<br>就瞄上了python，<br>恩，<br>说学就学。</p>\n<p>注意：</p>\n<ul>\n<li>用的是python3</li>\n<li>适合有一定脚本语言基础的人看（很多脚本语言的共性没有记录）</li>\n</ul>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2><p>Round 1: 基础<br><br></p>\n<ul>\n<li>输出语句 print<br><strong> 注意多个参数的格式 </strong></li>\n</ul>\n<pre><code>print(&apos;hello python!&apos;)\nx = 100\ny = &apos;hello&apos;\nprint(&apos;%s user, your score is %d&apos; % (y, x))\nprint(r&apos;&apos;)                            # 在&apos;&apos;内的字符不转义\n</code></pre><ul>\n<li>list、tuple、dict、set</li>\n</ul>\n<ol>\n<li><p>list    列表，有序的集合，随时添加删除元素<br>L = []<br>常用方法:<br>访问元素 - L[index] - index支持负数<br>末尾加入元素 - L.append(val)<br>某位置插入元素 - L.insert(index, val)<br>删除末尾元素 - L.pop()<br>删除某位置元素 - del L[index]</p>\n</li>\n<li><p>tuple 元组，初始化后不可修改 <strong>[ 初始化一个元素的元组时，元素后要加, : t = (1, ) ]</strong><br>T = ()<br><strong>list 与 tuple 可相互嵌套，tuple中的list可以增删，因为存的是地址</strong></p>\n</li>\n<li><p>dict 字典（你也可以叫它map)<br>D = {‘key’: value, }</p>\n</li>\n<li><p>set 集合，无序不重复<br>S = set([])</p>\n</li>\n</ol>\n<ul>\n<li>条件 与 循环<br>python的语法很简单，通过缩进来显示。<br>最重要的是<strong>:</strong></li>\n</ul>\n<pre><code>if &lt;条件&gt;:\n    continue\nelif &lt;条件&gt;:\n    break\nelse:\n    pass\n\nfor &lt; &gt; in &lt;对象集合&gt;:\n    pass\n\nwhile &lt;条件&gt;:\n    pass\n</code></pre><ul>\n<li>函数</li>\n</ul>\n<pre><code># 定义\ndef function_name(parameters):\n    pass                                # 一旦定义一个函数，不可以什么都不写，但可以像这样\n                                        # 用pass来占位，先让代码运行起来。\n</code></pre><p>当然，默认参数值，返回多个值，都是支持的<br>额外要注意的应该是 <strong>参数</strong> 部分，包括：必选参数、默认参数、可变参数、命名关键字参数、关键字参数。<br>可变参数允许传入0个或任意个参数，这些会被自动组装为一个tuple；<br>关键字参数允许传入0个或任意个含参数名的参数，这些被自动组装为1个dict。</p>\n<pre><code>def book(name, author, **kw):\n    if &apos;language&apos; in kw:                         # 判断关键字参数中是否有 language 字段\n        pass\n\n    print(&apos;name: &apos;, name, &apos;author: &apos;, author, &apos;other: &apos;, kw)\n\n# methon1\nbook(&apos;From Grass To Tree&apos;, &apos;ltree98&apos;, language = &apos;CHN&apos;)\nbook(&apos;How To Study Python&apos;, &apos;ltree98&apos;, language = &apos;ENG&apos;, pages = 100)\n\n# method2\nextra = {&apos;language&apos;: &apos;KOR&apos;, &apos;class&apos;: &apos;novel&apos;}\nbook(&apos;lalala&apos;, &apos;tree&apos;, **extra)\n</code></pre><p>PS：如果参数中已经有了一个可变参数，那么后面的命名关键字参数就不需要特殊分隔符’*‘了。<br><strong>参数顺序： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数。</strong></p>\n<pre><code>def f(a, b = 0, *args, **kw):        # 必选参数、默认参数、可变参数、关键字参数\n    pass\ndef f2(a, b = 0, *, d, **kw):        # 必选参数、默认参数、可变参数、命名关键字参数、关键字参数\n    pass\n</code></pre><p><strong>对于任意函数，都可以通过func(*args, **kw)的形式来调用它，无论参数是如何定义的。</strong></p>\n<ul>\n<li>others:<ul>\n<li>range([start = 0,] stop, [, step = 1]]), 生成从start开始（默认为0）到stop（不等于stop）,步长为step（默认为1）的整数序列；<br>start 与 step都是可选参数。</li>\n</ul>\n</li>\n</ul>\n<p><br><br><br></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br></h2><p>Round 2: 进阶<br><br><br><br></p>\n<ol>\n<li>一些特性（切片、迭代、列表生成式、生成器）</li>\n</ol>\n<ul>\n<li>切片<br>针对截取操作<br>L[start: stop: step]<br>截取从start序号开始到stop序号，步长为step的值成一个list返回。</li>\n</ul>\n<pre><code>&gt;&gt;&gt; L = list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; L1 = L[:5]\n[0, 1, 2, 3, 4]\n\n&gt;&gt;&gt; L2 = L[2:7]\n[2, 3, 4, 5, 6]\n\n&gt;&gt;&gt; L3 = L[:-1:2]\n[0, 2, 4, 6, 8]\n\n&gt;&gt;&gt; L4 = L[:]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><ul>\n<li>迭代<br>给定一个list或tuple，通过for循环来遍历它，这种遍历叫做 迭代（iteration）<br>很多语言的迭代是通过下标来进行的，但python里，并不是。<br>当然，顺序可能就不是你当初定义它时的顺序了。</li>\n</ul>\n<pre><code>weekday = {&apos;Mon&apos;: 1, &apos;Tue&apos;: 2, &apos;Wed&apos;: 3}\n\nif isinstance(weekday, Iterable):\n    for w in weekday:\n        print(w)\n</code></pre><p>isinstance(…, Iterable) 判断一个数据类型是否可迭代<br>一般可以可迭代对象是 集合数据类型（如 list、tuple、dict、set、str等），他们都是Iterable类型。</p>\n<ul>\n<li>列表生成式<br>顾名思义，就是一个创建list的方式，<br>通过这种方式创建list比较便捷</li>\n</ul>\n<pre><code>[x + y for x in &apos;ABC&apos; for y in &apos;XYZ&apos; if x != &apos;B&apos;]\n\n# 其实上面那个等价于下面\n\nL = []\nfor x in &apos;ABC&apos;:\n    for y in &apos;XYZ&apos;:\n        if x != &apos;B&apos;:\n            L.append(x+y)\n</code></pre><ul>\n<li>生成器<br>针对于列表容量有限的缺陷，<br>生成器就是一边循环一边计算。<br>与列表生成式的区别是，列表生成时最外层是 []，而生成器最外层是 ()<br>而且，得到的generator，需要不停next得到下一个元素。（一般会通过for循环来迭代获取）</li>\n</ul>\n<pre><code>g = (x + y for x in &apos;ABC&apos; for y in &apos;XYZ&apos; if x != &apos;B&apos;)\nfor v in g:\n    print(v)\n</code></pre><p>可以作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。<br>Iterator类型主要就两种，一种就是这个生成器，还有就是含yield的generator function</p>\n<p><br></p>\n<ol start=\"2\">\n<li>关于函数式编程 （ lambda、map、reduce、filter、 装饰器）</li>\n</ol>\n<ul>\n<li>lambda [arg1 [, arg2, arg3, …]]: expression<br>也叫匿名函数，通过它可以非常方便快捷的定义使用一个函数。<br>具体效果，下面会给出。</li>\n</ul>\n<ul>\n<li>map(func, seq1[, seq2…])<br>将func作用于seq中的每一个元素，并用一个列表给出返回值。</li>\n</ul>\n<pre><code>def f(x):\n    return x * x\nm = map(f, [1, 2, 3, 4, 5])\n# m 将会是一个列表 [1, 4, 9, 16, 25]\n</code></pre><p>其实，用lambda更方便简洁</p>\n<pre><code>m = map(lambda x: x*x, range(1, 6))\n</code></pre><ul>\n<li>reduce(func, seq[, init])<br>这是一个二元操作函数，它用来将一个集合中所有数据进行从前到后的二元操作。</li>\n</ul>\n<pre><code>from fuctools import reduce\ndef specialAdd(x, y):\n    return x*10 + y\nval = reduce(specialAdd, [1, 2, 3, 4, 5])\n# val将会是一个数字 12345\n</code></pre><p>reduce要提前导入，<br>当然，也可以用lambda</p>\n<pre><code>val = reduce(lambda x, y: x*10 + y, range(1, 6))\n</code></pre><ul>\n<li>filter(func, seq)<br>可以当做过滤器，将集合中的每个数都传入函数，根据函数返回的bool变量来决定是否留下。</li>\n</ul>\n<pre><code>def bigger_than_five(n):\n    return n &gt; 5\nf = list(filter(bigger_than_five, [3, 4, 5, 6, 7, 8]))\n# f 将会是一个列表 [6, 7, 8]\n\nf2 = list(filter(lambda n: n &gt; 5, range(3, 9)))\n</code></pre><ul>\n<li>装饰器<br>装饰器的作用就像它名字一样，给函数以装饰，做一个更大一范围的修饰。<br>比如，有A、B、C三个果汁工厂，现在要在每瓶果汁上印一个小商标。<br>我们可以在每个工厂内建立一个流水线来印商标，<br>也可以专门建立一个工厂D来印商标。<br>装饰器，就像后者，工厂D。</li>\n</ul>\n<pre><code>def myLog(func):\n    def wrapper(*args, **kw):\n        print(&apos;--- this is my log&apos;)\n        return func(*args, **kw)\n    return wrapper\n\n@myLog\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\n</code></pre><p>注意要加语法糖 @装饰器函数<br>本装饰器的作用是在函数调用前输出一段log。</p>\n<p>如果想让装饰器函数带参数，那就要进行三层嵌套。</p>\n<pre><code>def myLog(logText):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print(logText)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@myLog(&quot;hello log&quot;)\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\n</code></pre><p>但是，这里的函数名已经发生了更改，demo名称其实已经发生了更改，<br>demo.__name__ 是 wrapper<br>可以通过加<br>wrapper.__name__ = func.__name__<br>来改回来，<br>但是，过于繁琐，python提供了更好的方法</p>\n<pre><code>import functools\n\ndef myLog(logText):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print(logText)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@myLog(&quot;hello log&quot;)\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\nprint(demo.__name__)\n</code></pre><p><br></p>\n<ol start=\"3\">\n<li>关于面向对象编程</li>\n</ol>\n<p>python中是有类这个结构的。<br>还有一些命名规则：<br>变量名以 _  开头，代表私有变量（非强制）<br>变量名以 __ 开头，代表私有变量 （强制）<br>变量名以 __ 开头，并且以 __ 结尾，代表特殊变量</p>\n<pre><code>class Person(object):\n    def __init__(self, name, age):\n        self.__name = name\n        self.age = age\n    def eat(self):\n        print(&apos;Person Eating...&apos;)\n\n\nclass Student(Person):\n    def eat(self):\n        print(&apos;Student Eating...&apos;)\n    def study(self):\n        print(&apos;Student Study...&apos;)\n</code></pre><p>也可以对实例进行一些属性的绑定，当然，不会对类造成影响。<br>当然也可以对类进行方法绑定，其所有的实例均受影响</p>\n<pre><code>def set_height(self, height):\n    self.height = height\nclass Person(object):\n    name = &apos;tree&apos;\n\np = Person()\nprint(&apos;p name is: &apos;, p.name)\nprint(&apos;person name is: &apos;, Person.name)\n\np.age = 20\nprint(&apos;p age is: &apos;, p.age)\nprint(&apos;person age is: &apos;, Person.age\n\nPerson.set_height = set_height\np.set_height(180)\nprint(p.height)\n</code></pre><p>最后，可以通过在类内设置一些函数来使类更加完善:</p>\n<ul>\n<li>__init__<br>初始化方法</li>\n<li>__slots__<br>设定允许绑定的变量名（子类会继承父类）</li>\n<li>__len__<br>让类可以作用于len函数，设定计算类大小的方法</li>\n<li>__str__ 与 __repr__<br>都是用来当 print实例对象时 显示出来的字符串。<br>__str__是给用户看的，__repr__是给开发者看的（但一般都一样）</li>\n<li>__iter__ 与 __next__<br>可以让类作用于 for…in 循环</li>\n<li>__getitem__<br>可以像list一样实现按照下标取元素</li>\n<li>__getattr__<br>预设某属性默认值</li>\n<li>__call__<br>实现在实例本身的调用方法。</li>\n<li>装饰器实现get/set方法        </li>\n</ul>\n<pre><code>class Person(object):\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, value):\n        self._age = value\n</code></pre><p><br><br><br></p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br></h2><p>Final : 归纳<br><br></p>\n<p>python的一些基础东西，基本就这些了。<br>接下来，就可以去做一些东西来边练手边加深理解。<br>最后，<br>工具是死的，<br>人是活得，<br>不要局限自己，<br>放飞思维，<br>大胆去做。</p>\n<p><br><br><br><br><br><br><br></p>\n<p>参考：<br>着重推荐： <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a><br><a href=\"http://www.pythoner.com/46.html\" target=\"_blank\" rel=\"noopener\">http://www.pythoner.com/46.html</a></p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>python脚本学习</p>","more":"<p><br><br><br></p>\n<p>动机：<br>脚本可以省很多事情，<br>开发游戏用了lua，<br>但是，<br>真正日常要做一些东西脚本的时候，<br>发现用lua还是比较麻烦些，<br>所以，<br>就瞄上了python，<br>恩，<br>说学就学。</p>\n<p>注意：</p>\n<ul>\n<li>用的是python3</li>\n<li>适合有一定脚本语言基础的人看（很多脚本语言的共性没有记录）</li>\n</ul>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2><p>Round 1: 基础<br><br></p>\n<ul>\n<li>输出语句 print<br><strong> 注意多个参数的格式 </strong></li>\n</ul>\n<pre><code>print(&apos;hello python!&apos;)\nx = 100\ny = &apos;hello&apos;\nprint(&apos;%s user, your score is %d&apos; % (y, x))\nprint(r&apos;&apos;)                            # 在&apos;&apos;内的字符不转义\n</code></pre><ul>\n<li>list、tuple、dict、set</li>\n</ul>\n<ol>\n<li><p>list    列表，有序的集合，随时添加删除元素<br>L = []<br>常用方法:<br>访问元素 - L[index] - index支持负数<br>末尾加入元素 - L.append(val)<br>某位置插入元素 - L.insert(index, val)<br>删除末尾元素 - L.pop()<br>删除某位置元素 - del L[index]</p>\n</li>\n<li><p>tuple 元组，初始化后不可修改 <strong>[ 初始化一个元素的元组时，元素后要加, : t = (1, ) ]</strong><br>T = ()<br><strong>list 与 tuple 可相互嵌套，tuple中的list可以增删，因为存的是地址</strong></p>\n</li>\n<li><p>dict 字典（你也可以叫它map)<br>D = {‘key’: value, }</p>\n</li>\n<li><p>set 集合，无序不重复<br>S = set([])</p>\n</li>\n</ol>\n<ul>\n<li>条件 与 循环<br>python的语法很简单，通过缩进来显示。<br>最重要的是<strong>:</strong></li>\n</ul>\n<pre><code>if &lt;条件&gt;:\n    continue\nelif &lt;条件&gt;:\n    break\nelse:\n    pass\n\nfor &lt; &gt; in &lt;对象集合&gt;:\n    pass\n\nwhile &lt;条件&gt;:\n    pass\n</code></pre><ul>\n<li>函数</li>\n</ul>\n<pre><code># 定义\ndef function_name(parameters):\n    pass                                # 一旦定义一个函数，不可以什么都不写，但可以像这样\n                                        # 用pass来占位，先让代码运行起来。\n</code></pre><p>当然，默认参数值，返回多个值，都是支持的<br>额外要注意的应该是 <strong>参数</strong> 部分，包括：必选参数、默认参数、可变参数、命名关键字参数、关键字参数。<br>可变参数允许传入0个或任意个参数，这些会被自动组装为一个tuple；<br>关键字参数允许传入0个或任意个含参数名的参数，这些被自动组装为1个dict。</p>\n<pre><code>def book(name, author, **kw):\n    if &apos;language&apos; in kw:                         # 判断关键字参数中是否有 language 字段\n        pass\n\n    print(&apos;name: &apos;, name, &apos;author: &apos;, author, &apos;other: &apos;, kw)\n\n# methon1\nbook(&apos;From Grass To Tree&apos;, &apos;ltree98&apos;, language = &apos;CHN&apos;)\nbook(&apos;How To Study Python&apos;, &apos;ltree98&apos;, language = &apos;ENG&apos;, pages = 100)\n\n# method2\nextra = {&apos;language&apos;: &apos;KOR&apos;, &apos;class&apos;: &apos;novel&apos;}\nbook(&apos;lalala&apos;, &apos;tree&apos;, **extra)\n</code></pre><p>PS：如果参数中已经有了一个可变参数，那么后面的命名关键字参数就不需要特殊分隔符’*‘了。<br><strong>参数顺序： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数。</strong></p>\n<pre><code>def f(a, b = 0, *args, **kw):        # 必选参数、默认参数、可变参数、关键字参数\n    pass\ndef f2(a, b = 0, *, d, **kw):        # 必选参数、默认参数、可变参数、命名关键字参数、关键字参数\n    pass\n</code></pre><p><strong>对于任意函数，都可以通过func(*args, **kw)的形式来调用它，无论参数是如何定义的。</strong></p>\n<ul>\n<li>others:<ul>\n<li>range([start = 0,] stop, [, step = 1]]), 生成从start开始（默认为0）到stop（不等于stop）,步长为step（默认为1）的整数序列；<br>start 与 step都是可选参数。</li>\n</ul>\n</li>\n</ul>\n<p><br><br><br></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br></h2><p>Round 2: 进阶<br><br><br><br></p>\n<ol>\n<li>一些特性（切片、迭代、列表生成式、生成器）</li>\n</ol>\n<ul>\n<li>切片<br>针对截取操作<br>L[start: stop: step]<br>截取从start序号开始到stop序号，步长为step的值成一个list返回。</li>\n</ul>\n<pre><code>&gt;&gt;&gt; L = list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; L1 = L[:5]\n[0, 1, 2, 3, 4]\n\n&gt;&gt;&gt; L2 = L[2:7]\n[2, 3, 4, 5, 6]\n\n&gt;&gt;&gt; L3 = L[:-1:2]\n[0, 2, 4, 6, 8]\n\n&gt;&gt;&gt; L4 = L[:]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><ul>\n<li>迭代<br>给定一个list或tuple，通过for循环来遍历它，这种遍历叫做 迭代（iteration）<br>很多语言的迭代是通过下标来进行的，但python里，并不是。<br>当然，顺序可能就不是你当初定义它时的顺序了。</li>\n</ul>\n<pre><code>weekday = {&apos;Mon&apos;: 1, &apos;Tue&apos;: 2, &apos;Wed&apos;: 3}\n\nif isinstance(weekday, Iterable):\n    for w in weekday:\n        print(w)\n</code></pre><p>isinstance(…, Iterable) 判断一个数据类型是否可迭代<br>一般可以可迭代对象是 集合数据类型（如 list、tuple、dict、set、str等），他们都是Iterable类型。</p>\n<ul>\n<li>列表生成式<br>顾名思义，就是一个创建list的方式，<br>通过这种方式创建list比较便捷</li>\n</ul>\n<pre><code>[x + y for x in &apos;ABC&apos; for y in &apos;XYZ&apos; if x != &apos;B&apos;]\n\n# 其实上面那个等价于下面\n\nL = []\nfor x in &apos;ABC&apos;:\n    for y in &apos;XYZ&apos;:\n        if x != &apos;B&apos;:\n            L.append(x+y)\n</code></pre><ul>\n<li>生成器<br>针对于列表容量有限的缺陷，<br>生成器就是一边循环一边计算。<br>与列表生成式的区别是，列表生成时最外层是 []，而生成器最外层是 ()<br>而且，得到的generator，需要不停next得到下一个元素。（一般会通过for循环来迭代获取）</li>\n</ul>\n<pre><code>g = (x + y for x in &apos;ABC&apos; for y in &apos;XYZ&apos; if x != &apos;B&apos;)\nfor v in g:\n    print(v)\n</code></pre><p>可以作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。<br>Iterator类型主要就两种，一种就是这个生成器，还有就是含yield的generator function</p>\n<p><br></p>\n<ol start=\"2\">\n<li>关于函数式编程 （ lambda、map、reduce、filter、 装饰器）</li>\n</ol>\n<ul>\n<li>lambda [arg1 [, arg2, arg3, …]]: expression<br>也叫匿名函数，通过它可以非常方便快捷的定义使用一个函数。<br>具体效果，下面会给出。</li>\n</ul>\n<ul>\n<li>map(func, seq1[, seq2…])<br>将func作用于seq中的每一个元素，并用一个列表给出返回值。</li>\n</ul>\n<pre><code>def f(x):\n    return x * x\nm = map(f, [1, 2, 3, 4, 5])\n# m 将会是一个列表 [1, 4, 9, 16, 25]\n</code></pre><p>其实，用lambda更方便简洁</p>\n<pre><code>m = map(lambda x: x*x, range(1, 6))\n</code></pre><ul>\n<li>reduce(func, seq[, init])<br>这是一个二元操作函数，它用来将一个集合中所有数据进行从前到后的二元操作。</li>\n</ul>\n<pre><code>from fuctools import reduce\ndef specialAdd(x, y):\n    return x*10 + y\nval = reduce(specialAdd, [1, 2, 3, 4, 5])\n# val将会是一个数字 12345\n</code></pre><p>reduce要提前导入，<br>当然，也可以用lambda</p>\n<pre><code>val = reduce(lambda x, y: x*10 + y, range(1, 6))\n</code></pre><ul>\n<li>filter(func, seq)<br>可以当做过滤器，将集合中的每个数都传入函数，根据函数返回的bool变量来决定是否留下。</li>\n</ul>\n<pre><code>def bigger_than_five(n):\n    return n &gt; 5\nf = list(filter(bigger_than_five, [3, 4, 5, 6, 7, 8]))\n# f 将会是一个列表 [6, 7, 8]\n\nf2 = list(filter(lambda n: n &gt; 5, range(3, 9)))\n</code></pre><ul>\n<li>装饰器<br>装饰器的作用就像它名字一样，给函数以装饰，做一个更大一范围的修饰。<br>比如，有A、B、C三个果汁工厂，现在要在每瓶果汁上印一个小商标。<br>我们可以在每个工厂内建立一个流水线来印商标，<br>也可以专门建立一个工厂D来印商标。<br>装饰器，就像后者，工厂D。</li>\n</ul>\n<pre><code>def myLog(func):\n    def wrapper(*args, **kw):\n        print(&apos;--- this is my log&apos;)\n        return func(*args, **kw)\n    return wrapper\n\n@myLog\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\n</code></pre><p>注意要加语法糖 @装饰器函数<br>本装饰器的作用是在函数调用前输出一段log。</p>\n<p>如果想让装饰器函数带参数，那就要进行三层嵌套。</p>\n<pre><code>def myLog(logText):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print(logText)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@myLog(&quot;hello log&quot;)\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\n</code></pre><p>但是，这里的函数名已经发生了更改，demo名称其实已经发生了更改，<br>demo.__name__ 是 wrapper<br>可以通过加<br>wrapper.__name__ = func.__name__<br>来改回来，<br>但是，过于繁琐，python提供了更好的方法</p>\n<pre><code>import functools\n\ndef myLog(logText):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print(logText)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@myLog(&quot;hello log&quot;)\ndef demo():\n    print(&apos;\\n\\ndemo is running\\n\\n&apos;)\n\ndemo()\nprint(demo.__name__)\n</code></pre><p><br></p>\n<ol start=\"3\">\n<li>关于面向对象编程</li>\n</ol>\n<p>python中是有类这个结构的。<br>还有一些命名规则：<br>变量名以 _  开头，代表私有变量（非强制）<br>变量名以 __ 开头，代表私有变量 （强制）<br>变量名以 __ 开头，并且以 __ 结尾，代表特殊变量</p>\n<pre><code>class Person(object):\n    def __init__(self, name, age):\n        self.__name = name\n        self.age = age\n    def eat(self):\n        print(&apos;Person Eating...&apos;)\n\n\nclass Student(Person):\n    def eat(self):\n        print(&apos;Student Eating...&apos;)\n    def study(self):\n        print(&apos;Student Study...&apos;)\n</code></pre><p>也可以对实例进行一些属性的绑定，当然，不会对类造成影响。<br>当然也可以对类进行方法绑定，其所有的实例均受影响</p>\n<pre><code>def set_height(self, height):\n    self.height = height\nclass Person(object):\n    name = &apos;tree&apos;\n\np = Person()\nprint(&apos;p name is: &apos;, p.name)\nprint(&apos;person name is: &apos;, Person.name)\n\np.age = 20\nprint(&apos;p age is: &apos;, p.age)\nprint(&apos;person age is: &apos;, Person.age\n\nPerson.set_height = set_height\np.set_height(180)\nprint(p.height)\n</code></pre><p>最后，可以通过在类内设置一些函数来使类更加完善:</p>\n<ul>\n<li>__init__<br>初始化方法</li>\n<li>__slots__<br>设定允许绑定的变量名（子类会继承父类）</li>\n<li>__len__<br>让类可以作用于len函数，设定计算类大小的方法</li>\n<li>__str__ 与 __repr__<br>都是用来当 print实例对象时 显示出来的字符串。<br>__str__是给用户看的，__repr__是给开发者看的（但一般都一样）</li>\n<li>__iter__ 与 __next__<br>可以让类作用于 for…in 循环</li>\n<li>__getitem__<br>可以像list一样实现按照下标取元素</li>\n<li>__getattr__<br>预设某属性默认值</li>\n<li>__call__<br>实现在实例本身的调用方法。</li>\n<li>装饰器实现get/set方法        </li>\n</ul>\n<pre><code>class Person(object):\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, value):\n        self._age = value\n</code></pre><p><br><br><br></p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br></h2><p>Final : 归纳<br><br></p>\n<p>python的一些基础东西，基本就这些了。<br>接下来，就可以去做一些东西来边练手边加深理解。<br>最后，<br>工具是死的，<br>人是活得，<br>不要局限自己，<br>放飞思维，<br>大胆去做。</p>\n<p><br><br><br><br><br><br><br></p>\n<p>参考：<br>着重推荐： <a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a><br><a href=\"http://www.pythoner.com/46.html\" target=\"_blank\" rel=\"noopener\">http://www.pythoner.com/46.html</a></p>"},{"title":"《REWORK》读记","date":"2016-11-20T13:00:00.000Z","_content":"\n----------\n\nJason Friend 与 David Heinemeier Hansson 的 《REWORK》\n\n\n<!-- more -->\n<br/>\n\n好喜欢这种结构的书籍，\n每段都不是很长，\n很多段之间没有特别强大的关联性，\n特别适合在坐公交、坐地铁时候看一看。\n\n这本书感觉就像是给准备创业的人的一个个小TIP，\n作者把他们创业中遇到的想到的总结起来，供后人参考。\n还有，这本书的插图，真是赞的很。\n\n这其中，我最喜欢的一小段，\n就是 —— Tone is in your fingers\n你的思想，你的东西，通过改变工具是变不了的。\n\n作者之后也发布了另一部新作 《REMOTE》，\n评价好像不是很好。\n但是，还是要看一看的。\n\n最最后，这本书中文名叫 —— 重来\n额...好吧。","source":"_posts/《REWORK》读记.md","raw":"---\ntitle: 《REWORK》读记\ndate: 2016-11-20 21:00:00\ntags: 读书笔记\n---\n\n----------\n\nJason Friend 与 David Heinemeier Hansson 的 《REWORK》\n\n\n<!-- more -->\n<br/>\n\n好喜欢这种结构的书籍，\n每段都不是很长，\n很多段之间没有特别强大的关联性，\n特别适合在坐公交、坐地铁时候看一看。\n\n这本书感觉就像是给准备创业的人的一个个小TIP，\n作者把他们创业中遇到的想到的总结起来，供后人参考。\n还有，这本书的插图，真是赞的很。\n\n这其中，我最喜欢的一小段，\n就是 —— Tone is in your fingers\n你的思想，你的东西，通过改变工具是变不了的。\n\n作者之后也发布了另一部新作 《REMOTE》，\n评价好像不是很好。\n但是，还是要看一看的。\n\n最最后，这本书中文名叫 —— 重来\n额...好吧。","slug":"《REWORK》读记","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabj20024veuenz885c2s","content":"<hr>\n<p>Jason Friend 与 David Heinemeier Hansson 的 《REWORK》</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>好喜欢这种结构的书籍，<br>每段都不是很长，<br>很多段之间没有特别强大的关联性，<br>特别适合在坐公交、坐地铁时候看一看。</p>\n<p>这本书感觉就像是给准备创业的人的一个个小TIP，<br>作者把他们创业中遇到的想到的总结起来，供后人参考。<br>还有，这本书的插图，真是赞的很。</p>\n<p>这其中，我最喜欢的一小段，<br>就是 —— Tone is in your fingers<br>你的思想，你的东西，通过改变工具是变不了的。</p>\n<p>作者之后也发布了另一部新作 《REMOTE》，<br>评价好像不是很好。<br>但是，还是要看一看的。</p>\n<p>最最后，这本书中文名叫 —— 重来<br>额…好吧。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>Jason Friend 与 David Heinemeier Hansson 的 《REWORK》</p>","more":"<p><br></p>\n<p>好喜欢这种结构的书籍，<br>每段都不是很长，<br>很多段之间没有特别强大的关联性，<br>特别适合在坐公交、坐地铁时候看一看。</p>\n<p>这本书感觉就像是给准备创业的人的一个个小TIP，<br>作者把他们创业中遇到的想到的总结起来，供后人参考。<br>还有，这本书的插图，真是赞的很。</p>\n<p>这其中，我最喜欢的一小段，<br>就是 —— Tone is in your fingers<br>你的思想，你的东西，通过改变工具是变不了的。</p>\n<p>作者之后也发布了另一部新作 《REMOTE》，<br>评价好像不是很好。<br>但是，还是要看一看的。</p>\n<p>最最后，这本书中文名叫 —— 重来<br>额…好吧。</p>"},{"title":"《三体》读感","date":"2017-02-13T13:37:35.000Z","_content":"\n《三体》 第一部，读感\n\n<!-- more -->\n<br/>\n\n这是我看的第一部科幻小说，\n正如同事所言: 起点那么高，也不怕扯到裆= =..\n但是，自小阅历无数网络鸦片小说的我，历经各种玄幻校园修真异世穿越等毒害，当然不至于败倒在此。\n<br/>\n我知道这本书还是因为电影《超体》，当时好像挺乱。\n我看过电影，也看完了这本书第一部，\n个人感觉这两者好像没大有啥关系呀？如果同为科幻类也算关系的话，那它们倒还是有点儿关系的。\n<br/>\n第一部看完，还好，没有上来就一堆理论压死我。\n最开始台球问题的启蒙，瞬间就打开了我的思维。\n后面看到汪淼面对各种离奇的事物的恐慌，当时还有些不理解，\n后来才明白，这大概就是敬畏吧，无知的人才无所畏惧，知道的越多，就越敬畏。\n当然，这里面还是有一些理论术语什么的，还是不懂。\n但也没有去苛求，也没有去深究，\n才不管死亡倒计时的原理呢？别耽误我往后看！（傲娇小脸 ┗|｀O′|┛ ）\n<br/>\n整本书看完，\n印象最深刻的还是那个三体游戏以及它背后的三体文明，\n乱纪元与恒纪元的交替，\n文明一次次出现，一次次毁灭，\n但不变的是它们的目标，为了生存。\n为了生存，一次次脱水；\n为了生存，不断追求纪元规律；\n但是，找到规律后发现，自己的星球随时可能灰飞烟灭。\n于是，为了生存，它们前往地球。\n但是，怕到了地球，自己文明被压制，被地球文明毁灭，所以要压制地球文明。\n一切都是为了生存。\n但是，生存下去后呢？\n大概就是地球如今的模样，陷入内斗了。\n这时，会不会又有其他的文明来替代呢？\n<br/>\n最后，就是这本书的后记：\n如果存在外星文明，那么宇宙中有共同的道德标准吗？\n我翻来覆去的想，还是觉得不会有。\n（本来想了一堆，但是还是不写了，太负面太消极，我自己消极消极就够了..)\n<br/>\n最后的最后：\n\t我们都只是虫子而已。\n<br/>\n期待拜读后两部作品。\n","source":"_posts/《三体》读感.md","raw":"---\ntitle: 《三体》读感\ndate: 2017-02-13 21:37:35\ntags: 读书笔记\n---\n\n《三体》 第一部，读感\n\n<!-- more -->\n<br/>\n\n这是我看的第一部科幻小说，\n正如同事所言: 起点那么高，也不怕扯到裆= =..\n但是，自小阅历无数网络鸦片小说的我，历经各种玄幻校园修真异世穿越等毒害，当然不至于败倒在此。\n<br/>\n我知道这本书还是因为电影《超体》，当时好像挺乱。\n我看过电影，也看完了这本书第一部，\n个人感觉这两者好像没大有啥关系呀？如果同为科幻类也算关系的话，那它们倒还是有点儿关系的。\n<br/>\n第一部看完，还好，没有上来就一堆理论压死我。\n最开始台球问题的启蒙，瞬间就打开了我的思维。\n后面看到汪淼面对各种离奇的事物的恐慌，当时还有些不理解，\n后来才明白，这大概就是敬畏吧，无知的人才无所畏惧，知道的越多，就越敬畏。\n当然，这里面还是有一些理论术语什么的，还是不懂。\n但也没有去苛求，也没有去深究，\n才不管死亡倒计时的原理呢？别耽误我往后看！（傲娇小脸 ┗|｀O′|┛ ）\n<br/>\n整本书看完，\n印象最深刻的还是那个三体游戏以及它背后的三体文明，\n乱纪元与恒纪元的交替，\n文明一次次出现，一次次毁灭，\n但不变的是它们的目标，为了生存。\n为了生存，一次次脱水；\n为了生存，不断追求纪元规律；\n但是，找到规律后发现，自己的星球随时可能灰飞烟灭。\n于是，为了生存，它们前往地球。\n但是，怕到了地球，自己文明被压制，被地球文明毁灭，所以要压制地球文明。\n一切都是为了生存。\n但是，生存下去后呢？\n大概就是地球如今的模样，陷入内斗了。\n这时，会不会又有其他的文明来替代呢？\n<br/>\n最后，就是这本书的后记：\n如果存在外星文明，那么宇宙中有共同的道德标准吗？\n我翻来覆去的想，还是觉得不会有。\n（本来想了一堆，但是还是不写了，太负面太消极，我自己消极消极就够了..)\n<br/>\n最后的最后：\n\t我们都只是虫子而已。\n<br/>\n期待拜读后两部作品。\n","slug":"《三体》读感","published":1,"updated":"2018-04-01T17:08:51.000Z","_id":"cjfbbabj40027veuegu8oq9qu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>《三体》 第一部，读感</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>这是我看的第一部科幻小说，<br>正如同事所言: 起点那么高，也不怕扯到裆= =..<br>但是，自小阅历无数网络鸦片小说的我，历经各种玄幻校园修真异世穿越等毒害，当然不至于败倒在此。<br><br><br>我知道这本书还是因为电影《超体》，当时好像挺乱。<br>我看过电影，也看完了这本书第一部，<br>个人感觉这两者好像没大有啥关系呀？如果同为科幻类也算关系的话，那它们倒还是有点儿关系的。<br><br><br>第一部看完，还好，没有上来就一堆理论压死我。<br>最开始台球问题的启蒙，瞬间就打开了我的思维。<br>后面看到汪淼面对各种离奇的事物的恐慌，当时还有些不理解，<br>后来才明白，这大概就是敬畏吧，无知的人才无所畏惧，知道的越多，就越敬畏。<br>当然，这里面还是有一些理论术语什么的，还是不懂。<br>但也没有去苛求，也没有去深究，<br>才不管死亡倒计时的原理呢？别耽误我往后看！（傲娇小脸 ┗|｀O′|┛ ）<br><br><br>整本书看完，<br>印象最深刻的还是那个三体游戏以及它背后的三体文明，<br>乱纪元与恒纪元的交替，<br>文明一次次出现，一次次毁灭，<br>但不变的是它们的目标，为了生存。<br>为了生存，一次次脱水；<br>为了生存，不断追求纪元规律；<br>但是，找到规律后发现，自己的星球随时可能灰飞烟灭。<br>于是，为了生存，它们前往地球。<br>但是，怕到了地球，自己文明被压制，被地球文明毁灭，所以要压制地球文明。<br>一切都是为了生存。<br>但是，生存下去后呢？<br>大概就是地球如今的模样，陷入内斗了。<br>这时，会不会又有其他的文明来替代呢？<br><br><br>最后，就是这本书的后记：<br>如果存在外星文明，那么宇宙中有共同的道德标准吗？<br>我翻来覆去的想，还是觉得不会有。<br>（本来想了一堆，但是还是不写了，太负面太消极，我自己消极消极就够了..)<br><br><br>最后的最后：<br>    我们都只是虫子而已。<br><br><br>期待拜读后两部作品。</p>\n","site":{"data":{}},"excerpt":"<p>《三体》 第一部，读感</p>","more":"<p><br></p>\n<p>这是我看的第一部科幻小说，<br>正如同事所言: 起点那么高，也不怕扯到裆= =..<br>但是，自小阅历无数网络鸦片小说的我，历经各种玄幻校园修真异世穿越等毒害，当然不至于败倒在此。<br><br><br>我知道这本书还是因为电影《超体》，当时好像挺乱。<br>我看过电影，也看完了这本书第一部，<br>个人感觉这两者好像没大有啥关系呀？如果同为科幻类也算关系的话，那它们倒还是有点儿关系的。<br><br><br>第一部看完，还好，没有上来就一堆理论压死我。<br>最开始台球问题的启蒙，瞬间就打开了我的思维。<br>后面看到汪淼面对各种离奇的事物的恐慌，当时还有些不理解，<br>后来才明白，这大概就是敬畏吧，无知的人才无所畏惧，知道的越多，就越敬畏。<br>当然，这里面还是有一些理论术语什么的，还是不懂。<br>但也没有去苛求，也没有去深究，<br>才不管死亡倒计时的原理呢？别耽误我往后看！（傲娇小脸 ┗|｀O′|┛ ）<br><br><br>整本书看完，<br>印象最深刻的还是那个三体游戏以及它背后的三体文明，<br>乱纪元与恒纪元的交替，<br>文明一次次出现，一次次毁灭，<br>但不变的是它们的目标，为了生存。<br>为了生存，一次次脱水；<br>为了生存，不断追求纪元规律；<br>但是，找到规律后发现，自己的星球随时可能灰飞烟灭。<br>于是，为了生存，它们前往地球。<br>但是，怕到了地球，自己文明被压制，被地球文明毁灭，所以要压制地球文明。<br>一切都是为了生存。<br>但是，生存下去后呢？<br>大概就是地球如今的模样，陷入内斗了。<br>这时，会不会又有其他的文明来替代呢？<br><br><br>最后，就是这本书的后记：<br>如果存在外星文明，那么宇宙中有共同的道德标准吗？<br>我翻来覆去的想，还是觉得不会有。<br>（本来想了一堆，但是还是不写了，太负面太消极，我自己消极消极就够了..)<br><br><br>最后的最后：<br>    我们都只是虫子而已。<br><br><br>期待拜读后两部作品。</p>"},{"title":"《代码的整洁之道》读记","date":"2016-10-13T13:59:16.000Z","_content":"\n----------\n\n读这本书之前做了一些功课，很多人反映，书是一本好书，无奈作者废话太多。。。\n刚开始，我是不信的，但自己读下来才发现，古人诚不欺我啊。\n来划一下重点吧，写的这些或者是作者所描述的重点，或者是我感触比较深的东西。\n\n**Later equals never！**\n**稍后等于永不！**\n\n\n<!-- more -->\n<br/>\n\n### 第一章、关于整洁的代码\n- 代码的逻辑应该直截了当，让缺陷难以隐藏；尽量去减少依赖关系，从而便于维护；依据某种分层战略完善错误处理代码；性能调到最优，避免他人污染。\n- 糟糕的代码会引发混乱，别人修改糟糕的代码时，往往会越改越烂。\n- 每个函数、每个类、每个模块 都全神贯注去解决一件事\n- 代码应该通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。\n- 重要顺序：         \n\t- 能通过所有测试        \n\t- 没有重复代码         \n\t- 体现系统中的全部设计理念         \n\t- 包括尽量少的实体\n<br/>\n\n### 第二章、关于命名\n- 名副其实，见名知意\n- 使用可以读的出来的、可以被搜索的名称\n- 匈牙利命名法、去掉成员前缀\n- 类名、对象名 应该是名词或名词短语；    方法名应该是动词或动词短语\n- 不要抖机灵，每个概念对应一个词，不用双关语（add、insert）\n- 分离解决方案领域和问题领域的概念，与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称\n- 添加有意义的语境\n<br/>\n\n### 第三章、关于函数\n- 函数的第一规则是短小，第二条规则是更短小！\n- 第一章节有提到过的： 每个函数尽量只做一件事。\n- 自顶向下阅读代码，向下规则\n- 函数参数，最理想为零，其次单参、双参、三参...（除非有足够特殊的理由，不要三参数+）\n- 不要向函数传入bool，因为这叫要求该函数不止做一件事\n- 不要有副作用，比如让你洗个苹果，你别洗完了然后吃了它。\n- 普遍而言，应避免使用输出参数。\n- 分隔指令与询问，要么让它干什么，要么让它回答什么。\n<br/>\n\n### 第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）\n- 代码会一直被维护更新，但是注释不一定。\n- 注释不能改变根本问题，它不能优化糟糕的代码。\n- 值得写的注释：       \n\t- 版权及著作权声明等        \n\t- 对你的意图的解释        \n\t- 警示        \n\t- TODO注释，为以后编写查找方便\n- 废注释：        \n\t- 没有规范化，过于局部的注释（需要纵览全文，才能知晓其意）        \n\t- 多余的注释（ getMaxNumber(num1, num2) ,还需要写这个函数是干啥的吗？）        \n\t- 误导性注释        \n\t- 循规式注释（例如：要求每个函数都要像API文档一样写一套注释来说明函数作用，参数意义。）        \n\t- 日志式注释（之前不是说光维护代码，不维护注释吗？现在我维护注释，而且把每次修改的时间、内容都加上。有那时间干啥不好，100行的文件，80行注释日志？）        \n\t- 归属与署名        \n\t- 注释掉的代码（除了注释的人，其他人都不敢删的东西）        \n\t- 信息过多，无条理\n<br/>\n\n### 第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)\n- 用空白行来区分你的模块\n- 关系应该密切的东西：        \n\t- 变量声明，应该尽可能的靠近其使用位置        \n\t- 实体变量，应该在类的顶部声明        \n\t- 相关函数，函数A调用了函数B，应该让A和B放到一起，A尽可能的放在B的上面        \n\t- 概念相关，概念相关的代码 应该放在一起，相关性与距离成正比\n- 尽量让代码行短小，最好以80个字符为上限，但最多不要超过120\n- 水平方向上的区隔：        \n\t- 赋值操作周围加上空格        \n\t- 不在函数名和左圆括号之间加空格        \n\t- 逗号后加空格       \n\t- 加减周围加空格，优先级高的乘除周围不加空格；当然，如果只有优先级相同的运算符，还是可以在周围加空格的\n<br/>\n\n### 第六章、 关于对象与数据结构\n- 不要将类内变量设置为私有，然后又添加赋值器和取值器，将它公之于众\n- 对象与数据结构之间的二分原理：        \n\t- 过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，        \n\t- 面向对象代码便于在不改动既有函数的前提下添加新类    \n反过来说就是：        \n\t- 过程代码难以添加新数据结构，因为必须修改所有函数        \n\t- 面向对象代码难以添加新函数，因为必须修改所有类\n- Demeter律，模块不应了解它所操作对象的内部情形\n- 最为精炼的数据结构，是一个只有公共变量、没有函数的类\n<br/>\n\n### 第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\n- 使用异常处理而非返回错误码\n- 先写出 try-catch-finally语句\n- 给出异常发生的环境说明，方便定位\n- 依调用者需要定义异常类\n- 不要返回、传递NULL值\n<br/>\n\n### 第八章、关于边界（将其他代码整合到自己代码中）\n- 使用类似Map的边界接口，就把它保留在类或近亲类中；避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。\n- 学习性测试很有必要\n<br/>\n\n### 第九章、关于单元测试\n- TDD（测试驱动开发）三定律：        \n\t- 在编写不能通过的单元测试前，不可编写生产代码        \n\t- 只可编写刚好无法通过的单元测试，不能编译也算不通过        \n\t- 只可编写刚好足以通过当前失败测试的生产代码\n- 脏测试 等同于 没测试\n- 测试代码与生产代码一样重要，它需要被思考、被设计和被照料，它该像生产代码一样保持整洁。\n- 整洁的测试的要素 \t- 可读性！！！\n- 整洁测试的五条规则 \t- FIRST        \n\t- F：Fast，测试应该能够快速的运行。        \n\t- I：Independent，测试应该相互独立。        \n\t- R：Repeatable，测试应该可以在任何环境中重复通过。        \n\t- S：Self-Validating，测试应该有布尔值输出。        \n\t- T：Timely，测试应及时编写。\n<br/>\n\n### 第十章、关于类\n- 类应该由一组变量列表开始，公共静态常量优先于私有静态变量\n- 类应该通函数一样要短小\n- 类或模块应有且只有一条加以修改的理由\n- 单一全责：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个全责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为\n- 内聚：类应该只有少量实体变量\n- 既然修改会一直持续，那么就更应该对类加以组织，以降低修改的风险\n- 类应当依赖于抽象而不是依赖于具体细节\n<br/>\n\n### 第十一章、关于系统\n- 软件系统应将起始过程与之后的运行时逻辑分离开。    就比如我做一个玩家信息面板，在起始过程，需要创建很多Text、Image来存储玩家一些状态信息及玩家的形象。    但是，我用这个界面的时候，只需要改动里面的值、或者切换形象。    \n这时，就可以有两个函数，init来负责起始过程的创建；refresh来负责更新玩家的状态。（当然不能把所有具体实现都放在一个函数里，每个函数负责一个小模块是必要的）\n- 软件系统与物理系统可以类比，它们的架构都可以递增式地增长，只要我们持续将关注面恰当的切分。\n- 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言）对象实现。不同领域之间用最不具有亲还行的方面或类方面工具整合起来。\n<br/>\n\n### 第十二章、关于迭代\n- Kent Beck关于简单设计的四条规则    \n\t- 运行所有测试    \n\t- 不可重复    \n\t- 表达了程序员的意图    \n\t- 尽可能减少类和方法的数量    \n\t以上规则按其重要程度排列\n- 遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计。\n- 测试消除了对清理代码就会破坏代码的恐惧，所以可以放心的去重构。\n- 重复是良好系统设计的大敌，它代表着额外工作、额外风险和额外且不必要的复杂度。\n- 增强表达力方法：    \n\t- 选用好的名称    \n\t- 保持函数和类的尺寸短小    \n\t- 采用标准命名法    \n\t- 编写良好的单元测试    \n\t- 最重要的就是去尝试去做\n- 尽可能减少类和方法的数量，这条规则优先级是最低的，要让步于测试、消除重复和增强表达力。\n<br/>\n\n### 第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\n- 并发是一种解耦策略，它将**目的**和**时机**分解开，而在单线程中，两者紧密耦合。\n- 解耦目的与时机可以显著的改进程序的**吞吐量**和**结构**\n- 一些迷思与误解    \n\t- 并发总能改进系能。    并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。    \n\t- 编写并发程序无需修改设计。    并发算法的设计有可能与单线程系统的设计极不相同，解耦目的与时机往往对系统结构产生巨大的影响。    \n\t- 在采用Web或EJB容器的时候，理解并发问题并不重要。    只有了解容器的运作，才可以对其产生的并发问题更好的解决。\n- 关于并发编程的中肯理解    \n\t- 并发会在性能和编写额外代码上增加一些开销    \n\t- 正确的并发是复杂的，即便对于简单的问题也是如此    \n\t-并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待   \n\t- 并发常常需要对设计策略的根本性修改\n- 防御并发代码问题的原则与技巧    \n\t- 单一权责原则（SRP)    \n\t分离并发相关代码与其他代码    \n\t- 限制数据作用域    \n\t谨记数据封装，严格限制对可能被共享的数据的访问    \n\t- 使用数据复本    从多个线程收集所有复本的结果，并在单个线程中合并这些结果    \n\t- 线程应尽可能的独立    尝试将数据分解到可被独立线程（可能在不同的处理器上）操作的独立子集\n- 一些基础定义    \n\t- 限定资源    \n\t并发环境中有着固定尺寸或数量的资源。    \n\t- 互斥    \n\t每一时刻仅有一个线程能访问共享数据或共享资源。    \n\t- 线程饥饿    \n\t一个或一组线程在很长时间内或永久被禁止。    \n\t- 死锁    \n\t两个或多个线程互相等待执行结束。    \n\t- 活锁    \n\t执行次序一致的线程，每个都想要起步，但发现其他线程已开始。\n- 一些执行模型    \n\t- 生产者-消费者模型    \n\t一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。    \n\t- 读者-作者模型    \n\t当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累计。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一个辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。    \n\t- 经典的哲学家    一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。桌面中央摆着一大碗意大利面。每个哲学家在吃饭的时候都要拿起叉子吃饭。但除非手上有两把叉子，否则没法进食。如果左边或右边的哲学家已经取用一把叉子，中间这位就需要等到别人吃完，放回叉子。每位哲学家吃完后，就将两把叉子放回桌面，直到下次吃饭。\n- 避免使用一个共享对象的多个方法。当不得不使用时，写代码需要注意的方法。    \n\t- 基于客户端的锁定    \n\t客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。    \n\t- 基于服务端的锁定    \n\t在服务端创建锁定服务端的方法，调用所有方法，然后解锁。让客户端调用新方法。    \n\t- 适配服务端    \n\t创建执行锁定的中间层。这是一种基于服务端锁定的例子，但不修改原始服务端代码。\n- 尽可能减小同步区域\n- 尽早考虑关闭问题，尽早令其工作正常\n- 编写测试，测试线程代码\n关于测试代码的建议    \n\t- 将伪失败看做可能的线程问题    \n\t- 先使非线程代码可工作    \n\t- 编写可插拔的线程代码    \n\t- 编写可调整的线程代码    \n\t- 运行多于处理器数量的线程    \n\t- 在不同平台上运行    \n\t- 调整代码并强迫错误发生\n<br/>\n\n#### 第十四章、关于逐步改进\n- 要编写整洁代码，必须先写肮脏代码，然后清理它。\n所以，不要害怕写的肮脏，只要去清理，就可以写出整洁的代码。\n但是，一定要去**清理它**！\n- 在改进程序过程中，要保持系统始终可以运行\n- 进度可以重订，需求可以重新定义，团队动态可以修正，但糟糕的代码只是一直腐败发酵，无情的拖后腿\n<br/>\n\n#### 第十七章、味道与启发\n- 注释    \n\t- 不恰当的信息    \n\t让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。    \n\t- 废弃的注释    \n\t过时、无关或不正确的注释就是废弃的注释。    \n\t- 冗余注释 \n\t如果描述的是某种充分自我描述了的东西，那么注释就是多余的。    \n\t- 糟糕的注释    \n\t值得编写的注释，也值得好好写。不要画蛇添足，要保持整洁。    \n\t- 注释掉的代码    \n\t看到注释掉的代码，就删除它！\n\t源代码控制系统还会记得他，让注释的人回去找。    \n\t什么？不用源代码控制系统？    \n\t好吧，你已经不需要读这本书了。\n- 环境    \n\t- 需要多步才能实现的构建    \n\t构建系统应该是单步的小操作。    \n\t不应该从源代码控制系统中一点点签出代码；    \n\t不应该需要一系列神秘指令或环境依赖脚本来构建单个元素；    \n\t不应该四处寻找额外小JAR、XML文件和其他杂物；   \n\t应该能用单个命令签出系统，并用单个指令构建它。    \n\t- 需要多步才能做到的测试    \n\t应该能发出单个指令就可以运行全部单元测试。\n- 函数    \n\t- 过多的参数    \n\t函数的参数量应该少，三个以上绝对不可容忍。    \n\t- 输出参数    \n\t输出参数违反直觉，读者期望参数用于输入而非输出。    \n\t- 标识参数    \n\t布尔值参数等同于宣告该函数做了不知一件事，应该消灭。    \n\t- 死函数\n\t永不被调用的方法应该被丢弃。\n\t不要怕删除，源代码控制系统会帮你记住它。\n- 一般性问题    \n\t- 一个源文件中存在多种语言    \n\t理想的源文件包括且只包括一种语言，\n\t现实中，应该尽力减少源文件中额外语言的数量和范围。    \n\t- 明显的行为未被实现    \n\t遵循\"最小惊异原则\"，函数或类应该实现其他程序员有理由期待的行为。    \n\t- 不正确的边界行为    \n\t不要让代码只是能工作，应该追索每种边界条件，并编写测试。    \n\t- 忽视安全    \n\t关闭某些编译器警告，可能有助于构建；但更存在无穷无尽的调试风险。    \n\t- 重复    \n\t本书最重要的规则之一    \n\t尽可能找到并消除重复。    \n\t- 在错误的抽象层级上的代码    \n\t创建分离较高层级一般性概念与较低层级细节概念的抽象模型。    \n\t- 基类依赖于派生类    \n\t将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类概念。    \n\t- 信息过多    \n\t设计良好的模块有着非常小的接口，让你事半功倍。    \n\t设计低劣的模块有着广阔、深入的接口，让你事倍功半。    \n\t设计良好的接口并不提供许多需要依靠的函数，所以耦合度也较低。    \n\t设计低劣的接口提供大量必须调用的函数，耦合度较高。    \n\t- 死代码    \n\t死代码就是不执行的代码，可以在        \n\t\t- 不会发生的条件语句中        \n\t\t- 从不抛出异常的try语句的catch块中        \n\t\t- 在永久不会发生的switch/case条件中 \n\t\n\t找到这些代码。    \n\t然后，埋葬它！    \n\t- 垂直分隔    \n\t变量和函数应该在被靠近使用的地方定义。    \n\t私有函数应该刚好在其首次被使用的位置下面定义。    \n\t- 前后不一致    \n\t最小惊异原则，小心选择约定，一旦选中，就应该持续的遵循。    \n\t- 使用解释性变量名、函数名、类名    \n\t- 把逻辑依赖改为物理依赖    \n\t依赖者模块不应对被依赖者模块有假定，应该明确的询问候着全部信息。    \n\t- 用多态替代 if/else 或 switch/case    \n\t- 用命名常量替代魔术数    \n\t- 封装条件、边界    \n\t- 函数只做一件事\n- 关于类    \n\t- import package.*;  比80行的导入语句好看多了     \n\t- 不要继承常量\n- 名称    \n\t- 采用描述性的名称    \n\t- 名称应与抽象层级相符    \n\t- 尽可能用标准命名法    \n\t- 无歧义的名称    \n\t- 为较大作用范围选用较长名称    \n\t- 避免编码    \n\t- 名称应该说明副作用\n- 测试    \n\t- 多测试    \n\t- 使用覆盖率工具    \n\t- 别略过小测试    \n\t- 被忽略的测试就是对不确定事物的疑问    \n\t- 测试边界条件    \n\t- 全面测试相近的缺陷    \n\t- 测试应该快速\n<br/>\n<br/>\n\n#### 本书总结\n终于把这本书啃完了。\n虽然作者比较啰嗦点，但是收获还是很大的。\n书中提到的，有些已经做到了；\n但有些不仅没做到，还是反面教材。\n多规范一下自己的代码，毕竟对于我们来说，代码的清晰度、整洁度还是很重要的。\n代码总要给别人看的，不要让自己的代码羞以示人。","source":"_posts/《代码的整洁之道》读记.md","raw":"---\ntitle: 《代码的整洁之道》读记\ndate: 2016-10-13 21:59:16\ntags: 读书笔记\n---\n\n----------\n\n读这本书之前做了一些功课，很多人反映，书是一本好书，无奈作者废话太多。。。\n刚开始，我是不信的，但自己读下来才发现，古人诚不欺我啊。\n来划一下重点吧，写的这些或者是作者所描述的重点，或者是我感触比较深的东西。\n\n**Later equals never！**\n**稍后等于永不！**\n\n\n<!-- more -->\n<br/>\n\n### 第一章、关于整洁的代码\n- 代码的逻辑应该直截了当，让缺陷难以隐藏；尽量去减少依赖关系，从而便于维护；依据某种分层战略完善错误处理代码；性能调到最优，避免他人污染。\n- 糟糕的代码会引发混乱，别人修改糟糕的代码时，往往会越改越烂。\n- 每个函数、每个类、每个模块 都全神贯注去解决一件事\n- 代码应该通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。\n- 重要顺序：         \n\t- 能通过所有测试        \n\t- 没有重复代码         \n\t- 体现系统中的全部设计理念         \n\t- 包括尽量少的实体\n<br/>\n\n### 第二章、关于命名\n- 名副其实，见名知意\n- 使用可以读的出来的、可以被搜索的名称\n- 匈牙利命名法、去掉成员前缀\n- 类名、对象名 应该是名词或名词短语；    方法名应该是动词或动词短语\n- 不要抖机灵，每个概念对应一个词，不用双关语（add、insert）\n- 分离解决方案领域和问题领域的概念，与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称\n- 添加有意义的语境\n<br/>\n\n### 第三章、关于函数\n- 函数的第一规则是短小，第二条规则是更短小！\n- 第一章节有提到过的： 每个函数尽量只做一件事。\n- 自顶向下阅读代码，向下规则\n- 函数参数，最理想为零，其次单参、双参、三参...（除非有足够特殊的理由，不要三参数+）\n- 不要向函数传入bool，因为这叫要求该函数不止做一件事\n- 不要有副作用，比如让你洗个苹果，你别洗完了然后吃了它。\n- 普遍而言，应避免使用输出参数。\n- 分隔指令与询问，要么让它干什么，要么让它回答什么。\n<br/>\n\n### 第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）\n- 代码会一直被维护更新，但是注释不一定。\n- 注释不能改变根本问题，它不能优化糟糕的代码。\n- 值得写的注释：       \n\t- 版权及著作权声明等        \n\t- 对你的意图的解释        \n\t- 警示        \n\t- TODO注释，为以后编写查找方便\n- 废注释：        \n\t- 没有规范化，过于局部的注释（需要纵览全文，才能知晓其意）        \n\t- 多余的注释（ getMaxNumber(num1, num2) ,还需要写这个函数是干啥的吗？）        \n\t- 误导性注释        \n\t- 循规式注释（例如：要求每个函数都要像API文档一样写一套注释来说明函数作用，参数意义。）        \n\t- 日志式注释（之前不是说光维护代码，不维护注释吗？现在我维护注释，而且把每次修改的时间、内容都加上。有那时间干啥不好，100行的文件，80行注释日志？）        \n\t- 归属与署名        \n\t- 注释掉的代码（除了注释的人，其他人都不敢删的东西）        \n\t- 信息过多，无条理\n<br/>\n\n### 第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)\n- 用空白行来区分你的模块\n- 关系应该密切的东西：        \n\t- 变量声明，应该尽可能的靠近其使用位置        \n\t- 实体变量，应该在类的顶部声明        \n\t- 相关函数，函数A调用了函数B，应该让A和B放到一起，A尽可能的放在B的上面        \n\t- 概念相关，概念相关的代码 应该放在一起，相关性与距离成正比\n- 尽量让代码行短小，最好以80个字符为上限，但最多不要超过120\n- 水平方向上的区隔：        \n\t- 赋值操作周围加上空格        \n\t- 不在函数名和左圆括号之间加空格        \n\t- 逗号后加空格       \n\t- 加减周围加空格，优先级高的乘除周围不加空格；当然，如果只有优先级相同的运算符，还是可以在周围加空格的\n<br/>\n\n### 第六章、 关于对象与数据结构\n- 不要将类内变量设置为私有，然后又添加赋值器和取值器，将它公之于众\n- 对象与数据结构之间的二分原理：        \n\t- 过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，        \n\t- 面向对象代码便于在不改动既有函数的前提下添加新类    \n反过来说就是：        \n\t- 过程代码难以添加新数据结构，因为必须修改所有函数        \n\t- 面向对象代码难以添加新函数，因为必须修改所有类\n- Demeter律，模块不应了解它所操作对象的内部情形\n- 最为精炼的数据结构，是一个只有公共变量、没有函数的类\n<br/>\n\n### 第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\n- 使用异常处理而非返回错误码\n- 先写出 try-catch-finally语句\n- 给出异常发生的环境说明，方便定位\n- 依调用者需要定义异常类\n- 不要返回、传递NULL值\n<br/>\n\n### 第八章、关于边界（将其他代码整合到自己代码中）\n- 使用类似Map的边界接口，就把它保留在类或近亲类中；避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。\n- 学习性测试很有必要\n<br/>\n\n### 第九章、关于单元测试\n- TDD（测试驱动开发）三定律：        \n\t- 在编写不能通过的单元测试前，不可编写生产代码        \n\t- 只可编写刚好无法通过的单元测试，不能编译也算不通过        \n\t- 只可编写刚好足以通过当前失败测试的生产代码\n- 脏测试 等同于 没测试\n- 测试代码与生产代码一样重要，它需要被思考、被设计和被照料，它该像生产代码一样保持整洁。\n- 整洁的测试的要素 \t- 可读性！！！\n- 整洁测试的五条规则 \t- FIRST        \n\t- F：Fast，测试应该能够快速的运行。        \n\t- I：Independent，测试应该相互独立。        \n\t- R：Repeatable，测试应该可以在任何环境中重复通过。        \n\t- S：Self-Validating，测试应该有布尔值输出。        \n\t- T：Timely，测试应及时编写。\n<br/>\n\n### 第十章、关于类\n- 类应该由一组变量列表开始，公共静态常量优先于私有静态变量\n- 类应该通函数一样要短小\n- 类或模块应有且只有一条加以修改的理由\n- 单一全责：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个全责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为\n- 内聚：类应该只有少量实体变量\n- 既然修改会一直持续，那么就更应该对类加以组织，以降低修改的风险\n- 类应当依赖于抽象而不是依赖于具体细节\n<br/>\n\n### 第十一章、关于系统\n- 软件系统应将起始过程与之后的运行时逻辑分离开。    就比如我做一个玩家信息面板，在起始过程，需要创建很多Text、Image来存储玩家一些状态信息及玩家的形象。    但是，我用这个界面的时候，只需要改动里面的值、或者切换形象。    \n这时，就可以有两个函数，init来负责起始过程的创建；refresh来负责更新玩家的状态。（当然不能把所有具体实现都放在一个函数里，每个函数负责一个小模块是必要的）\n- 软件系统与物理系统可以类比，它们的架构都可以递增式地增长，只要我们持续将关注面恰当的切分。\n- 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言）对象实现。不同领域之间用最不具有亲还行的方面或类方面工具整合起来。\n<br/>\n\n### 第十二章、关于迭代\n- Kent Beck关于简单设计的四条规则    \n\t- 运行所有测试    \n\t- 不可重复    \n\t- 表达了程序员的意图    \n\t- 尽可能减少类和方法的数量    \n\t以上规则按其重要程度排列\n- 遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计。\n- 测试消除了对清理代码就会破坏代码的恐惧，所以可以放心的去重构。\n- 重复是良好系统设计的大敌，它代表着额外工作、额外风险和额外且不必要的复杂度。\n- 增强表达力方法：    \n\t- 选用好的名称    \n\t- 保持函数和类的尺寸短小    \n\t- 采用标准命名法    \n\t- 编写良好的单元测试    \n\t- 最重要的就是去尝试去做\n- 尽可能减少类和方法的数量，这条规则优先级是最低的，要让步于测试、消除重复和增强表达力。\n<br/>\n\n### 第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\n- 并发是一种解耦策略，它将**目的**和**时机**分解开，而在单线程中，两者紧密耦合。\n- 解耦目的与时机可以显著的改进程序的**吞吐量**和**结构**\n- 一些迷思与误解    \n\t- 并发总能改进系能。    并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。    \n\t- 编写并发程序无需修改设计。    并发算法的设计有可能与单线程系统的设计极不相同，解耦目的与时机往往对系统结构产生巨大的影响。    \n\t- 在采用Web或EJB容器的时候，理解并发问题并不重要。    只有了解容器的运作，才可以对其产生的并发问题更好的解决。\n- 关于并发编程的中肯理解    \n\t- 并发会在性能和编写额外代码上增加一些开销    \n\t- 正确的并发是复杂的，即便对于简单的问题也是如此    \n\t-并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待   \n\t- 并发常常需要对设计策略的根本性修改\n- 防御并发代码问题的原则与技巧    \n\t- 单一权责原则（SRP)    \n\t分离并发相关代码与其他代码    \n\t- 限制数据作用域    \n\t谨记数据封装，严格限制对可能被共享的数据的访问    \n\t- 使用数据复本    从多个线程收集所有复本的结果，并在单个线程中合并这些结果    \n\t- 线程应尽可能的独立    尝试将数据分解到可被独立线程（可能在不同的处理器上）操作的独立子集\n- 一些基础定义    \n\t- 限定资源    \n\t并发环境中有着固定尺寸或数量的资源。    \n\t- 互斥    \n\t每一时刻仅有一个线程能访问共享数据或共享资源。    \n\t- 线程饥饿    \n\t一个或一组线程在很长时间内或永久被禁止。    \n\t- 死锁    \n\t两个或多个线程互相等待执行结束。    \n\t- 活锁    \n\t执行次序一致的线程，每个都想要起步，但发现其他线程已开始。\n- 一些执行模型    \n\t- 生产者-消费者模型    \n\t一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。    \n\t- 读者-作者模型    \n\t当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累计。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一个辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。    \n\t- 经典的哲学家    一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。桌面中央摆着一大碗意大利面。每个哲学家在吃饭的时候都要拿起叉子吃饭。但除非手上有两把叉子，否则没法进食。如果左边或右边的哲学家已经取用一把叉子，中间这位就需要等到别人吃完，放回叉子。每位哲学家吃完后，就将两把叉子放回桌面，直到下次吃饭。\n- 避免使用一个共享对象的多个方法。当不得不使用时，写代码需要注意的方法。    \n\t- 基于客户端的锁定    \n\t客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。    \n\t- 基于服务端的锁定    \n\t在服务端创建锁定服务端的方法，调用所有方法，然后解锁。让客户端调用新方法。    \n\t- 适配服务端    \n\t创建执行锁定的中间层。这是一种基于服务端锁定的例子，但不修改原始服务端代码。\n- 尽可能减小同步区域\n- 尽早考虑关闭问题，尽早令其工作正常\n- 编写测试，测试线程代码\n关于测试代码的建议    \n\t- 将伪失败看做可能的线程问题    \n\t- 先使非线程代码可工作    \n\t- 编写可插拔的线程代码    \n\t- 编写可调整的线程代码    \n\t- 运行多于处理器数量的线程    \n\t- 在不同平台上运行    \n\t- 调整代码并强迫错误发生\n<br/>\n\n#### 第十四章、关于逐步改进\n- 要编写整洁代码，必须先写肮脏代码，然后清理它。\n所以，不要害怕写的肮脏，只要去清理，就可以写出整洁的代码。\n但是，一定要去**清理它**！\n- 在改进程序过程中，要保持系统始终可以运行\n- 进度可以重订，需求可以重新定义，团队动态可以修正，但糟糕的代码只是一直腐败发酵，无情的拖后腿\n<br/>\n\n#### 第十七章、味道与启发\n- 注释    \n\t- 不恰当的信息    \n\t让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。    \n\t- 废弃的注释    \n\t过时、无关或不正确的注释就是废弃的注释。    \n\t- 冗余注释 \n\t如果描述的是某种充分自我描述了的东西，那么注释就是多余的。    \n\t- 糟糕的注释    \n\t值得编写的注释，也值得好好写。不要画蛇添足，要保持整洁。    \n\t- 注释掉的代码    \n\t看到注释掉的代码，就删除它！\n\t源代码控制系统还会记得他，让注释的人回去找。    \n\t什么？不用源代码控制系统？    \n\t好吧，你已经不需要读这本书了。\n- 环境    \n\t- 需要多步才能实现的构建    \n\t构建系统应该是单步的小操作。    \n\t不应该从源代码控制系统中一点点签出代码；    \n\t不应该需要一系列神秘指令或环境依赖脚本来构建单个元素；    \n\t不应该四处寻找额外小JAR、XML文件和其他杂物；   \n\t应该能用单个命令签出系统，并用单个指令构建它。    \n\t- 需要多步才能做到的测试    \n\t应该能发出单个指令就可以运行全部单元测试。\n- 函数    \n\t- 过多的参数    \n\t函数的参数量应该少，三个以上绝对不可容忍。    \n\t- 输出参数    \n\t输出参数违反直觉，读者期望参数用于输入而非输出。    \n\t- 标识参数    \n\t布尔值参数等同于宣告该函数做了不知一件事，应该消灭。    \n\t- 死函数\n\t永不被调用的方法应该被丢弃。\n\t不要怕删除，源代码控制系统会帮你记住它。\n- 一般性问题    \n\t- 一个源文件中存在多种语言    \n\t理想的源文件包括且只包括一种语言，\n\t现实中，应该尽力减少源文件中额外语言的数量和范围。    \n\t- 明显的行为未被实现    \n\t遵循\"最小惊异原则\"，函数或类应该实现其他程序员有理由期待的行为。    \n\t- 不正确的边界行为    \n\t不要让代码只是能工作，应该追索每种边界条件，并编写测试。    \n\t- 忽视安全    \n\t关闭某些编译器警告，可能有助于构建；但更存在无穷无尽的调试风险。    \n\t- 重复    \n\t本书最重要的规则之一    \n\t尽可能找到并消除重复。    \n\t- 在错误的抽象层级上的代码    \n\t创建分离较高层级一般性概念与较低层级细节概念的抽象模型。    \n\t- 基类依赖于派生类    \n\t将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类概念。    \n\t- 信息过多    \n\t设计良好的模块有着非常小的接口，让你事半功倍。    \n\t设计低劣的模块有着广阔、深入的接口，让你事倍功半。    \n\t设计良好的接口并不提供许多需要依靠的函数，所以耦合度也较低。    \n\t设计低劣的接口提供大量必须调用的函数，耦合度较高。    \n\t- 死代码    \n\t死代码就是不执行的代码，可以在        \n\t\t- 不会发生的条件语句中        \n\t\t- 从不抛出异常的try语句的catch块中        \n\t\t- 在永久不会发生的switch/case条件中 \n\t\n\t找到这些代码。    \n\t然后，埋葬它！    \n\t- 垂直分隔    \n\t变量和函数应该在被靠近使用的地方定义。    \n\t私有函数应该刚好在其首次被使用的位置下面定义。    \n\t- 前后不一致    \n\t最小惊异原则，小心选择约定，一旦选中，就应该持续的遵循。    \n\t- 使用解释性变量名、函数名、类名    \n\t- 把逻辑依赖改为物理依赖    \n\t依赖者模块不应对被依赖者模块有假定，应该明确的询问候着全部信息。    \n\t- 用多态替代 if/else 或 switch/case    \n\t- 用命名常量替代魔术数    \n\t- 封装条件、边界    \n\t- 函数只做一件事\n- 关于类    \n\t- import package.*;  比80行的导入语句好看多了     \n\t- 不要继承常量\n- 名称    \n\t- 采用描述性的名称    \n\t- 名称应与抽象层级相符    \n\t- 尽可能用标准命名法    \n\t- 无歧义的名称    \n\t- 为较大作用范围选用较长名称    \n\t- 避免编码    \n\t- 名称应该说明副作用\n- 测试    \n\t- 多测试    \n\t- 使用覆盖率工具    \n\t- 别略过小测试    \n\t- 被忽略的测试就是对不确定事物的疑问    \n\t- 测试边界条件    \n\t- 全面测试相近的缺陷    \n\t- 测试应该快速\n<br/>\n<br/>\n\n#### 本书总结\n终于把这本书啃完了。\n虽然作者比较啰嗦点，但是收获还是很大的。\n书中提到的，有些已经做到了；\n但有些不仅没做到，还是反面教材。\n多规范一下自己的代码，毕竟对于我们来说，代码的清晰度、整洁度还是很重要的。\n代码总要给别人看的，不要让自己的代码羞以示人。","slug":"《代码的整洁之道》读记","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabj50029veuehjh3z0vc","content":"<hr>\n<p>读这本书之前做了一些功课，很多人反映，书是一本好书，无奈作者废话太多。。。<br>刚开始，我是不信的，但自己读下来才发现，古人诚不欺我啊。<br>来划一下重点吧，写的这些或者是作者所描述的重点，或者是我感触比较深的东西。</p>\n<p><strong>Later equals never！</strong><br><strong>稍后等于永不！</strong></p>\n<a id=\"more\"></a>\n<p><br></p>\n<h3 id=\"第一章、关于整洁的代码\"><a href=\"#第一章、关于整洁的代码\" class=\"headerlink\" title=\"第一章、关于整洁的代码\"></a>第一章、关于整洁的代码</h3><ul>\n<li>代码的逻辑应该直截了当，让缺陷难以隐藏；尽量去减少依赖关系，从而便于维护；依据某种分层战略完善错误处理代码；性能调到最优，避免他人污染。</li>\n<li>糟糕的代码会引发混乱，别人修改糟糕的代码时，往往会越改越烂。</li>\n<li>每个函数、每个类、每个模块 都全神贯注去解决一件事</li>\n<li>代码应该通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。</li>\n<li>重要顺序：         <ul>\n<li>能通过所有测试        </li>\n<li>没有重复代码         </li>\n<li>体现系统中的全部设计理念         </li>\n<li>包括尽量少的实体<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二章、关于命名\"><a href=\"#第二章、关于命名\" class=\"headerlink\" title=\"第二章、关于命名\"></a>第二章、关于命名</h3><ul>\n<li>名副其实，见名知意</li>\n<li>使用可以读的出来的、可以被搜索的名称</li>\n<li>匈牙利命名法、去掉成员前缀</li>\n<li>类名、对象名 应该是名词或名词短语；    方法名应该是动词或动词短语</li>\n<li>不要抖机灵，每个概念对应一个词，不用双关语（add、insert）</li>\n<li>分离解决方案领域和问题领域的概念，与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称</li>\n<li>添加有意义的语境<br><br></li>\n</ul>\n<h3 id=\"第三章、关于函数\"><a href=\"#第三章、关于函数\" class=\"headerlink\" title=\"第三章、关于函数\"></a>第三章、关于函数</h3><ul>\n<li>函数的第一规则是短小，第二条规则是更短小！</li>\n<li>第一章节有提到过的： 每个函数尽量只做一件事。</li>\n<li>自顶向下阅读代码，向下规则</li>\n<li>函数参数，最理想为零，其次单参、双参、三参…（除非有足够特殊的理由，不要三参数+）</li>\n<li>不要向函数传入bool，因为这叫要求该函数不止做一件事</li>\n<li>不要有副作用，比如让你洗个苹果，你别洗完了然后吃了它。</li>\n<li>普遍而言，应避免使用输出参数。</li>\n<li>分隔指令与询问，要么让它干什么，要么让它回答什么。<br><br></li>\n</ul>\n<h3 id=\"第四章、关于注释-（别给糟糕的代码加注释，重新写吧！）\"><a href=\"#第四章、关于注释-（别给糟糕的代码加注释，重新写吧！）\" class=\"headerlink\" title=\"第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）\"></a>第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）</h3><ul>\n<li>代码会一直被维护更新，但是注释不一定。</li>\n<li>注释不能改变根本问题，它不能优化糟糕的代码。</li>\n<li>值得写的注释：       <ul>\n<li>版权及著作权声明等        </li>\n<li>对你的意图的解释        </li>\n<li>警示        </li>\n<li>TODO注释，为以后编写查找方便</li>\n</ul>\n</li>\n<li>废注释：        <ul>\n<li>没有规范化，过于局部的注释（需要纵览全文，才能知晓其意）        </li>\n<li>多余的注释（ getMaxNumber(num1, num2) ,还需要写这个函数是干啥的吗？）        </li>\n<li>误导性注释        </li>\n<li>循规式注释（例如：要求每个函数都要像API文档一样写一套注释来说明函数作用，参数意义。）        </li>\n<li>日志式注释（之前不是说光维护代码，不维护注释吗？现在我维护注释，而且把每次修改的时间、内容都加上。有那时间干啥不好，100行的文件，80行注释日志？）        </li>\n<li>归属与署名        </li>\n<li>注释掉的代码（除了注释的人，其他人都不敢删的东西）        </li>\n<li>信息过多，无条理<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第五章、关于格式-代码的格式是你代码的普通话，别让他说方言\"><a href=\"#第五章、关于格式-代码的格式是你代码的普通话，别让他说方言\" class=\"headerlink\" title=\"第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)\"></a>第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)</h3><ul>\n<li>用空白行来区分你的模块</li>\n<li>关系应该密切的东西：        <ul>\n<li>变量声明，应该尽可能的靠近其使用位置        </li>\n<li>实体变量，应该在类的顶部声明        </li>\n<li>相关函数，函数A调用了函数B，应该让A和B放到一起，A尽可能的放在B的上面        </li>\n<li>概念相关，概念相关的代码 应该放在一起，相关性与距离成正比</li>\n</ul>\n</li>\n<li>尽量让代码行短小，最好以80个字符为上限，但最多不要超过120</li>\n<li>水平方向上的区隔：        <ul>\n<li>赋值操作周围加上空格        </li>\n<li>不在函数名和左圆括号之间加空格        </li>\n<li>逗号后加空格       </li>\n<li>加减周围加空格，优先级高的乘除周围不加空格；当然，如果只有优先级相同的运算符，还是可以在周围加空格的<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第六章、-关于对象与数据结构\"><a href=\"#第六章、-关于对象与数据结构\" class=\"headerlink\" title=\"第六章、 关于对象与数据结构\"></a>第六章、 关于对象与数据结构</h3><ul>\n<li>不要将类内变量设置为私有，然后又添加赋值器和取值器，将它公之于众</li>\n<li>对象与数据结构之间的二分原理：        <ul>\n<li>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，        </li>\n<li>面向对象代码便于在不改动既有函数的前提下添加新类<br>反过来说就是：        </li>\n<li>过程代码难以添加新数据结构，因为必须修改所有函数        </li>\n<li>面向对象代码难以添加新函数，因为必须修改所有类</li>\n</ul>\n</li>\n<li>Demeter律，模块不应了解它所操作对象的内部情形</li>\n<li>最为精炼的数据结构，是一个只有公共变量、没有函数的类<br><br></li>\n</ul>\n<h3 id=\"第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\"><a href=\"#第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\" class=\"headerlink\" title=\"第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\"></a>第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）</h3><ul>\n<li>使用异常处理而非返回错误码</li>\n<li>先写出 try-catch-finally语句</li>\n<li>给出异常发生的环境说明，方便定位</li>\n<li>依调用者需要定义异常类</li>\n<li>不要返回、传递NULL值<br><br></li>\n</ul>\n<h3 id=\"第八章、关于边界（将其他代码整合到自己代码中）\"><a href=\"#第八章、关于边界（将其他代码整合到自己代码中）\" class=\"headerlink\" title=\"第八章、关于边界（将其他代码整合到自己代码中）\"></a>第八章、关于边界（将其他代码整合到自己代码中）</h3><ul>\n<li>使用类似Map的边界接口，就把它保留在类或近亲类中；避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。</li>\n<li>学习性测试很有必要<br><br></li>\n</ul>\n<h3 id=\"第九章、关于单元测试\"><a href=\"#第九章、关于单元测试\" class=\"headerlink\" title=\"第九章、关于单元测试\"></a>第九章、关于单元测试</h3><ul>\n<li>TDD（测试驱动开发）三定律：        <ul>\n<li>在编写不能通过的单元测试前，不可编写生产代码        </li>\n<li>只可编写刚好无法通过的单元测试，不能编译也算不通过        </li>\n<li>只可编写刚好足以通过当前失败测试的生产代码</li>\n</ul>\n</li>\n<li>脏测试 等同于 没测试</li>\n<li>测试代码与生产代码一样重要，它需要被思考、被设计和被照料，它该像生产代码一样保持整洁。</li>\n<li>整洁的测试的要素     - 可读性！！！</li>\n<li>整洁测试的五条规则     - FIRST        <ul>\n<li>F：Fast，测试应该能够快速的运行。        </li>\n<li>I：Independent，测试应该相互独立。        </li>\n<li>R：Repeatable，测试应该可以在任何环境中重复通过。        </li>\n<li>S：Self-Validating，测试应该有布尔值输出。        </li>\n<li>T：Timely，测试应及时编写。<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第十章、关于类\"><a href=\"#第十章、关于类\" class=\"headerlink\" title=\"第十章、关于类\"></a>第十章、关于类</h3><ul>\n<li>类应该由一组变量列表开始，公共静态常量优先于私有静态变量</li>\n<li>类应该通函数一样要短小</li>\n<li>类或模块应有且只有一条加以修改的理由</li>\n<li>单一全责：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个全责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为</li>\n<li>内聚：类应该只有少量实体变量</li>\n<li>既然修改会一直持续，那么就更应该对类加以组织，以降低修改的风险</li>\n<li>类应当依赖于抽象而不是依赖于具体细节<br><br></li>\n</ul>\n<h3 id=\"第十一章、关于系统\"><a href=\"#第十一章、关于系统\" class=\"headerlink\" title=\"第十一章、关于系统\"></a>第十一章、关于系统</h3><ul>\n<li>软件系统应将起始过程与之后的运行时逻辑分离开。    就比如我做一个玩家信息面板，在起始过程，需要创建很多Text、Image来存储玩家一些状态信息及玩家的形象。    但是，我用这个界面的时候，只需要改动里面的值、或者切换形象。<br>这时，就可以有两个函数，init来负责起始过程的创建；refresh来负责更新玩家的状态。（当然不能把所有具体实现都放在一个函数里，每个函数负责一个小模块是必要的）</li>\n<li>软件系统与物理系统可以类比，它们的架构都可以递增式地增长，只要我们持续将关注面恰当的切分。</li>\n<li>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言）对象实现。不同领域之间用最不具有亲还行的方面或类方面工具整合起来。<br><br></li>\n</ul>\n<h3 id=\"第十二章、关于迭代\"><a href=\"#第十二章、关于迭代\" class=\"headerlink\" title=\"第十二章、关于迭代\"></a>第十二章、关于迭代</h3><ul>\n<li>Kent Beck关于简单设计的四条规则    <ul>\n<li>运行所有测试    </li>\n<li>不可重复    </li>\n<li>表达了程序员的意图    </li>\n<li>尽可能减少类和方法的数量<br>以上规则按其重要程度排列</li>\n</ul>\n</li>\n<li>遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计。</li>\n<li>测试消除了对清理代码就会破坏代码的恐惧，所以可以放心的去重构。</li>\n<li>重复是良好系统设计的大敌，它代表着额外工作、额外风险和额外且不必要的复杂度。</li>\n<li>增强表达力方法：    <ul>\n<li>选用好的名称    </li>\n<li>保持函数和类的尺寸短小    </li>\n<li>采用标准命名法    </li>\n<li>编写良好的单元测试    </li>\n<li>最重要的就是去尝试去做</li>\n</ul>\n</li>\n<li>尽可能减少类和方法的数量，这条规则优先级是最低的，要让步于测试、消除重复和增强表达力。<br><br></li>\n</ul>\n<h3 id=\"第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\"><a href=\"#第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\" class=\"headerlink\" title=\"第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\"></a>第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）</h3><ul>\n<li>并发是一种解耦策略，它将<strong>目的</strong>和<strong>时机</strong>分解开，而在单线程中，两者紧密耦合。</li>\n<li>解耦目的与时机可以显著的改进程序的<strong>吞吐量</strong>和<strong>结构</strong></li>\n<li>一些迷思与误解    <ul>\n<li>并发总能改进系能。    并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。    </li>\n<li>编写并发程序无需修改设计。    并发算法的设计有可能与单线程系统的设计极不相同，解耦目的与时机往往对系统结构产生巨大的影响。    </li>\n<li>在采用Web或EJB容器的时候，理解并发问题并不重要。    只有了解容器的运作，才可以对其产生的并发问题更好的解决。</li>\n</ul>\n</li>\n<li>关于并发编程的中肯理解    <ul>\n<li>并发会在性能和编写额外代码上增加一些开销    </li>\n<li>正确的并发是复杂的，即便对于简单的问题也是如此<br>-并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待   </li>\n<li>并发常常需要对设计策略的根本性修改</li>\n</ul>\n</li>\n<li>防御并发代码问题的原则与技巧    <ul>\n<li>单一权责原则（SRP)<br>分离并发相关代码与其他代码    </li>\n<li>限制数据作用域<br>谨记数据封装，严格限制对可能被共享的数据的访问    </li>\n<li>使用数据复本    从多个线程收集所有复本的结果，并在单个线程中合并这些结果    </li>\n<li>线程应尽可能的独立    尝试将数据分解到可被独立线程（可能在不同的处理器上）操作的独立子集</li>\n</ul>\n</li>\n<li>一些基础定义    <ul>\n<li>限定资源<br>并发环境中有着固定尺寸或数量的资源。    </li>\n<li>互斥<br>每一时刻仅有一个线程能访问共享数据或共享资源。    </li>\n<li>线程饥饿<br>一个或一组线程在很长时间内或永久被禁止。    </li>\n<li>死锁<br>两个或多个线程互相等待执行结束。    </li>\n<li>活锁<br>执行次序一致的线程，每个都想要起步，但发现其他线程已开始。</li>\n</ul>\n</li>\n<li>一些执行模型    <ul>\n<li>生产者-消费者模型<br>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。    </li>\n<li>读者-作者模型<br>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累计。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一个辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。    </li>\n<li>经典的哲学家    一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。桌面中央摆着一大碗意大利面。每个哲学家在吃饭的时候都要拿起叉子吃饭。但除非手上有两把叉子，否则没法进食。如果左边或右边的哲学家已经取用一把叉子，中间这位就需要等到别人吃完，放回叉子。每位哲学家吃完后，就将两把叉子放回桌面，直到下次吃饭。</li>\n</ul>\n</li>\n<li>避免使用一个共享对象的多个方法。当不得不使用时，写代码需要注意的方法。    <ul>\n<li>基于客户端的锁定<br>客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。    </li>\n<li>基于服务端的锁定<br>在服务端创建锁定服务端的方法，调用所有方法，然后解锁。让客户端调用新方法。    </li>\n<li>适配服务端<br>创建执行锁定的中间层。这是一种基于服务端锁定的例子，但不修改原始服务端代码。</li>\n</ul>\n</li>\n<li>尽可能减小同步区域</li>\n<li>尽早考虑关闭问题，尽早令其工作正常</li>\n<li>编写测试，测试线程代码<br>关于测试代码的建议    <ul>\n<li>将伪失败看做可能的线程问题    </li>\n<li>先使非线程代码可工作    </li>\n<li>编写可插拔的线程代码    </li>\n<li>编写可调整的线程代码    </li>\n<li>运行多于处理器数量的线程    </li>\n<li>在不同平台上运行    </li>\n<li>调整代码并强迫错误发生<br><br></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"第十四章、关于逐步改进\"><a href=\"#第十四章、关于逐步改进\" class=\"headerlink\" title=\"第十四章、关于逐步改进\"></a>第十四章、关于逐步改进</h4><ul>\n<li>要编写整洁代码，必须先写肮脏代码，然后清理它。<br>所以，不要害怕写的肮脏，只要去清理，就可以写出整洁的代码。<br>但是，一定要去<strong>清理它</strong>！</li>\n<li>在改进程序过程中，要保持系统始终可以运行</li>\n<li>进度可以重订，需求可以重新定义，团队动态可以修正，但糟糕的代码只是一直腐败发酵，无情的拖后腿<br><br></li>\n</ul>\n<h4 id=\"第十七章、味道与启发\"><a href=\"#第十七章、味道与启发\" class=\"headerlink\" title=\"第十七章、味道与启发\"></a>第十七章、味道与启发</h4><ul>\n<li>注释    <ul>\n<li>不恰当的信息<br>让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。    </li>\n<li>废弃的注释<br>过时、无关或不正确的注释就是废弃的注释。    </li>\n<li>冗余注释<br>如果描述的是某种充分自我描述了的东西，那么注释就是多余的。    </li>\n<li>糟糕的注释<br>值得编写的注释，也值得好好写。不要画蛇添足，要保持整洁。    </li>\n<li>注释掉的代码<br>看到注释掉的代码，就删除它！<br>源代码控制系统还会记得他，让注释的人回去找。<br>什么？不用源代码控制系统？<br>好吧，你已经不需要读这本书了。</li>\n</ul>\n</li>\n<li>环境    <ul>\n<li>需要多步才能实现的构建<br>构建系统应该是单步的小操作。<br>不应该从源代码控制系统中一点点签出代码；<br>不应该需要一系列神秘指令或环境依赖脚本来构建单个元素；<br>不应该四处寻找额外小JAR、XML文件和其他杂物；<br>应该能用单个命令签出系统，并用单个指令构建它。    </li>\n<li>需要多步才能做到的测试<br>应该能发出单个指令就可以运行全部单元测试。</li>\n</ul>\n</li>\n<li>函数    <ul>\n<li>过多的参数<br>函数的参数量应该少，三个以上绝对不可容忍。    </li>\n<li>输出参数<br>输出参数违反直觉，读者期望参数用于输入而非输出。    </li>\n<li>标识参数<br>布尔值参数等同于宣告该函数做了不知一件事，应该消灭。    </li>\n<li>死函数<br>永不被调用的方法应该被丢弃。<br>不要怕删除，源代码控制系统会帮你记住它。</li>\n</ul>\n</li>\n<li><p>一般性问题    </p>\n<ul>\n<li>一个源文件中存在多种语言<br>理想的源文件包括且只包括一种语言，<br>现实中，应该尽力减少源文件中额外语言的数量和范围。    </li>\n<li>明显的行为未被实现<br>遵循”最小惊异原则”，函数或类应该实现其他程序员有理由期待的行为。    </li>\n<li>不正确的边界行为<br>不要让代码只是能工作，应该追索每种边界条件，并编写测试。    </li>\n<li>忽视安全<br>关闭某些编译器警告，可能有助于构建；但更存在无穷无尽的调试风险。    </li>\n<li>重复<br>本书最重要的规则之一<br>尽可能找到并消除重复。    </li>\n<li>在错误的抽象层级上的代码<br>创建分离较高层级一般性概念与较低层级细节概念的抽象模型。    </li>\n<li>基类依赖于派生类<br>将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类概念。    </li>\n<li>信息过多<br>设计良好的模块有着非常小的接口，让你事半功倍。<br>设计低劣的模块有着广阔、深入的接口，让你事倍功半。<br>设计良好的接口并不提供许多需要依靠的函数，所以耦合度也较低。<br>设计低劣的接口提供大量必须调用的函数，耦合度较高。    </li>\n<li><p>死代码<br>死代码就是不执行的代码，可以在        </p>\n<ul>\n<li>不会发生的条件语句中        </li>\n<li>从不抛出异常的try语句的catch块中        </li>\n<li>在永久不会发生的switch/case条件中 </li>\n</ul>\n<p>找到这些代码。<br>然后，埋葬它！    </p>\n</li>\n<li>垂直分隔<br>变量和函数应该在被靠近使用的地方定义。<br>私有函数应该刚好在其首次被使用的位置下面定义。    </li>\n<li>前后不一致<br>最小惊异原则，小心选择约定，一旦选中，就应该持续的遵循。    </li>\n<li>使用解释性变量名、函数名、类名    </li>\n<li>把逻辑依赖改为物理依赖<br>依赖者模块不应对被依赖者模块有假定，应该明确的询问候着全部信息。    </li>\n<li>用多态替代 if/else 或 switch/case    </li>\n<li>用命名常量替代魔术数    </li>\n<li>封装条件、边界    </li>\n<li>函数只做一件事</li>\n</ul>\n</li>\n<li>关于类    <ul>\n<li>import package.*;  比80行的导入语句好看多了     </li>\n<li>不要继承常量</li>\n</ul>\n</li>\n<li>名称    <ul>\n<li>采用描述性的名称    </li>\n<li>名称应与抽象层级相符    </li>\n<li>尽可能用标准命名法    </li>\n<li>无歧义的名称    </li>\n<li>为较大作用范围选用较长名称    </li>\n<li>避免编码    </li>\n<li>名称应该说明副作用</li>\n</ul>\n</li>\n<li>测试    <ul>\n<li>多测试    </li>\n<li>使用覆盖率工具    </li>\n<li>别略过小测试    </li>\n<li>被忽略的测试就是对不确定事物的疑问    </li>\n<li>测试边界条件    </li>\n<li>全面测试相近的缺陷    </li>\n<li>测试应该快速<br><br><br><br></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"本书总结\"><a href=\"#本书总结\" class=\"headerlink\" title=\"本书总结\"></a>本书总结</h4><p>终于把这本书啃完了。<br>虽然作者比较啰嗦点，但是收获还是很大的。<br>书中提到的，有些已经做到了；<br>但有些不仅没做到，还是反面教材。<br>多规范一下自己的代码，毕竟对于我们来说，代码的清晰度、整洁度还是很重要的。<br>代码总要给别人看的，不要让自己的代码羞以示人。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>读这本书之前做了一些功课，很多人反映，书是一本好书，无奈作者废话太多。。。<br>刚开始，我是不信的，但自己读下来才发现，古人诚不欺我啊。<br>来划一下重点吧，写的这些或者是作者所描述的重点，或者是我感触比较深的东西。</p>\n<p><strong>Later equals never！</strong><br><strong>稍后等于永不！</strong></p>","more":"<p><br></p>\n<h3 id=\"第一章、关于整洁的代码\"><a href=\"#第一章、关于整洁的代码\" class=\"headerlink\" title=\"第一章、关于整洁的代码\"></a>第一章、关于整洁的代码</h3><ul>\n<li>代码的逻辑应该直截了当，让缺陷难以隐藏；尽量去减少依赖关系，从而便于维护；依据某种分层战略完善错误处理代码；性能调到最优，避免他人污染。</li>\n<li>糟糕的代码会引发混乱，别人修改糟糕的代码时，往往会越改越烂。</li>\n<li>每个函数、每个类、每个模块 都全神贯注去解决一件事</li>\n<li>代码应该通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。</li>\n<li>重要顺序：         <ul>\n<li>能通过所有测试        </li>\n<li>没有重复代码         </li>\n<li>体现系统中的全部设计理念         </li>\n<li>包括尽量少的实体<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二章、关于命名\"><a href=\"#第二章、关于命名\" class=\"headerlink\" title=\"第二章、关于命名\"></a>第二章、关于命名</h3><ul>\n<li>名副其实，见名知意</li>\n<li>使用可以读的出来的、可以被搜索的名称</li>\n<li>匈牙利命名法、去掉成员前缀</li>\n<li>类名、对象名 应该是名词或名词短语；    方法名应该是动词或动词短语</li>\n<li>不要抖机灵，每个概念对应一个词，不用双关语（add、insert）</li>\n<li>分离解决方案领域和问题领域的概念，与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称</li>\n<li>添加有意义的语境<br><br></li>\n</ul>\n<h3 id=\"第三章、关于函数\"><a href=\"#第三章、关于函数\" class=\"headerlink\" title=\"第三章、关于函数\"></a>第三章、关于函数</h3><ul>\n<li>函数的第一规则是短小，第二条规则是更短小！</li>\n<li>第一章节有提到过的： 每个函数尽量只做一件事。</li>\n<li>自顶向下阅读代码，向下规则</li>\n<li>函数参数，最理想为零，其次单参、双参、三参…（除非有足够特殊的理由，不要三参数+）</li>\n<li>不要向函数传入bool，因为这叫要求该函数不止做一件事</li>\n<li>不要有副作用，比如让你洗个苹果，你别洗完了然后吃了它。</li>\n<li>普遍而言，应避免使用输出参数。</li>\n<li>分隔指令与询问，要么让它干什么，要么让它回答什么。<br><br></li>\n</ul>\n<h3 id=\"第四章、关于注释-（别给糟糕的代码加注释，重新写吧！）\"><a href=\"#第四章、关于注释-（别给糟糕的代码加注释，重新写吧！）\" class=\"headerlink\" title=\"第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）\"></a>第四章、关于注释  （别给糟糕的代码加注释，重新写吧！）</h3><ul>\n<li>代码会一直被维护更新，但是注释不一定。</li>\n<li>注释不能改变根本问题，它不能优化糟糕的代码。</li>\n<li>值得写的注释：       <ul>\n<li>版权及著作权声明等        </li>\n<li>对你的意图的解释        </li>\n<li>警示        </li>\n<li>TODO注释，为以后编写查找方便</li>\n</ul>\n</li>\n<li>废注释：        <ul>\n<li>没有规范化，过于局部的注释（需要纵览全文，才能知晓其意）        </li>\n<li>多余的注释（ getMaxNumber(num1, num2) ,还需要写这个函数是干啥的吗？）        </li>\n<li>误导性注释        </li>\n<li>循规式注释（例如：要求每个函数都要像API文档一样写一套注释来说明函数作用，参数意义。）        </li>\n<li>日志式注释（之前不是说光维护代码，不维护注释吗？现在我维护注释，而且把每次修改的时间、内容都加上。有那时间干啥不好，100行的文件，80行注释日志？）        </li>\n<li>归属与署名        </li>\n<li>注释掉的代码（除了注释的人，其他人都不敢删的东西）        </li>\n<li>信息过多，无条理<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第五章、关于格式-代码的格式是你代码的普通话，别让他说方言\"><a href=\"#第五章、关于格式-代码的格式是你代码的普通话，别让他说方言\" class=\"headerlink\" title=\"第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)\"></a>第五章、关于格式    (代码的格式是你代码的普通话，别让他说方言)</h3><ul>\n<li>用空白行来区分你的模块</li>\n<li>关系应该密切的东西：        <ul>\n<li>变量声明，应该尽可能的靠近其使用位置        </li>\n<li>实体变量，应该在类的顶部声明        </li>\n<li>相关函数，函数A调用了函数B，应该让A和B放到一起，A尽可能的放在B的上面        </li>\n<li>概念相关，概念相关的代码 应该放在一起，相关性与距离成正比</li>\n</ul>\n</li>\n<li>尽量让代码行短小，最好以80个字符为上限，但最多不要超过120</li>\n<li>水平方向上的区隔：        <ul>\n<li>赋值操作周围加上空格        </li>\n<li>不在函数名和左圆括号之间加空格        </li>\n<li>逗号后加空格       </li>\n<li>加减周围加空格，优先级高的乘除周围不加空格；当然，如果只有优先级相同的运算符，还是可以在周围加空格的<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第六章、-关于对象与数据结构\"><a href=\"#第六章、-关于对象与数据结构\" class=\"headerlink\" title=\"第六章、 关于对象与数据结构\"></a>第六章、 关于对象与数据结构</h3><ul>\n<li>不要将类内变量设置为私有，然后又添加赋值器和取值器，将它公之于众</li>\n<li>对象与数据结构之间的二分原理：        <ul>\n<li>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，        </li>\n<li>面向对象代码便于在不改动既有函数的前提下添加新类<br>反过来说就是：        </li>\n<li>过程代码难以添加新数据结构，因为必须修改所有函数        </li>\n<li>面向对象代码难以添加新函数，因为必须修改所有类</li>\n</ul>\n</li>\n<li>Demeter律，模块不应了解它所操作对象的内部情形</li>\n<li>最为精炼的数据结构，是一个只有公共变量、没有函数的类<br><br></li>\n</ul>\n<h3 id=\"第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\"><a href=\"#第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\" class=\"headerlink\" title=\"第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）\"></a>第七章、关于错误处理（当错误发生时，程序员有责任确保代码照常工作）</h3><ul>\n<li>使用异常处理而非返回错误码</li>\n<li>先写出 try-catch-finally语句</li>\n<li>给出异常发生的环境说明，方便定位</li>\n<li>依调用者需要定义异常类</li>\n<li>不要返回、传递NULL值<br><br></li>\n</ul>\n<h3 id=\"第八章、关于边界（将其他代码整合到自己代码中）\"><a href=\"#第八章、关于边界（将其他代码整合到自己代码中）\" class=\"headerlink\" title=\"第八章、关于边界（将其他代码整合到自己代码中）\"></a>第八章、关于边界（将其他代码整合到自己代码中）</h3><ul>\n<li>使用类似Map的边界接口，就把它保留在类或近亲类中；避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。</li>\n<li>学习性测试很有必要<br><br></li>\n</ul>\n<h3 id=\"第九章、关于单元测试\"><a href=\"#第九章、关于单元测试\" class=\"headerlink\" title=\"第九章、关于单元测试\"></a>第九章、关于单元测试</h3><ul>\n<li>TDD（测试驱动开发）三定律：        <ul>\n<li>在编写不能通过的单元测试前，不可编写生产代码        </li>\n<li>只可编写刚好无法通过的单元测试，不能编译也算不通过        </li>\n<li>只可编写刚好足以通过当前失败测试的生产代码</li>\n</ul>\n</li>\n<li>脏测试 等同于 没测试</li>\n<li>测试代码与生产代码一样重要，它需要被思考、被设计和被照料，它该像生产代码一样保持整洁。</li>\n<li>整洁的测试的要素     - 可读性！！！</li>\n<li>整洁测试的五条规则     - FIRST        <ul>\n<li>F：Fast，测试应该能够快速的运行。        </li>\n<li>I：Independent，测试应该相互独立。        </li>\n<li>R：Repeatable，测试应该可以在任何环境中重复通过。        </li>\n<li>S：Self-Validating，测试应该有布尔值输出。        </li>\n<li>T：Timely，测试应及时编写。<br><br></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第十章、关于类\"><a href=\"#第十章、关于类\" class=\"headerlink\" title=\"第十章、关于类\"></a>第十章、关于类</h3><ul>\n<li>类应该由一组变量列表开始，公共静态常量优先于私有静态变量</li>\n<li>类应该通函数一样要短小</li>\n<li>类或模块应有且只有一条加以修改的理由</li>\n<li>单一全责：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个全责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为</li>\n<li>内聚：类应该只有少量实体变量</li>\n<li>既然修改会一直持续，那么就更应该对类加以组织，以降低修改的风险</li>\n<li>类应当依赖于抽象而不是依赖于具体细节<br><br></li>\n</ul>\n<h3 id=\"第十一章、关于系统\"><a href=\"#第十一章、关于系统\" class=\"headerlink\" title=\"第十一章、关于系统\"></a>第十一章、关于系统</h3><ul>\n<li>软件系统应将起始过程与之后的运行时逻辑分离开。    就比如我做一个玩家信息面板，在起始过程，需要创建很多Text、Image来存储玩家一些状态信息及玩家的形象。    但是，我用这个界面的时候，只需要改动里面的值、或者切换形象。<br>这时，就可以有两个函数，init来负责起始过程的创建；refresh来负责更新玩家的状态。（当然不能把所有具体实现都放在一个函数里，每个函数负责一个小模块是必要的）</li>\n<li>软件系统与物理系统可以类比，它们的架构都可以递增式地增长，只要我们持续将关注面恰当的切分。</li>\n<li>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言）对象实现。不同领域之间用最不具有亲还行的方面或类方面工具整合起来。<br><br></li>\n</ul>\n<h3 id=\"第十二章、关于迭代\"><a href=\"#第十二章、关于迭代\" class=\"headerlink\" title=\"第十二章、关于迭代\"></a>第十二章、关于迭代</h3><ul>\n<li>Kent Beck关于简单设计的四条规则    <ul>\n<li>运行所有测试    </li>\n<li>不可重复    </li>\n<li>表达了程序员的意图    </li>\n<li>尽可能减少类和方法的数量<br>以上规则按其重要程度排列</li>\n</ul>\n</li>\n<li>遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计。</li>\n<li>测试消除了对清理代码就会破坏代码的恐惧，所以可以放心的去重构。</li>\n<li>重复是良好系统设计的大敌，它代表着额外工作、额外风险和额外且不必要的复杂度。</li>\n<li>增强表达力方法：    <ul>\n<li>选用好的名称    </li>\n<li>保持函数和类的尺寸短小    </li>\n<li>采用标准命名法    </li>\n<li>编写良好的单元测试    </li>\n<li>最重要的就是去尝试去做</li>\n</ul>\n</li>\n<li>尽可能减少类和方法的数量，这条规则优先级是最低的，要让步于测试、消除重复和增强表达力。<br><br></li>\n</ul>\n<h3 id=\"第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\"><a href=\"#第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\" class=\"headerlink\" title=\"第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）\"></a>第十三章、关于并发编程（对象是过程的抽象，线程是调度的抽象）</h3><ul>\n<li>并发是一种解耦策略，它将<strong>目的</strong>和<strong>时机</strong>分解开，而在单线程中，两者紧密耦合。</li>\n<li>解耦目的与时机可以显著的改进程序的<strong>吞吐量</strong>和<strong>结构</strong></li>\n<li>一些迷思与误解    <ul>\n<li>并发总能改进系能。    并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。    </li>\n<li>编写并发程序无需修改设计。    并发算法的设计有可能与单线程系统的设计极不相同，解耦目的与时机往往对系统结构产生巨大的影响。    </li>\n<li>在采用Web或EJB容器的时候，理解并发问题并不重要。    只有了解容器的运作，才可以对其产生的并发问题更好的解决。</li>\n</ul>\n</li>\n<li>关于并发编程的中肯理解    <ul>\n<li>并发会在性能和编写额外代码上增加一些开销    </li>\n<li>正确的并发是复杂的，即便对于简单的问题也是如此<br>-并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待   </li>\n<li>并发常常需要对设计策略的根本性修改</li>\n</ul>\n</li>\n<li>防御并发代码问题的原则与技巧    <ul>\n<li>单一权责原则（SRP)<br>分离并发相关代码与其他代码    </li>\n<li>限制数据作用域<br>谨记数据封装，严格限制对可能被共享的数据的访问    </li>\n<li>使用数据复本    从多个线程收集所有复本的结果，并在单个线程中合并这些结果    </li>\n<li>线程应尽可能的独立    尝试将数据分解到可被独立线程（可能在不同的处理器上）操作的独立子集</li>\n</ul>\n</li>\n<li>一些基础定义    <ul>\n<li>限定资源<br>并发环境中有着固定尺寸或数量的资源。    </li>\n<li>互斥<br>每一时刻仅有一个线程能访问共享数据或共享资源。    </li>\n<li>线程饥饿<br>一个或一组线程在很长时间内或永久被禁止。    </li>\n<li>死锁<br>两个或多个线程互相等待执行结束。    </li>\n<li>活锁<br>执行次序一致的线程，每个都想要起步，但发现其他线程已开始。</li>\n</ul>\n</li>\n<li>一些执行模型    <ul>\n<li>生产者-消费者模型<br>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。    </li>\n<li>读者-作者模型<br>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累计。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一个辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。    </li>\n<li>经典的哲学家    一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。桌面中央摆着一大碗意大利面。每个哲学家在吃饭的时候都要拿起叉子吃饭。但除非手上有两把叉子，否则没法进食。如果左边或右边的哲学家已经取用一把叉子，中间这位就需要等到别人吃完，放回叉子。每位哲学家吃完后，就将两把叉子放回桌面，直到下次吃饭。</li>\n</ul>\n</li>\n<li>避免使用一个共享对象的多个方法。当不得不使用时，写代码需要注意的方法。    <ul>\n<li>基于客户端的锁定<br>客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。    </li>\n<li>基于服务端的锁定<br>在服务端创建锁定服务端的方法，调用所有方法，然后解锁。让客户端调用新方法。    </li>\n<li>适配服务端<br>创建执行锁定的中间层。这是一种基于服务端锁定的例子，但不修改原始服务端代码。</li>\n</ul>\n</li>\n<li>尽可能减小同步区域</li>\n<li>尽早考虑关闭问题，尽早令其工作正常</li>\n<li>编写测试，测试线程代码<br>关于测试代码的建议    <ul>\n<li>将伪失败看做可能的线程问题    </li>\n<li>先使非线程代码可工作    </li>\n<li>编写可插拔的线程代码    </li>\n<li>编写可调整的线程代码    </li>\n<li>运行多于处理器数量的线程    </li>\n<li>在不同平台上运行    </li>\n<li>调整代码并强迫错误发生<br><br></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"第十四章、关于逐步改进\"><a href=\"#第十四章、关于逐步改进\" class=\"headerlink\" title=\"第十四章、关于逐步改进\"></a>第十四章、关于逐步改进</h4><ul>\n<li>要编写整洁代码，必须先写肮脏代码，然后清理它。<br>所以，不要害怕写的肮脏，只要去清理，就可以写出整洁的代码。<br>但是，一定要去<strong>清理它</strong>！</li>\n<li>在改进程序过程中，要保持系统始终可以运行</li>\n<li>进度可以重订，需求可以重新定义，团队动态可以修正，但糟糕的代码只是一直腐败发酵，无情的拖后腿<br><br></li>\n</ul>\n<h4 id=\"第十七章、味道与启发\"><a href=\"#第十七章、味道与启发\" class=\"headerlink\" title=\"第十七章、味道与启发\"></a>第十七章、味道与启发</h4><ul>\n<li>注释    <ul>\n<li>不恰当的信息<br>让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。    </li>\n<li>废弃的注释<br>过时、无关或不正确的注释就是废弃的注释。    </li>\n<li>冗余注释<br>如果描述的是某种充分自我描述了的东西，那么注释就是多余的。    </li>\n<li>糟糕的注释<br>值得编写的注释，也值得好好写。不要画蛇添足，要保持整洁。    </li>\n<li>注释掉的代码<br>看到注释掉的代码，就删除它！<br>源代码控制系统还会记得他，让注释的人回去找。<br>什么？不用源代码控制系统？<br>好吧，你已经不需要读这本书了。</li>\n</ul>\n</li>\n<li>环境    <ul>\n<li>需要多步才能实现的构建<br>构建系统应该是单步的小操作。<br>不应该从源代码控制系统中一点点签出代码；<br>不应该需要一系列神秘指令或环境依赖脚本来构建单个元素；<br>不应该四处寻找额外小JAR、XML文件和其他杂物；<br>应该能用单个命令签出系统，并用单个指令构建它。    </li>\n<li>需要多步才能做到的测试<br>应该能发出单个指令就可以运行全部单元测试。</li>\n</ul>\n</li>\n<li>函数    <ul>\n<li>过多的参数<br>函数的参数量应该少，三个以上绝对不可容忍。    </li>\n<li>输出参数<br>输出参数违反直觉，读者期望参数用于输入而非输出。    </li>\n<li>标识参数<br>布尔值参数等同于宣告该函数做了不知一件事，应该消灭。    </li>\n<li>死函数<br>永不被调用的方法应该被丢弃。<br>不要怕删除，源代码控制系统会帮你记住它。</li>\n</ul>\n</li>\n<li><p>一般性问题    </p>\n<ul>\n<li>一个源文件中存在多种语言<br>理想的源文件包括且只包括一种语言，<br>现实中，应该尽力减少源文件中额外语言的数量和范围。    </li>\n<li>明显的行为未被实现<br>遵循”最小惊异原则”，函数或类应该实现其他程序员有理由期待的行为。    </li>\n<li>不正确的边界行为<br>不要让代码只是能工作，应该追索每种边界条件，并编写测试。    </li>\n<li>忽视安全<br>关闭某些编译器警告，可能有助于构建；但更存在无穷无尽的调试风险。    </li>\n<li>重复<br>本书最重要的规则之一<br>尽可能找到并消除重复。    </li>\n<li>在错误的抽象层级上的代码<br>创建分离较高层级一般性概念与较低层级细节概念的抽象模型。    </li>\n<li>基类依赖于派生类<br>将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类概念。    </li>\n<li>信息过多<br>设计良好的模块有着非常小的接口，让你事半功倍。<br>设计低劣的模块有着广阔、深入的接口，让你事倍功半。<br>设计良好的接口并不提供许多需要依靠的函数，所以耦合度也较低。<br>设计低劣的接口提供大量必须调用的函数，耦合度较高。    </li>\n<li><p>死代码<br>死代码就是不执行的代码，可以在        </p>\n<ul>\n<li>不会发生的条件语句中        </li>\n<li>从不抛出异常的try语句的catch块中        </li>\n<li>在永久不会发生的switch/case条件中 </li>\n</ul>\n<p>找到这些代码。<br>然后，埋葬它！    </p>\n</li>\n<li>垂直分隔<br>变量和函数应该在被靠近使用的地方定义。<br>私有函数应该刚好在其首次被使用的位置下面定义。    </li>\n<li>前后不一致<br>最小惊异原则，小心选择约定，一旦选中，就应该持续的遵循。    </li>\n<li>使用解释性变量名、函数名、类名    </li>\n<li>把逻辑依赖改为物理依赖<br>依赖者模块不应对被依赖者模块有假定，应该明确的询问候着全部信息。    </li>\n<li>用多态替代 if/else 或 switch/case    </li>\n<li>用命名常量替代魔术数    </li>\n<li>封装条件、边界    </li>\n<li>函数只做一件事</li>\n</ul>\n</li>\n<li>关于类    <ul>\n<li>import package.*;  比80行的导入语句好看多了     </li>\n<li>不要继承常量</li>\n</ul>\n</li>\n<li>名称    <ul>\n<li>采用描述性的名称    </li>\n<li>名称应与抽象层级相符    </li>\n<li>尽可能用标准命名法    </li>\n<li>无歧义的名称    </li>\n<li>为较大作用范围选用较长名称    </li>\n<li>避免编码    </li>\n<li>名称应该说明副作用</li>\n</ul>\n</li>\n<li>测试    <ul>\n<li>多测试    </li>\n<li>使用覆盖率工具    </li>\n<li>别略过小测试    </li>\n<li>被忽略的测试就是对不确定事物的疑问    </li>\n<li>测试边界条件    </li>\n<li>全面测试相近的缺陷    </li>\n<li>测试应该快速<br><br><br><br></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"本书总结\"><a href=\"#本书总结\" class=\"headerlink\" title=\"本书总结\"></a>本书总结</h4><p>终于把这本书啃完了。<br>虽然作者比较啰嗦点，但是收获还是很大的。<br>书中提到的，有些已经做到了；<br>但有些不仅没做到，还是反面教材。<br>多规范一下自己的代码，毕竟对于我们来说，代码的清晰度、整洁度还是很重要的。<br>代码总要给别人看的，不要让自己的代码羞以示人。</p>"},{"title":"《我们仨》读记","date":"2017-05-30T13:00:00.000Z","_content":"\n----------\n\n很多东西，想做，能做，却又做不到。\n\n\n<!-- more -->\n<br/>\n\n这本书，本来是为了给女朋友培养读书兴趣而买的。\n但是，发现，好像不是她的菜（虽然，她磕磕绊绊的也读完了）。\n我也就每天临睡前读一些，慢慢也读完了。\n\n<br/>\n\n《我们仨》是杨绛老师在失去自己唯一女儿与丈夫后，写的一篇回忆录。\n总共三部分：\n- 我们俩老了\n- 我们仨失散了\n- 我一个人思念我们仨\n前两部分，用一个\"万里长梦\"来委婉的表达自己所经历的这些。\n最后一部分，回忆这些年来的一切。\n\n<br/>\n\n每次拿起这本书，再浮躁的心都会平静下来，慢慢的看，慢慢的感受，慢慢的品。\n其实我对这一家并没有多少了解，只是隐约记得她们的名气很大。\n通过这本书，感受到的就是一个老人，仔细的，缓慢的回忆这一切；所用的文字、语句没有过于粉饰，很朴素，很淡然；所写的情节，详则多叙，略则少言，不空洞，很流畅。\n有几段文字，我挺喜欢的：\n1.\n我疑疑惑惑地在古驿道上一脚一脚走。柳树一年四季变化最勤。秋风刚刚一吹，柳叶就开始黄落，随着一阵一阵风，落下一批又一批叶子，冬天都变成光秃秃的寒柳。春风还没有吹，柳条上已经发芽，远看着已有绿意；柳树在春风里，就飘荡着嫩绿的长条。然后蒙蒙飞絮，要飞上一两个月。飞絮还没有飞完，柳树都已绿叶成荫。然后又一片片黄落，又变成光秃秃的寒柳。我在古驿道上，一脚一脚的，走了一年多。\n\n2.\n看动物吃东西很有趣，狮子喂肉之前，得把同笼的分开，因为狮子见了肉就不顾夫妻情分。猪类动物吃花生，连皮带壳；熊吐出壳带皮吃；猴子剥了壳还捻去皮。可是大象食肠粗，饲养员喂大象，大团的粮食、整只的苹果、整条的萝卜、连皮的香蕉，都一口吞之。可是它自己进食却很精细；吃稻草，先从大捆稻草中拈出一小束，拍打干净，筑筑整齐，才送入口中。我们断不定最聪明的是灵活的猴子还是笨重的大象。我们爱大象。\n\n<br/>\n\n最喜欢的还有书前后的书信，现在都是微信QQ的时代，看到这些书信，真的别有一番风趣。\n\n<br/>\n\"我们仨其实是最平凡不过的。我们这个家，很朴素；我们三个人，很单纯。我们与世无求，与人无争，只求相聚在一起，相守在一起，各自做力所能及的事。\"\n但是，这种最朴素最平凡的家，也是最令人羡慕的。\n即使，想去做，并且能做到，却又做不到的。\n","source":"_posts/《我们仨》读记.md","raw":"---\ntitle: 《我们仨》读记\ndate: 2017-05-30 21:00:00\ntags: 读书笔记\n---\n\n----------\n\n很多东西，想做，能做，却又做不到。\n\n\n<!-- more -->\n<br/>\n\n这本书，本来是为了给女朋友培养读书兴趣而买的。\n但是，发现，好像不是她的菜（虽然，她磕磕绊绊的也读完了）。\n我也就每天临睡前读一些，慢慢也读完了。\n\n<br/>\n\n《我们仨》是杨绛老师在失去自己唯一女儿与丈夫后，写的一篇回忆录。\n总共三部分：\n- 我们俩老了\n- 我们仨失散了\n- 我一个人思念我们仨\n前两部分，用一个\"万里长梦\"来委婉的表达自己所经历的这些。\n最后一部分，回忆这些年来的一切。\n\n<br/>\n\n每次拿起这本书，再浮躁的心都会平静下来，慢慢的看，慢慢的感受，慢慢的品。\n其实我对这一家并没有多少了解，只是隐约记得她们的名气很大。\n通过这本书，感受到的就是一个老人，仔细的，缓慢的回忆这一切；所用的文字、语句没有过于粉饰，很朴素，很淡然；所写的情节，详则多叙，略则少言，不空洞，很流畅。\n有几段文字，我挺喜欢的：\n1.\n我疑疑惑惑地在古驿道上一脚一脚走。柳树一年四季变化最勤。秋风刚刚一吹，柳叶就开始黄落，随着一阵一阵风，落下一批又一批叶子，冬天都变成光秃秃的寒柳。春风还没有吹，柳条上已经发芽，远看着已有绿意；柳树在春风里，就飘荡着嫩绿的长条。然后蒙蒙飞絮，要飞上一两个月。飞絮还没有飞完，柳树都已绿叶成荫。然后又一片片黄落，又变成光秃秃的寒柳。我在古驿道上，一脚一脚的，走了一年多。\n\n2.\n看动物吃东西很有趣，狮子喂肉之前，得把同笼的分开，因为狮子见了肉就不顾夫妻情分。猪类动物吃花生，连皮带壳；熊吐出壳带皮吃；猴子剥了壳还捻去皮。可是大象食肠粗，饲养员喂大象，大团的粮食、整只的苹果、整条的萝卜、连皮的香蕉，都一口吞之。可是它自己进食却很精细；吃稻草，先从大捆稻草中拈出一小束，拍打干净，筑筑整齐，才送入口中。我们断不定最聪明的是灵活的猴子还是笨重的大象。我们爱大象。\n\n<br/>\n\n最喜欢的还有书前后的书信，现在都是微信QQ的时代，看到这些书信，真的别有一番风趣。\n\n<br/>\n\"我们仨其实是最平凡不过的。我们这个家，很朴素；我们三个人，很单纯。我们与世无求，与人无争，只求相聚在一起，相守在一起，各自做力所能及的事。\"\n但是，这种最朴素最平凡的家，也是最令人羡慕的。\n即使，想去做，并且能做到，却又做不到的。\n","slug":"《我们仨》读记","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabj7002cveue316mdew4","content":"<hr>\n<p>很多东西，想做，能做，却又做不到。</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>这本书，本来是为了给女朋友培养读书兴趣而买的。<br>但是，发现，好像不是她的菜（虽然，她磕磕绊绊的也读完了）。<br>我也就每天临睡前读一些，慢慢也读完了。</p>\n<p><br></p>\n<p>《我们仨》是杨绛老师在失去自己唯一女儿与丈夫后，写的一篇回忆录。<br>总共三部分：</p>\n<ul>\n<li>我们俩老了</li>\n<li>我们仨失散了</li>\n<li>我一个人思念我们仨<br>前两部分，用一个”万里长梦”来委婉的表达自己所经历的这些。<br>最后一部分，回忆这些年来的一切。</li>\n</ul>\n<p><br></p>\n<p>每次拿起这本书，再浮躁的心都会平静下来，慢慢的看，慢慢的感受，慢慢的品。<br>其实我对这一家并没有多少了解，只是隐约记得她们的名气很大。<br>通过这本书，感受到的就是一个老人，仔细的，缓慢的回忆这一切；所用的文字、语句没有过于粉饰，很朴素，很淡然；所写的情节，详则多叙，略则少言，不空洞，很流畅。<br>有几段文字，我挺喜欢的：<br>1.<br>我疑疑惑惑地在古驿道上一脚一脚走。柳树一年四季变化最勤。秋风刚刚一吹，柳叶就开始黄落，随着一阵一阵风，落下一批又一批叶子，冬天都变成光秃秃的寒柳。春风还没有吹，柳条上已经发芽，远看着已有绿意；柳树在春风里，就飘荡着嫩绿的长条。然后蒙蒙飞絮，要飞上一两个月。飞絮还没有飞完，柳树都已绿叶成荫。然后又一片片黄落，又变成光秃秃的寒柳。我在古驿道上，一脚一脚的，走了一年多。</p>\n<p>2.<br>看动物吃东西很有趣，狮子喂肉之前，得把同笼的分开，因为狮子见了肉就不顾夫妻情分。猪类动物吃花生，连皮带壳；熊吐出壳带皮吃；猴子剥了壳还捻去皮。可是大象食肠粗，饲养员喂大象，大团的粮食、整只的苹果、整条的萝卜、连皮的香蕉，都一口吞之。可是它自己进食却很精细；吃稻草，先从大捆稻草中拈出一小束，拍打干净，筑筑整齐，才送入口中。我们断不定最聪明的是灵活的猴子还是笨重的大象。我们爱大象。</p>\n<p><br></p>\n<p>最喜欢的还有书前后的书信，现在都是微信QQ的时代，看到这些书信，真的别有一番风趣。</p>\n<p><br><br>“我们仨其实是最平凡不过的。我们这个家，很朴素；我们三个人，很单纯。我们与世无求，与人无争，只求相聚在一起，相守在一起，各自做力所能及的事。”<br>但是，这种最朴素最平凡的家，也是最令人羡慕的。<br>即使，想去做，并且能做到，却又做不到的。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>很多东西，想做，能做，却又做不到。</p>","more":"<p><br></p>\n<p>这本书，本来是为了给女朋友培养读书兴趣而买的。<br>但是，发现，好像不是她的菜（虽然，她磕磕绊绊的也读完了）。<br>我也就每天临睡前读一些，慢慢也读完了。</p>\n<p><br></p>\n<p>《我们仨》是杨绛老师在失去自己唯一女儿与丈夫后，写的一篇回忆录。<br>总共三部分：</p>\n<ul>\n<li>我们俩老了</li>\n<li>我们仨失散了</li>\n<li>我一个人思念我们仨<br>前两部分，用一个”万里长梦”来委婉的表达自己所经历的这些。<br>最后一部分，回忆这些年来的一切。</li>\n</ul>\n<p><br></p>\n<p>每次拿起这本书，再浮躁的心都会平静下来，慢慢的看，慢慢的感受，慢慢的品。<br>其实我对这一家并没有多少了解，只是隐约记得她们的名气很大。<br>通过这本书，感受到的就是一个老人，仔细的，缓慢的回忆这一切；所用的文字、语句没有过于粉饰，很朴素，很淡然；所写的情节，详则多叙，略则少言，不空洞，很流畅。<br>有几段文字，我挺喜欢的：<br>1.<br>我疑疑惑惑地在古驿道上一脚一脚走。柳树一年四季变化最勤。秋风刚刚一吹，柳叶就开始黄落，随着一阵一阵风，落下一批又一批叶子，冬天都变成光秃秃的寒柳。春风还没有吹，柳条上已经发芽，远看着已有绿意；柳树在春风里，就飘荡着嫩绿的长条。然后蒙蒙飞絮，要飞上一两个月。飞絮还没有飞完，柳树都已绿叶成荫。然后又一片片黄落，又变成光秃秃的寒柳。我在古驿道上，一脚一脚的，走了一年多。</p>\n<p>2.<br>看动物吃东西很有趣，狮子喂肉之前，得把同笼的分开，因为狮子见了肉就不顾夫妻情分。猪类动物吃花生，连皮带壳；熊吐出壳带皮吃；猴子剥了壳还捻去皮。可是大象食肠粗，饲养员喂大象，大团的粮食、整只的苹果、整条的萝卜、连皮的香蕉，都一口吞之。可是它自己进食却很精细；吃稻草，先从大捆稻草中拈出一小束，拍打干净，筑筑整齐，才送入口中。我们断不定最聪明的是灵活的猴子还是笨重的大象。我们爱大象。</p>\n<p><br></p>\n<p>最喜欢的还有书前后的书信，现在都是微信QQ的时代，看到这些书信，真的别有一番风趣。</p>\n<p><br><br>“我们仨其实是最平凡不过的。我们这个家，很朴素；我们三个人，很单纯。我们与世无求，与人无争，只求相聚在一起，相守在一起，各自做力所能及的事。”<br>但是，这种最朴素最平凡的家，也是最令人羡慕的。<br>即使，想去做，并且能做到，却又做不到的。</p>"},{"title":"《时间简史》读感","date":"2017-03-14T13:37:35.000Z","_content":"\n《时间简史》 读感\n\n如果不进行外加干涉,事物总是倾向于增加它的无序度。\n\n<!-- more -->\n<br/>\n\n这段时间，读了一下霍金的《时间简史》。\n这本书把我带入了一个新的世界的感觉。\n前半段，带我温习了一下高中及大学的物理（PS：这里好想吐槽，之前学物理，就是告诉你一个定理、公式，去背去做题，根本不去想为什么，或许，这就是我学的那么吃力的原因吧。）\n后面，直接就是之前没有接触过的，几乎没有认知的领域了。\n\n<br/>\n\n给我印象最深刻的几个部分：\n1. CPT守恒。通过P守恒、CP守恒到CPT守恒，可以拓展到很多东西。\n2. 时间箭头。热力学时间箭头、心理学时间箭头、宇宙学时间箭头。尤其是热力学时间箭头，就是由有序到无序的过程，熵在不断增加的过程。\n3. 时空维度。曾经我一度困扰，四维空间以上的五维空间是什么样子呢？后来才知道，说四维空间，好像不是很合适，应该是三维+一维，三个空间维度加一个时间维度。\n然后，剩下的维度是我们之上，还是我们之下呢？（也就是说我们在五维空间内，还是四维就包含了五维呢？）反正，根据M理论，宇宙由三维可见空间维+一维时间维+七维不可见空间维构成。\n4. 不确定性原理。人们永远不能同时准确知道粒子的位置和速度；对其中一个知道的越精确，则对另一个就知道的越不准确。\n5. 人择原理。我们之所以看到宇宙是这个样子，只是因为如果它不是这样，我们就不会在这里去观察它。\n\n<br/>\n\n这本书看完以后，真如醍醐灌顶。\n理顺了之前既得已知的知识，扩展了后面的知识，虽然，没有细究（也不必细究），但是有了一个了解。\n对于物之上，物之下，更深层的了解，开拓了视野。\n\n<br/>\n\n最后，\n在相对论中并没有一个唯一的绝对时间，\n每个人都有自己的时间测度，这依赖于他在何处并如何运动。\n与自己最相近的，应该是反我（任何粒子都有会和它湮灭的反粒子,也可能存在由反粒子构成的整个反世界和反人）\n然而，如果你遇到了反自身，注意不要握手！\n否则，你们两人都会在一个巨大的闪光中消失殆尽。\n","source":"_posts/《时间简史》读感.md","raw":"---\ntitle: 《时间简史》读感\ndate: 2017-03-14 21:37:35\ntags: 读书笔记\n---\n\n《时间简史》 读感\n\n如果不进行外加干涉,事物总是倾向于增加它的无序度。\n\n<!-- more -->\n<br/>\n\n这段时间，读了一下霍金的《时间简史》。\n这本书把我带入了一个新的世界的感觉。\n前半段，带我温习了一下高中及大学的物理（PS：这里好想吐槽，之前学物理，就是告诉你一个定理、公式，去背去做题，根本不去想为什么，或许，这就是我学的那么吃力的原因吧。）\n后面，直接就是之前没有接触过的，几乎没有认知的领域了。\n\n<br/>\n\n给我印象最深刻的几个部分：\n1. CPT守恒。通过P守恒、CP守恒到CPT守恒，可以拓展到很多东西。\n2. 时间箭头。热力学时间箭头、心理学时间箭头、宇宙学时间箭头。尤其是热力学时间箭头，就是由有序到无序的过程，熵在不断增加的过程。\n3. 时空维度。曾经我一度困扰，四维空间以上的五维空间是什么样子呢？后来才知道，说四维空间，好像不是很合适，应该是三维+一维，三个空间维度加一个时间维度。\n然后，剩下的维度是我们之上，还是我们之下呢？（也就是说我们在五维空间内，还是四维就包含了五维呢？）反正，根据M理论，宇宙由三维可见空间维+一维时间维+七维不可见空间维构成。\n4. 不确定性原理。人们永远不能同时准确知道粒子的位置和速度；对其中一个知道的越精确，则对另一个就知道的越不准确。\n5. 人择原理。我们之所以看到宇宙是这个样子，只是因为如果它不是这样，我们就不会在这里去观察它。\n\n<br/>\n\n这本书看完以后，真如醍醐灌顶。\n理顺了之前既得已知的知识，扩展了后面的知识，虽然，没有细究（也不必细究），但是有了一个了解。\n对于物之上，物之下，更深层的了解，开拓了视野。\n\n<br/>\n\n最后，\n在相对论中并没有一个唯一的绝对时间，\n每个人都有自己的时间测度，这依赖于他在何处并如何运动。\n与自己最相近的，应该是反我（任何粒子都有会和它湮灭的反粒子,也可能存在由反粒子构成的整个反世界和反人）\n然而，如果你遇到了反自身，注意不要握手！\n否则，你们两人都会在一个巨大的闪光中消失殆尽。\n","slug":"《时间简史》读感","published":1,"updated":"2018-04-01T17:08:42.000Z","_id":"cjfbbabj9002eveueb3wlgu54","comments":1,"layout":"post","photos":[],"link":"","content":"<p>《时间简史》 读感</p>\n<p>如果不进行外加干涉,事物总是倾向于增加它的无序度。</p>\n<a id=\"more\"></a>\n<p><br></p>\n<p>这段时间，读了一下霍金的《时间简史》。<br>这本书把我带入了一个新的世界的感觉。<br>前半段，带我温习了一下高中及大学的物理（PS：这里好想吐槽，之前学物理，就是告诉你一个定理、公式，去背去做题，根本不去想为什么，或许，这就是我学的那么吃力的原因吧。）<br>后面，直接就是之前没有接触过的，几乎没有认知的领域了。</p>\n<p><br></p>\n<p>给我印象最深刻的几个部分：</p>\n<ol>\n<li>CPT守恒。通过P守恒、CP守恒到CPT守恒，可以拓展到很多东西。</li>\n<li>时间箭头。热力学时间箭头、心理学时间箭头、宇宙学时间箭头。尤其是热力学时间箭头，就是由有序到无序的过程，熵在不断增加的过程。</li>\n<li>时空维度。曾经我一度困扰，四维空间以上的五维空间是什么样子呢？后来才知道，说四维空间，好像不是很合适，应该是三维+一维，三个空间维度加一个时间维度。<br>然后，剩下的维度是我们之上，还是我们之下呢？（也就是说我们在五维空间内，还是四维就包含了五维呢？）反正，根据M理论，宇宙由三维可见空间维+一维时间维+七维不可见空间维构成。</li>\n<li>不确定性原理。人们永远不能同时准确知道粒子的位置和速度；对其中一个知道的越精确，则对另一个就知道的越不准确。</li>\n<li>人择原理。我们之所以看到宇宙是这个样子，只是因为如果它不是这样，我们就不会在这里去观察它。</li>\n</ol>\n<p><br></p>\n<p>这本书看完以后，真如醍醐灌顶。<br>理顺了之前既得已知的知识，扩展了后面的知识，虽然，没有细究（也不必细究），但是有了一个了解。<br>对于物之上，物之下，更深层的了解，开拓了视野。</p>\n<p><br></p>\n<p>最后，<br>在相对论中并没有一个唯一的绝对时间，<br>每个人都有自己的时间测度，这依赖于他在何处并如何运动。<br>与自己最相近的，应该是反我（任何粒子都有会和它湮灭的反粒子,也可能存在由反粒子构成的整个反世界和反人）<br>然而，如果你遇到了反自身，注意不要握手！<br>否则，你们两人都会在一个巨大的闪光中消失殆尽。</p>\n","site":{"data":{}},"excerpt":"<p>《时间简史》 读感</p>\n<p>如果不进行外加干涉,事物总是倾向于增加它的无序度。</p>","more":"<p><br></p>\n<p>这段时间，读了一下霍金的《时间简史》。<br>这本书把我带入了一个新的世界的感觉。<br>前半段，带我温习了一下高中及大学的物理（PS：这里好想吐槽，之前学物理，就是告诉你一个定理、公式，去背去做题，根本不去想为什么，或许，这就是我学的那么吃力的原因吧。）<br>后面，直接就是之前没有接触过的，几乎没有认知的领域了。</p>\n<p><br></p>\n<p>给我印象最深刻的几个部分：</p>\n<ol>\n<li>CPT守恒。通过P守恒、CP守恒到CPT守恒，可以拓展到很多东西。</li>\n<li>时间箭头。热力学时间箭头、心理学时间箭头、宇宙学时间箭头。尤其是热力学时间箭头，就是由有序到无序的过程，熵在不断增加的过程。</li>\n<li>时空维度。曾经我一度困扰，四维空间以上的五维空间是什么样子呢？后来才知道，说四维空间，好像不是很合适，应该是三维+一维，三个空间维度加一个时间维度。<br>然后，剩下的维度是我们之上，还是我们之下呢？（也就是说我们在五维空间内，还是四维就包含了五维呢？）反正，根据M理论，宇宙由三维可见空间维+一维时间维+七维不可见空间维构成。</li>\n<li>不确定性原理。人们永远不能同时准确知道粒子的位置和速度；对其中一个知道的越精确，则对另一个就知道的越不准确。</li>\n<li>人择原理。我们之所以看到宇宙是这个样子，只是因为如果它不是这样，我们就不会在这里去观察它。</li>\n</ol>\n<p><br></p>\n<p>这本书看完以后，真如醍醐灌顶。<br>理顺了之前既得已知的知识，扩展了后面的知识，虽然，没有细究（也不必细究），但是有了一个了解。<br>对于物之上，物之下，更深层的了解，开拓了视野。</p>\n<p><br></p>\n<p>最后，<br>在相对论中并没有一个唯一的绝对时间，<br>每个人都有自己的时间测度，这依赖于他在何处并如何运动。<br>与自己最相近的，应该是反我（任何粒子都有会和它湮灭的反粒子,也可能存在由反粒子构成的整个反世界和反人）<br>然而，如果你遇到了反自身，注意不要握手！<br>否则，你们两人都会在一个巨大的闪光中消失殆尽。</p>"},{"title":"《生死疲劳》读感","date":"2016-07-25T14:22:05.000Z","_content":"\n莫言的《生死疲劳》读感\n\n<!-- more -->\n\n经同事推荐，\n拜读了一下莫言的《生死疲劳》，\n按他的话：莫言获得诺贝尔文学奖，还是有他独到之处的，应该读一下他的文章。\n<br/>\n这本书，一是从大局上，中国农村从1950年到2000年间50年的变化，每一次的转世都是代表每个时代的特点，非常有标志性。\n二是从个人上，带着怨恨的人是无法转世为人的，西门闹那么深的仇怨，也被这一次次的转世磨没了脾性，从刚转世为驴的驴折腾，到最后为蓝千岁时，平静的叙述这一切。\n其实，不光是主人公西门闹，读者也饱受煎熬，读者也随着西门闹一起，一次次转世，一次次的经历着他所经历的一切。\n<br/>\n驴、牛、猪、狗 这四个中（猴 和 蓝千岁 的部分太少，主要是这四个），最不甘而且有人性的要属驴，\n正如其名——驴折腾，可是真能折腾，\n作为第一个顺序的动物，西门闹的怨恨还是很强的，\n不爽于自己为驴，不爽于蓝脸为己主，不爽于蓝脸与迎春的结合，等等。\n但，到了牛这里，牛犟劲，\n这犟劲的态度，不单指西门闹的不妥协，不服从，\n也配着蓝脸的单干行为的犟，即使到最后，\n被一鞭一鞭抽死，也不妥协。\n转世为猪这部分，则开始天马行空，这部分我读着最费力的部分，\n一是本书读到这里，已经经历两世，有些疲劳了，\n二是，这部分有些太扯了，总让我跳戏。\n转世为狗，已经是一个新的开始了，\n无论是西门闹，还是读者也快到极限了，\n所以，狗精神这部分，西门闹已经完全适应了为动物，\n不像为驴时，还有着人性，其实，在为猪时，他就已经有些忘却自己的人性了。\n<br/>\n遗憾的是，这本书，有些虎头蛇尾。\n后面很多东西，都能感觉的出来很仓促，\n尤其是到猴子和蓝千岁这两部分，跟前面比都少的贫瘠了。\n还有，最后，这些人死的...\n让我感觉回到了余华的《活着》的最后部分，\n只不过，《活着》中，一人一牛，在那田野中耕种着；\n而《生死疲劳》里，是那蓝千岁在一排长满杂草的墓前唏嘘着。\n<br/>\n噢，还有一点。\n本书中，男女关系，有些乱的我头晕...\n<br/>\n总之，莫先生的文笔还是很强的，那些细节的描写，都不需要多想，就能有幅画面在眼前。\n有很多，让我想拍大腿叫好的语句。\n对了，还有，本书内的莫言，是最让我跳戏的东西。","source":"_posts/《生死疲劳》读感.md","raw":"---\ntitle: 《生死疲劳》读感\ndate: 2016-07-25 22:22:05\ntags: 读书笔记\n---\n\n莫言的《生死疲劳》读感\n\n<!-- more -->\n\n经同事推荐，\n拜读了一下莫言的《生死疲劳》，\n按他的话：莫言获得诺贝尔文学奖，还是有他独到之处的，应该读一下他的文章。\n<br/>\n这本书，一是从大局上，中国农村从1950年到2000年间50年的变化，每一次的转世都是代表每个时代的特点，非常有标志性。\n二是从个人上，带着怨恨的人是无法转世为人的，西门闹那么深的仇怨，也被这一次次的转世磨没了脾性，从刚转世为驴的驴折腾，到最后为蓝千岁时，平静的叙述这一切。\n其实，不光是主人公西门闹，读者也饱受煎熬，读者也随着西门闹一起，一次次转世，一次次的经历着他所经历的一切。\n<br/>\n驴、牛、猪、狗 这四个中（猴 和 蓝千岁 的部分太少，主要是这四个），最不甘而且有人性的要属驴，\n正如其名——驴折腾，可是真能折腾，\n作为第一个顺序的动物，西门闹的怨恨还是很强的，\n不爽于自己为驴，不爽于蓝脸为己主，不爽于蓝脸与迎春的结合，等等。\n但，到了牛这里，牛犟劲，\n这犟劲的态度，不单指西门闹的不妥协，不服从，\n也配着蓝脸的单干行为的犟，即使到最后，\n被一鞭一鞭抽死，也不妥协。\n转世为猪这部分，则开始天马行空，这部分我读着最费力的部分，\n一是本书读到这里，已经经历两世，有些疲劳了，\n二是，这部分有些太扯了，总让我跳戏。\n转世为狗，已经是一个新的开始了，\n无论是西门闹，还是读者也快到极限了，\n所以，狗精神这部分，西门闹已经完全适应了为动物，\n不像为驴时，还有着人性，其实，在为猪时，他就已经有些忘却自己的人性了。\n<br/>\n遗憾的是，这本书，有些虎头蛇尾。\n后面很多东西，都能感觉的出来很仓促，\n尤其是到猴子和蓝千岁这两部分，跟前面比都少的贫瘠了。\n还有，最后，这些人死的...\n让我感觉回到了余华的《活着》的最后部分，\n只不过，《活着》中，一人一牛，在那田野中耕种着；\n而《生死疲劳》里，是那蓝千岁在一排长满杂草的墓前唏嘘着。\n<br/>\n噢，还有一点。\n本书中，男女关系，有些乱的我头晕...\n<br/>\n总之，莫先生的文笔还是很强的，那些细节的描写，都不需要多想，就能有幅画面在眼前。\n有很多，让我想拍大腿叫好的语句。\n对了，还有，本书内的莫言，是最让我跳戏的东西。","slug":"《生死疲劳》读感","published":1,"updated":"2018-04-01T17:08:47.000Z","_id":"cjfbbabjc002hveueb5xiywlp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>莫言的《生死疲劳》读感</p>\n<a id=\"more\"></a>\n<p>经同事推荐，<br>拜读了一下莫言的《生死疲劳》，<br>按他的话：莫言获得诺贝尔文学奖，还是有他独到之处的，应该读一下他的文章。<br><br><br>这本书，一是从大局上，中国农村从1950年到2000年间50年的变化，每一次的转世都是代表每个时代的特点，非常有标志性。<br>二是从个人上，带着怨恨的人是无法转世为人的，西门闹那么深的仇怨，也被这一次次的转世磨没了脾性，从刚转世为驴的驴折腾，到最后为蓝千岁时，平静的叙述这一切。<br>其实，不光是主人公西门闹，读者也饱受煎熬，读者也随着西门闹一起，一次次转世，一次次的经历着他所经历的一切。<br><br><br>驴、牛、猪、狗 这四个中（猴 和 蓝千岁 的部分太少，主要是这四个），最不甘而且有人性的要属驴，<br>正如其名——驴折腾，可是真能折腾，<br>作为第一个顺序的动物，西门闹的怨恨还是很强的，<br>不爽于自己为驴，不爽于蓝脸为己主，不爽于蓝脸与迎春的结合，等等。<br>但，到了牛这里，牛犟劲，<br>这犟劲的态度，不单指西门闹的不妥协，不服从，<br>也配着蓝脸的单干行为的犟，即使到最后，<br>被一鞭一鞭抽死，也不妥协。<br>转世为猪这部分，则开始天马行空，这部分我读着最费力的部分，<br>一是本书读到这里，已经经历两世，有些疲劳了，<br>二是，这部分有些太扯了，总让我跳戏。<br>转世为狗，已经是一个新的开始了，<br>无论是西门闹，还是读者也快到极限了，<br>所以，狗精神这部分，西门闹已经完全适应了为动物，<br>不像为驴时，还有着人性，其实，在为猪时，他就已经有些忘却自己的人性了。<br><br><br>遗憾的是，这本书，有些虎头蛇尾。<br>后面很多东西，都能感觉的出来很仓促，<br>尤其是到猴子和蓝千岁这两部分，跟前面比都少的贫瘠了。<br>还有，最后，这些人死的…<br>让我感觉回到了余华的《活着》的最后部分，<br>只不过，《活着》中，一人一牛，在那田野中耕种着；<br>而《生死疲劳》里，是那蓝千岁在一排长满杂草的墓前唏嘘着。<br><br><br>噢，还有一点。<br>本书中，男女关系，有些乱的我头晕…<br><br><br>总之，莫先生的文笔还是很强的，那些细节的描写，都不需要多想，就能有幅画面在眼前。<br>有很多，让我想拍大腿叫好的语句。<br>对了，还有，本书内的莫言，是最让我跳戏的东西。</p>\n","site":{"data":{}},"excerpt":"<p>莫言的《生死疲劳》读感</p>","more":"<p>经同事推荐，<br>拜读了一下莫言的《生死疲劳》，<br>按他的话：莫言获得诺贝尔文学奖，还是有他独到之处的，应该读一下他的文章。<br><br><br>这本书，一是从大局上，中国农村从1950年到2000年间50年的变化，每一次的转世都是代表每个时代的特点，非常有标志性。<br>二是从个人上，带着怨恨的人是无法转世为人的，西门闹那么深的仇怨，也被这一次次的转世磨没了脾性，从刚转世为驴的驴折腾，到最后为蓝千岁时，平静的叙述这一切。<br>其实，不光是主人公西门闹，读者也饱受煎熬，读者也随着西门闹一起，一次次转世，一次次的经历着他所经历的一切。<br><br><br>驴、牛、猪、狗 这四个中（猴 和 蓝千岁 的部分太少，主要是这四个），最不甘而且有人性的要属驴，<br>正如其名——驴折腾，可是真能折腾，<br>作为第一个顺序的动物，西门闹的怨恨还是很强的，<br>不爽于自己为驴，不爽于蓝脸为己主，不爽于蓝脸与迎春的结合，等等。<br>但，到了牛这里，牛犟劲，<br>这犟劲的态度，不单指西门闹的不妥协，不服从，<br>也配着蓝脸的单干行为的犟，即使到最后，<br>被一鞭一鞭抽死，也不妥协。<br>转世为猪这部分，则开始天马行空，这部分我读着最费力的部分，<br>一是本书读到这里，已经经历两世，有些疲劳了，<br>二是，这部分有些太扯了，总让我跳戏。<br>转世为狗，已经是一个新的开始了，<br>无论是西门闹，还是读者也快到极限了，<br>所以，狗精神这部分，西门闹已经完全适应了为动物，<br>不像为驴时，还有着人性，其实，在为猪时，他就已经有些忘却自己的人性了。<br><br><br>遗憾的是，这本书，有些虎头蛇尾。<br>后面很多东西，都能感觉的出来很仓促，<br>尤其是到猴子和蓝千岁这两部分，跟前面比都少的贫瘠了。<br>还有，最后，这些人死的…<br>让我感觉回到了余华的《活着》的最后部分，<br>只不过，《活着》中，一人一牛，在那田野中耕种着；<br>而《生死疲劳》里，是那蓝千岁在一排长满杂草的墓前唏嘘着。<br><br><br>噢，还有一点。<br>本书中，男女关系，有些乱的我头晕…<br><br><br>总之，莫先生的文笔还是很强的，那些细节的描写，都不需要多想，就能有幅画面在眼前。<br>有很多，让我想拍大腿叫好的语句。<br>对了，还有，本书内的莫言，是最让我跳戏的东西。</p>"},{"title":"为什么要搞这个？","date":"2016-07-20T15:03:16.000Z","_content":"\n折腾啥呀？！！\n\n<!-- more -->\n为什么要搞这个东西呢？\n已经不写博文好长时间了，\n起因是到了大四，离开学校，一人奔赴帝都找工作，没有多少时间，（一个字，懒）\n之后，就是刚入职，要学习新的东西，没空出时间，（还是一个字，懒）\n等可以应付了以后，懒癌开始犯了，（已经找不出借口了）\n后来...后来就毕业了，又忙毕业...\n拖着，拖着，到了现在。\n<br/>\n想着，毕业了，\n该有个新的开始了，\n本来想做个个人网站，结果发现，好麻烦啊o(╯□╰)o...\n精力实在有限（还是懒呗..）\n忽然发现了这个，\n简约的风格，便捷的部署，还不用我去维护它，\n毅然，上了这辆车。\n<br/>\n最重要的是，\n搞这个东西，\n看起来是屌屌的呀。\n而且，年轻人，就是该多折腾折腾嘛。","source":"_posts/为什么要搞这个？.md","raw":"---\ntitle: 为什么要搞这个？\ndate: 2016-07-20 23:03:16\ntags: 随笔\n---\n\n折腾啥呀？！！\n\n<!-- more -->\n为什么要搞这个东西呢？\n已经不写博文好长时间了，\n起因是到了大四，离开学校，一人奔赴帝都找工作，没有多少时间，（一个字，懒）\n之后，就是刚入职，要学习新的东西，没空出时间，（还是一个字，懒）\n等可以应付了以后，懒癌开始犯了，（已经找不出借口了）\n后来...后来就毕业了，又忙毕业...\n拖着，拖着，到了现在。\n<br/>\n想着，毕业了，\n该有个新的开始了，\n本来想做个个人网站，结果发现，好麻烦啊o(╯□╰)o...\n精力实在有限（还是懒呗..）\n忽然发现了这个，\n简约的风格，便捷的部署，还不用我去维护它，\n毅然，上了这辆车。\n<br/>\n最重要的是，\n搞这个东西，\n看起来是屌屌的呀。\n而且，年轻人，就是该多折腾折腾嘛。","slug":"为什么要搞这个？","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabje002jveuen8c0vh4d","content":"<p>折腾啥呀？！！</p>\n<a id=\"more\"></a>\n<p>为什么要搞这个东西呢？<br>已经不写博文好长时间了，<br>起因是到了大四，离开学校，一人奔赴帝都找工作，没有多少时间，（一个字，懒）<br>之后，就是刚入职，要学习新的东西，没空出时间，（还是一个字，懒）<br>等可以应付了以后，懒癌开始犯了，（已经找不出借口了）<br>后来…后来就毕业了，又忙毕业…<br>拖着，拖着，到了现在。<br><br><br>想着，毕业了，<br>该有个新的开始了，<br>本来想做个个人网站，结果发现，好麻烦啊o(╯□╰)o…<br>精力实在有限（还是懒呗..）<br>忽然发现了这个，<br>简约的风格，便捷的部署，还不用我去维护它，<br>毅然，上了这辆车。<br><br><br>最重要的是，<br>搞这个东西，<br>看起来是屌屌的呀。<br>而且，年轻人，就是该多折腾折腾嘛。</p>\n","site":{"data":{}},"excerpt":"<p>折腾啥呀？！！</p>","more":"<p>为什么要搞这个东西呢？<br>已经不写博文好长时间了，<br>起因是到了大四，离开学校，一人奔赴帝都找工作，没有多少时间，（一个字，懒）<br>之后，就是刚入职，要学习新的东西，没空出时间，（还是一个字，懒）<br>等可以应付了以后，懒癌开始犯了，（已经找不出借口了）<br>后来…后来就毕业了，又忙毕业…<br>拖着，拖着，到了现在。<br><br><br>想着，毕业了，<br>该有个新的开始了，<br>本来想做个个人网站，结果发现，好麻烦啊o(╯□╰)o…<br>精力实在有限（还是懒呗..）<br>忽然发现了这个，<br>简约的风格，便捷的部署，还不用我去维护它，<br>毅然，上了这辆车。<br><br><br>最重要的是，<br>搞这个东西，<br>看起来是屌屌的呀。<br>而且，年轻人，就是该多折腾折腾嘛。</p>"},{"title":"删除文件名中的空格","date":"2016-11-02T15:07:16.000Z","_content":"\n用lua、python3来删除文件名中的空格。\n\n<!-- more -->\n<br/>\n工作不认真，\n目录下的文件名有空格，\n遇到这种就很烦躁呀，\n算了，\n还是搞个脚本解决下吧。\n<br/>\n做的很简单，\n处理的是**当前目录**下所有文件的文件名，\n通过**替换字符串**的方式将空格替换了。\n<br/>\n环境：MAC\n<br/>\n- lua方法\n\n\n\t\tlocal files = {}\n\t\tlocal all = io.popen(\"ls \")\n\t\tfor filename in all:lines() do\n\t\t\tif string.find(filename, ' ') then\n\t\t\t\tlocal newName = string.gsub(filename, ' ', '')\n\t\t\t\tos.rename(filename, newName)\n\t\t\tend\n\t\tend\n\n<br/>\n\n- python3方法\n\n\n\t\timport os\n\t\tfor parent, dirnames, filenames in os.walk(os.getcwd()):\n\t\t\tfor filename in filenames:\n\t\t\t\tos.rename(os.path.join(parent, filename), os.path.join(parent, filename.replace(' ', '')))\n\n","source":"_posts/删除文件名中的空格.md","raw":"---\ntitle: 删除文件名中的空格\ndate: 2016-11-02 23:07:16\ntags: [脚本, 小技巧]\n---\n\n用lua、python3来删除文件名中的空格。\n\n<!-- more -->\n<br/>\n工作不认真，\n目录下的文件名有空格，\n遇到这种就很烦躁呀，\n算了，\n还是搞个脚本解决下吧。\n<br/>\n做的很简单，\n处理的是**当前目录**下所有文件的文件名，\n通过**替换字符串**的方式将空格替换了。\n<br/>\n环境：MAC\n<br/>\n- lua方法\n\n\n\t\tlocal files = {}\n\t\tlocal all = io.popen(\"ls \")\n\t\tfor filename in all:lines() do\n\t\t\tif string.find(filename, ' ') then\n\t\t\t\tlocal newName = string.gsub(filename, ' ', '')\n\t\t\t\tos.rename(filename, newName)\n\t\t\tend\n\t\tend\n\n<br/>\n\n- python3方法\n\n\n\t\timport os\n\t\tfor parent, dirnames, filenames in os.walk(os.getcwd()):\n\t\t\tfor filename in filenames:\n\t\t\t\tos.rename(os.path.join(parent, filename), os.path.join(parent, filename.replace(' ', '')))\n\n","slug":"删除文件名中的空格","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabjh002mveuehs1khsi8","content":"<p>用lua、python3来删除文件名中的空格。</p>\n<a id=\"more\"></a>\n<p><br><br>工作不认真，<br>目录下的文件名有空格，<br>遇到这种就很烦躁呀，<br>算了，<br>还是搞个脚本解决下吧。<br><br><br>做的很简单，<br>处理的是<strong>当前目录</strong>下所有文件的文件名，<br>通过<strong>替换字符串</strong>的方式将空格替换了。<br><br><br>环境：MAC<br><br></p>\n<ul>\n<li>lua方法</li>\n</ul>\n<pre><code>local files = {}\nlocal all = io.popen(&quot;ls &quot;)\nfor filename in all:lines() do\n    if string.find(filename, &apos; &apos;) then\n        local newName = string.gsub(filename, &apos; &apos;, &apos;&apos;)\n        os.rename(filename, newName)\n    end\nend\n</code></pre><p><br></p>\n<ul>\n<li>python3方法</li>\n</ul>\n<pre><code>import os\nfor parent, dirnames, filenames in os.walk(os.getcwd()):\n    for filename in filenames:\n        os.rename(os.path.join(parent, filename), os.path.join(parent, filename.replace(&apos; &apos;, &apos;&apos;)))\n</code></pre>","site":{"data":{}},"excerpt":"<p>用lua、python3来删除文件名中的空格。</p>","more":"<p><br><br>工作不认真，<br>目录下的文件名有空格，<br>遇到这种就很烦躁呀，<br>算了，<br>还是搞个脚本解决下吧。<br><br><br>做的很简单，<br>处理的是<strong>当前目录</strong>下所有文件的文件名，<br>通过<strong>替换字符串</strong>的方式将空格替换了。<br><br><br>环境：MAC<br><br></p>\n<ul>\n<li>lua方法</li>\n</ul>\n<pre><code>local files = {}\nlocal all = io.popen(&quot;ls &quot;)\nfor filename in all:lines() do\n    if string.find(filename, &apos; &apos;) then\n        local newName = string.gsub(filename, &apos; &apos;, &apos;&apos;)\n        os.rename(filename, newName)\n    end\nend\n</code></pre><p><br></p>\n<ul>\n<li>python3方法</li>\n</ul>\n<pre><code>import os\nfor parent, dirnames, filenames in os.walk(os.getcwd()):\n    for filename in filenames:\n        os.rename(os.path.join(parent, filename), os.path.join(parent, filename.replace(&apos; &apos;, &apos;&apos;)))\n</code></pre>"},{"title":"用python发邮件","date":"2016-11-04T12:51:35.000Z","_content":"\nOne Step\n\n用python来发邮件\n\n<!-- more -->\n<br/>\n恩，\n学了python就不要浪费，\n公司要求每天都要写工作日志，\n每次都要:\n1. 打开浏览器\n2. 选择收藏夹里的邮箱\n3. 输入账号密码登陆\n4. 选择收件人\n5. 填写邮件抬头\n6. 填写当前日期，还要把鼠标移下去看看\n7. 写工作日志\n8. 点击发送\n\n很麻烦啊，\n写个脚本，\n\n1. 打开脚本\n2. 写你的工作日志（注意，只需要写日志，不需要写时间，title，收件人等）\n3. 编译\n\n惊！\n这难道就是传说中的 —— One Step ？！！\n\n<br/>\n唠叨完了，该整干货了。\n\n\n\t\timport smtplib\n\t\tfrom email.header import Header\n\t\tfrom email.mime.text import MIMEText\n\t\tfrom datetime import datetime\n\n\t\tsender = ''  \t\t\t\t\t\t\t# 此处填写发件人邮箱\n\t\tpassword = ''\t\t\t\t\t\t\t# 此处填写发件人邮箱密码   \t=>注释1\n\t\treceiver = ''\t\t\t\t\t\t\t# 此处填写收件人邮箱\n\t\tsmtp_server = ''\t\t\t\t\t\t# 此处填写smtp服务器地址\n\t\t\n\t\tDATE_FORMATE = '%Y-%m-%d %A'\t\t\t# 日期的格式\t\t\t\t=> 注释2\n\t\ttitle = ''\t\t\t\t\t\t\t\t# 此处填写邮件标题\n\n\t\tdef initialContent():\n\t\t\tnow = datetime.now()\n\t\t\treturn now.strftime(DATE_FORMATE)\n\n\t\tdef sendEmail(cont):\n\t\t\tcontent = initialContent() + '\\n' + cont\n\n\t\t\ttry:\n\t\t\t\tmsg = MIMEText(content, 'plain', 'utf-8') \t\t\t\t\t\n\t\t\t\tmsg['Subject'] = Header(title, 'utf-8')\t\t\t\t# => 注释3\n\t\t\t\tmsg['From'] = sender + ' <' + sender + '>'\t\t\t# => 注释3\n\t\t\t\tmsg['To'] = receiver\t\t\t\t\t\t\t\t# => 注释3\n\n\t\t\t\tserver = smtplib.SMTP(smtp_server, 25) \t\t\t\t# 连接服务器，默认端口均为25\n\t\t\t\tserver.set_debuglevel(1)  \t\t\t\t\t\t\t# 选择是否开启Debug，可以得到与服务端的反馈信息\n\t\t\t\tserver.login(sender, password)\n\t\t\t\tserver.sendmail(sender, [receiver], msg.as_string())\n\t\t\t\tserver.quit()\n\t\t\n\t\t\t\tprint('send email success')\n\t\t\texcept smtplib.SMTPException:\n\t\t\t\tpriint('send email fail')\n\n\n关于上述代码的一些注释：\n- 注释1:\n关于邮箱密码，有些密码需要填写客户端授权码，比如163，当然，要用SMPT发邮件，需要将发信箱的SMTP服务打开。\n- 注释2:\n日期的格式，更详细的可参考官方文档：http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime\n- 注释3:\n这里的From、To、Subject是非常必要的\n\n**还有，最好不要用163邮箱测试发邮件，会出现很多乱七八糟的问题（并非是你代码的问题）。**\n<br/>\n上面代码是用来发邮件的核心代码，\n写日志的地方加在里面是很不友好的行为，\n所以，\n再单独建一个新的友好的地方来写日志。\n\n\n\t\timport imp \n\t\ttool = imp.load_source('sendEmail', 'url')\t\t\t\t# 导入核心模块，url 填写你上面核心代码的位置\n\n\t\tcontent = \"\"\"\n\t\t在这里来写你的工作日志，\n\t\t支持多行。\n\t\t\"\"\"\n\n\t\ttool.sendEmail(content.strip()) \t\t\t\t\t\t# strip将首尾空白字符删除\n\n<br/>\n这样就方便很多了。\n最后，\n这个只是初步版本，\n后期可以添加很多你想要的东西，\n比如多个联系人，一些判断。\n我因为自己用，所以没有加那些东西。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/用python发邮件.md","raw":"---\ntitle: 用python发邮件\ndate: 2016-11-04 20:51:35\ntags: [脚本, 小技巧]\n---\n\nOne Step\n\n用python来发邮件\n\n<!-- more -->\n<br/>\n恩，\n学了python就不要浪费，\n公司要求每天都要写工作日志，\n每次都要:\n1. 打开浏览器\n2. 选择收藏夹里的邮箱\n3. 输入账号密码登陆\n4. 选择收件人\n5. 填写邮件抬头\n6. 填写当前日期，还要把鼠标移下去看看\n7. 写工作日志\n8. 点击发送\n\n很麻烦啊，\n写个脚本，\n\n1. 打开脚本\n2. 写你的工作日志（注意，只需要写日志，不需要写时间，title，收件人等）\n3. 编译\n\n惊！\n这难道就是传说中的 —— One Step ？！！\n\n<br/>\n唠叨完了，该整干货了。\n\n\n\t\timport smtplib\n\t\tfrom email.header import Header\n\t\tfrom email.mime.text import MIMEText\n\t\tfrom datetime import datetime\n\n\t\tsender = ''  \t\t\t\t\t\t\t# 此处填写发件人邮箱\n\t\tpassword = ''\t\t\t\t\t\t\t# 此处填写发件人邮箱密码   \t=>注释1\n\t\treceiver = ''\t\t\t\t\t\t\t# 此处填写收件人邮箱\n\t\tsmtp_server = ''\t\t\t\t\t\t# 此处填写smtp服务器地址\n\t\t\n\t\tDATE_FORMATE = '%Y-%m-%d %A'\t\t\t# 日期的格式\t\t\t\t=> 注释2\n\t\ttitle = ''\t\t\t\t\t\t\t\t# 此处填写邮件标题\n\n\t\tdef initialContent():\n\t\t\tnow = datetime.now()\n\t\t\treturn now.strftime(DATE_FORMATE)\n\n\t\tdef sendEmail(cont):\n\t\t\tcontent = initialContent() + '\\n' + cont\n\n\t\t\ttry:\n\t\t\t\tmsg = MIMEText(content, 'plain', 'utf-8') \t\t\t\t\t\n\t\t\t\tmsg['Subject'] = Header(title, 'utf-8')\t\t\t\t# => 注释3\n\t\t\t\tmsg['From'] = sender + ' <' + sender + '>'\t\t\t# => 注释3\n\t\t\t\tmsg['To'] = receiver\t\t\t\t\t\t\t\t# => 注释3\n\n\t\t\t\tserver = smtplib.SMTP(smtp_server, 25) \t\t\t\t# 连接服务器，默认端口均为25\n\t\t\t\tserver.set_debuglevel(1)  \t\t\t\t\t\t\t# 选择是否开启Debug，可以得到与服务端的反馈信息\n\t\t\t\tserver.login(sender, password)\n\t\t\t\tserver.sendmail(sender, [receiver], msg.as_string())\n\t\t\t\tserver.quit()\n\t\t\n\t\t\t\tprint('send email success')\n\t\t\texcept smtplib.SMTPException:\n\t\t\t\tpriint('send email fail')\n\n\n关于上述代码的一些注释：\n- 注释1:\n关于邮箱密码，有些密码需要填写客户端授权码，比如163，当然，要用SMPT发邮件，需要将发信箱的SMTP服务打开。\n- 注释2:\n日期的格式，更详细的可参考官方文档：http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime\n- 注释3:\n这里的From、To、Subject是非常必要的\n\n**还有，最好不要用163邮箱测试发邮件，会出现很多乱七八糟的问题（并非是你代码的问题）。**\n<br/>\n上面代码是用来发邮件的核心代码，\n写日志的地方加在里面是很不友好的行为，\n所以，\n再单独建一个新的友好的地方来写日志。\n\n\n\t\timport imp \n\t\ttool = imp.load_source('sendEmail', 'url')\t\t\t\t# 导入核心模块，url 填写你上面核心代码的位置\n\n\t\tcontent = \"\"\"\n\t\t在这里来写你的工作日志，\n\t\t支持多行。\n\t\t\"\"\"\n\n\t\ttool.sendEmail(content.strip()) \t\t\t\t\t\t# strip将首尾空白字符删除\n\n<br/>\n这样就方便很多了。\n最后，\n这个只是初步版本，\n后期可以添加很多你想要的东西，\n比如多个联系人，一些判断。\n我因为自己用，所以没有加那些东西。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"用python发邮件","published":1,"updated":"2017-06-06T23:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfbbabjj002oveuefj8v8gwc","content":"<p>One Step</p>\n<p>用python来发邮件</p>\n<a id=\"more\"></a>\n<p><br><br>恩，<br>学了python就不要浪费，<br>公司要求每天都要写工作日志，<br>每次都要:</p>\n<ol>\n<li>打开浏览器</li>\n<li>选择收藏夹里的邮箱</li>\n<li>输入账号密码登陆</li>\n<li>选择收件人</li>\n<li>填写邮件抬头</li>\n<li>填写当前日期，还要把鼠标移下去看看</li>\n<li>写工作日志</li>\n<li>点击发送</li>\n</ol>\n<p>很麻烦啊，<br>写个脚本，</p>\n<ol>\n<li>打开脚本</li>\n<li>写你的工作日志（注意，只需要写日志，不需要写时间，title，收件人等）</li>\n<li>编译</li>\n</ol>\n<p>惊！<br>这难道就是传说中的 —— One Step ？！！</p>\n<p><br><br>唠叨完了，该整干货了。</p>\n<pre><code>import smtplib\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom datetime import datetime\n\nsender = &apos;&apos;                              # 此处填写发件人邮箱\npassword = &apos;&apos;                            # 此处填写发件人邮箱密码       =&gt;注释1\nreceiver = &apos;&apos;                            # 此处填写收件人邮箱\nsmtp_server = &apos;&apos;                        # 此处填写smtp服务器地址\n\nDATE_FORMATE = &apos;%Y-%m-%d %A&apos;            # 日期的格式                =&gt; 注释2\ntitle = &apos;&apos;                                # 此处填写邮件标题\n\ndef initialContent():\n    now = datetime.now()\n    return now.strftime(DATE_FORMATE)\n\ndef sendEmail(cont):\n    content = initialContent() + &apos;\\n&apos; + cont\n\n    try:\n        msg = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)                     \n        msg[&apos;Subject&apos;] = Header(title, &apos;utf-8&apos;)                # =&gt; 注释3\n        msg[&apos;From&apos;] = sender + &apos; &lt;&apos; + sender + &apos;&gt;&apos;            # =&gt; 注释3\n        msg[&apos;To&apos;] = receiver                                # =&gt; 注释3\n\n        server = smtplib.SMTP(smtp_server, 25)                 # 连接服务器，默认端口均为25\n        server.set_debuglevel(1)                              # 选择是否开启Debug，可以得到与服务端的反馈信息\n        server.login(sender, password)\n        server.sendmail(sender, [receiver], msg.as_string())\n        server.quit()\n\n        print(&apos;send email success&apos;)\n    except smtplib.SMTPException:\n        priint(&apos;send email fail&apos;)\n</code></pre><p>关于上述代码的一些注释：</p>\n<ul>\n<li>注释1:<br>关于邮箱密码，有些密码需要填写客户端授权码，比如163，当然，要用SMPT发邮件，需要将发信箱的SMTP服务打开。</li>\n<li>注释2:<br>日期的格式，更详细的可参考官方文档：<a href=\"http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime\" target=\"_blank\" rel=\"noopener\">http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime</a></li>\n<li>注释3:<br>这里的From、To、Subject是非常必要的</li>\n</ul>\n<p><strong>还有，最好不要用163邮箱测试发邮件，会出现很多乱七八糟的问题（并非是你代码的问题）。</strong><br><br><br>上面代码是用来发邮件的核心代码，<br>写日志的地方加在里面是很不友好的行为，<br>所以，<br>再单独建一个新的友好的地方来写日志。</p>\n<pre><code>import imp \ntool = imp.load_source(&apos;sendEmail&apos;, &apos;url&apos;)                # 导入核心模块，url 填写你上面核心代码的位置\n\ncontent = &quot;&quot;&quot;\n在这里来写你的工作日志，\n支持多行。\n&quot;&quot;&quot;\n\ntool.sendEmail(content.strip())                         # strip将首尾空白字符删除\n</code></pre><p><br><br>这样就方便很多了。<br>最后，<br>这个只是初步版本，<br>后期可以添加很多你想要的东西，<br>比如多个联系人，一些判断。<br>我因为自己用，所以没有加那些东西。</p>\n","site":{"data":{}},"excerpt":"<p>One Step</p>\n<p>用python来发邮件</p>","more":"<p><br><br>恩，<br>学了python就不要浪费，<br>公司要求每天都要写工作日志，<br>每次都要:</p>\n<ol>\n<li>打开浏览器</li>\n<li>选择收藏夹里的邮箱</li>\n<li>输入账号密码登陆</li>\n<li>选择收件人</li>\n<li>填写邮件抬头</li>\n<li>填写当前日期，还要把鼠标移下去看看</li>\n<li>写工作日志</li>\n<li>点击发送</li>\n</ol>\n<p>很麻烦啊，<br>写个脚本，</p>\n<ol>\n<li>打开脚本</li>\n<li>写你的工作日志（注意，只需要写日志，不需要写时间，title，收件人等）</li>\n<li>编译</li>\n</ol>\n<p>惊！<br>这难道就是传说中的 —— One Step ？！！</p>\n<p><br><br>唠叨完了，该整干货了。</p>\n<pre><code>import smtplib\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom datetime import datetime\n\nsender = &apos;&apos;                              # 此处填写发件人邮箱\npassword = &apos;&apos;                            # 此处填写发件人邮箱密码       =&gt;注释1\nreceiver = &apos;&apos;                            # 此处填写收件人邮箱\nsmtp_server = &apos;&apos;                        # 此处填写smtp服务器地址\n\nDATE_FORMATE = &apos;%Y-%m-%d %A&apos;            # 日期的格式                =&gt; 注释2\ntitle = &apos;&apos;                                # 此处填写邮件标题\n\ndef initialContent():\n    now = datetime.now()\n    return now.strftime(DATE_FORMATE)\n\ndef sendEmail(cont):\n    content = initialContent() + &apos;\\n&apos; + cont\n\n    try:\n        msg = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)                     \n        msg[&apos;Subject&apos;] = Header(title, &apos;utf-8&apos;)                # =&gt; 注释3\n        msg[&apos;From&apos;] = sender + &apos; &lt;&apos; + sender + &apos;&gt;&apos;            # =&gt; 注释3\n        msg[&apos;To&apos;] = receiver                                # =&gt; 注释3\n\n        server = smtplib.SMTP(smtp_server, 25)                 # 连接服务器，默认端口均为25\n        server.set_debuglevel(1)                              # 选择是否开启Debug，可以得到与服务端的反馈信息\n        server.login(sender, password)\n        server.sendmail(sender, [receiver], msg.as_string())\n        server.quit()\n\n        print(&apos;send email success&apos;)\n    except smtplib.SMTPException:\n        priint(&apos;send email fail&apos;)\n</code></pre><p>关于上述代码的一些注释：</p>\n<ul>\n<li>注释1:<br>关于邮箱密码，有些密码需要填写客户端授权码，比如163，当然，要用SMPT发邮件，需要将发信箱的SMTP服务打开。</li>\n<li>注释2:<br>日期的格式，更详细的可参考官方文档：<a href=\"http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime\" target=\"_blank\" rel=\"noopener\">http://python.usyiyi.cn/translate/python_352/library/datetime.html#datetime.datetime</a></li>\n<li>注释3:<br>这里的From、To、Subject是非常必要的</li>\n</ul>\n<p><strong>还有，最好不要用163邮箱测试发邮件，会出现很多乱七八糟的问题（并非是你代码的问题）。</strong><br><br><br>上面代码是用来发邮件的核心代码，<br>写日志的地方加在里面是很不友好的行为，<br>所以，<br>再单独建一个新的友好的地方来写日志。</p>\n<pre><code>import imp \ntool = imp.load_source(&apos;sendEmail&apos;, &apos;url&apos;)                # 导入核心模块，url 填写你上面核心代码的位置\n\ncontent = &quot;&quot;&quot;\n在这里来写你的工作日志，\n支持多行。\n&quot;&quot;&quot;\n\ntool.sendEmail(content.strip())                         # strip将首尾空白字符删除\n</code></pre><p><br><br>这样就方便很多了。<br>最后，<br>这个只是初步版本，<br>后期可以添加很多你想要的东西，<br>比如多个联系人，一些判断。<br>我因为自己用，所以没有加那些东西。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjfbbabeu0001veuei4surlab","tag_id":"cjfbbabfl0006veue1lgyog3h","_id":"cjfbbabg7000fveueqbili4nq"},{"post_id":"cjfbbabeu0001veuei4surlab","tag_id":"cjfbbabfw000aveuek9nz1d7s","_id":"cjfbbabg9000hveuepmynnyul"},{"post_id":"cjfbbabge000kveueg3u6lcnj","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabgk000nveuerl1q7a9v"},{"post_id":"cjfbbabge000kveueg3u6lcnj","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabgn000pveue26pzttjp"},{"post_id":"cjfbbabf80003veueshqys9p2","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabgt000sveueqy4isdtv"},{"post_id":"cjfbbabf80003veueshqys9p2","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabgv000uveue68qyll93"},{"post_id":"cjfbbabgg000lveuecujwuqrg","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabgz000xveuev3hey2xx"},{"post_id":"cjfbbabgg000lveuecujwuqrg","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabh2000zveuesn1b63rp"},{"post_id":"cjfbbabgk000oveueme0emc25","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabh60012veue1ym72ysu"},{"post_id":"cjfbbabgk000oveueme0emc25","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabh90014veue9vy5x85b"},{"post_id":"cjfbbabgn000qveuexf73zwny","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabhe0017veuetlnaokeo"},{"post_id":"cjfbbabgn000qveuexf73zwny","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabhj0019veue5rdx6m11"},{"post_id":"cjfbbabgt000tveue13wd4se5","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabhm001cveueoy1nokf1"},{"post_id":"cjfbbabgt000tveue13wd4se5","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabhq001eveueyd6022fp"},{"post_id":"cjfbbabfe0004veueblbhoze5","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabhu001hveue3ktokm5x"},{"post_id":"cjfbbabfe0004veueblbhoze5","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabhy001jveueweu2wozc"},{"post_id":"cjfbbabgw000vveueqbiefv3d","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabia001mveuejqfi6blm"},{"post_id":"cjfbbabgw000vveueqbiefv3d","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabic001oveue6txgqa4o"},{"post_id":"cjfbbabgz000yveue837t1emp","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabig001rveuexqbz9t6m"},{"post_id":"cjfbbabgz000yveue837t1emp","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabim001tveuesjn5yefa"},{"post_id":"cjfbbabh20010veueixni50l0","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabir001wveuek4mnxwsd"},{"post_id":"cjfbbabh20010veueixni50l0","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabit001yveuenp7s3bv9"},{"post_id":"cjfbbabh60013veuetz6zhnwk","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabix0021veuesbcwfiqe"},{"post_id":"cjfbbabh60013veuetz6zhnwk","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabj10023veuefaojcnl3"},{"post_id":"cjfbbabfh0005veuewt7g5v9i","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabj40026veueqdlhz2pq"},{"post_id":"cjfbbabfh0005veuewt7g5v9i","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabj50028veueo6e985hr"},{"post_id":"cjfbbabh90015veuecszp9cp1","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabj7002bveue0sho5gcn"},{"post_id":"cjfbbabh90015veuecszp9cp1","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabj9002dveue3gphufgz"},{"post_id":"cjfbbabhe0018veuek3rnva60","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjb002gveueth2fh8jq"},{"post_id":"cjfbbabhe0018veuek3rnva60","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjd002iveue7kl84ga0"},{"post_id":"cjfbbabhj001aveuevox3pxma","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjh002lveuefqh0m00d"},{"post_id":"cjfbbabhj001aveuevox3pxma","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabji002nveuelsk33ucv"},{"post_id":"cjfbbabhm001dveue3y553nby","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjm002qveue93vnhdrb"},{"post_id":"cjfbbabhm001dveue3y553nby","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjn002rveuew8yoepr9"},{"post_id":"cjfbbabfn0008veuegp0dsow2","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjn002tveueuzvltf0o"},{"post_id":"cjfbbabfn0008veuegp0dsow2","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjn002uveueh5m4rsng"},{"post_id":"cjfbbabhq001fveue235916bu","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjp002wveue9ekjm8ue"},{"post_id":"cjfbbabhq001fveue235916bu","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjp002xveueh3lprwv8"},{"post_id":"cjfbbabhu001iveue0zsw9jek","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjp002yveuei4hngkmj"},{"post_id":"cjfbbabhu001iveue0zsw9jek","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjq0030veueihor6mxj"},{"post_id":"cjfbbabi7001kveuexmsixgk8","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjq0031veue8sqzs4zz"},{"post_id":"cjfbbabi7001kveuexmsixgk8","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjq0033veueryk84g9f"},{"post_id":"cjfbbabib001nveueqsnmmtnr","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjq0034veueu1qtwlni"},{"post_id":"cjfbbabib001nveueqsnmmtnr","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjs0036veuevk6oowsy"},{"post_id":"cjfbbabfr0009veueujr2snut","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjs0037veue9w7c7may"},{"post_id":"cjfbbabfr0009veueujr2snut","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjt0039veuekqivjv0i"},{"post_id":"cjfbbabid001pveuegyy4g5dm","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjt003aveueykqorgrk"},{"post_id":"cjfbbabid001pveuegyy4g5dm","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjt003cveuej5516pzx"},{"post_id":"cjfbbabih001sveuedn0p6hg8","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabju003dveue33a6894n"},{"post_id":"cjfbbabih001sveuedn0p6hg8","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabju003fveuebrwalwjh"},{"post_id":"cjfbbabin001uveueckr3719c","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabju003gveuew21dvpdk"},{"post_id":"cjfbbabin001uveueckr3719c","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjv003iveue8cy2viys"},{"post_id":"cjfbbabir001xveueqgy5tuwa","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjv003jveuewdev8k3g"},{"post_id":"cjfbbabir001xveueqgy5tuwa","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjw003lveuejwpnf9xb"},{"post_id":"cjfbbabfw000bveuewxzx5pak","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjw003mveueehynz378"},{"post_id":"cjfbbabfw000bveuewxzx5pak","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjx003oveuer09uzx4g"},{"post_id":"cjfbbabg0000cveuemzblex1r","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabjy003pveueqr76i3vw"},{"post_id":"cjfbbabg0000cveuemzblex1r","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabjy003qveueqbyug9tn"},{"post_id":"cjfbbabg5000eveuee63rksmf","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabk0003sveue71yxc20r"},{"post_id":"cjfbbabg5000eveuee63rksmf","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabk0003tveueex555xtn"},{"post_id":"cjfbbabg7000gveueeolvnmz7","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabk0003vveueur04pinl"},{"post_id":"cjfbbabg7000gveueeolvnmz7","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabk1003wveuekneo2xlt"},{"post_id":"cjfbbabgb000jveueimj0l8oi","tag_id":"cjfbbabg3000dveuenq109ihk","_id":"cjfbbabk1003xveuenoeu0gnf"},{"post_id":"cjfbbabgb000jveueimj0l8oi","tag_id":"cjfbbabga000iveuehgsg9fg1","_id":"cjfbbabk1003yveue7qkaj034"},{"post_id":"cjfbbabiu001zveue84smn040","tag_id":"cjfbbabjl002pveueow7for1k","_id":"cjfbbabk1003zveueoxzuorh6"},{"post_id":"cjfbbabix0022veuehdjeod1x","tag_id":"cjfbbabjo002vveuejgjg5qnk","_id":"cjfbbabk20041veuexdbd91hh"},{"post_id":"cjfbbabj20024veuenz885c2s","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfbbabk20042veue8gg7s98d"},{"post_id":"cjfbbabj50029veuehjh3z0vc","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfbbabk30044veuea0peyp80"},{"post_id":"cjfbbabj7002cveue316mdew4","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfbbabk30045veuenqyuwm05"},{"post_id":"cjfbbabje002jveuen8c0vh4d","tag_id":"cjfbbabjq0032veuehlpq9fe5","_id":"cjfbbabk30048veuecb5poqn5"},{"post_id":"cjfbbabjh002mveuehs1khsi8","tag_id":"cjfbbabjv003kveue2bc5f1ie","_id":"cjfbbabk40049veuepoo6qaep"},{"post_id":"cjfbbabjh002mveuehs1khsi8","tag_id":"cjfbbabjx003nveue2kocpw55","_id":"cjfbbabk4004aveuesnpfaoh8"},{"post_id":"cjfbbabjj002oveuefj8v8gwc","tag_id":"cjfbbabjv003kveue2bc5f1ie","_id":"cjfbbabk4004bveueeerqhkb1"},{"post_id":"cjfbbabjj002oveuefj8v8gwc","tag_id":"cjfbbabjx003nveue2kocpw55","_id":"cjfbbabk5004cveue1n45v2sg"},{"post_id":"cjfbbabel0000veuehqqkznt6","tag_id":"cjfbbabjq0032veuehlpq9fe5","_id":"cjfh2ao4h00001hue7ikjo953"},{"post_id":"cjfbbabj40027veuegu8oq9qu","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfh2ao4l00011huetv31se6e"},{"post_id":"cjfbbabj9002eveueb3wlgu54","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfh2ao4r00021huexm2fmvxg"},{"post_id":"cjfbbabjc002hveueb5xiywlp","tag_id":"cjfbbabjp002zveue58uy7g74","_id":"cjfh2ao4s00031hue38ew04ps"}],"Tag":[{"name":"生活","_id":"cjfbbabf10002veueyys6x4lb"},{"name":"环境搭建","_id":"cjfbbabfl0006veue1lgyog3h"},{"name":"Go","_id":"cjfbbabfw000aveuek9nz1d7s"},{"name":"Leetcode","_id":"cjfbbabg3000dveuenq109ihk"},{"name":"算法","_id":"cjfbbabga000iveuehgsg9fg1"},{"name":"cocos2d-x","_id":"cjfbbabjl002pveueow7for1k"},{"name":"GameCenter","_id":"cjfbbabjn002sveueigi1j4wn"},{"name":"学习笔记","_id":"cjfbbabjo002vveuejgjg5qnk"},{"name":"读书笔记","_id":"cjfbbabjp002zveue58uy7g74"},{"name":"随笔","_id":"cjfbbabjq0032veuehlpq9fe5"},{"name":"脚本","_id":"cjfbbabjv003kveue2bc5f1ie"},{"name":"小技巧","_id":"cjfbbabjx003nveue2kocpw55"}]}}