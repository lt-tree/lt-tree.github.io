<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tree House</title>
  
  <subtitle>不如自挂东南枝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-28T11:46:14.308Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ltree98</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020，苦中乐</title>
    <link href="http://yoursite.com/2021/01/24/2020%EF%BC%8C%E8%8B%A6%E4%B8%AD%E4%B9%90/"/>
    <id>http://yoursite.com/2021/01/24/2020%EF%BC%8C%E8%8B%A6%E4%B8%AD%E4%B9%90/</id>
    <published>2021-01-24T13:44:35.000Z</published>
    <updated>2021-02-28T11:46:14.308Z</updated>
    
    <content type="html"><![CDATA[<p>对过去2020年的总结，及未来2021年的展望。</p><a id="more"></a><p>疫情反复，项目上线，苦中作乐</p><p><br></p><h1 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h1><p>过去的一年，很难。<br>还记得过年期间，国内疫情初起，大家被迫在家待机的时候，由于国外还未见端倪，我还在国外四处游玩，只不过已经开始谨慎的带起了口罩。<br>然后，事态日趋严重，我也慢慢收起了玩心，尽早回了国，怕晚了回不来了（果然，同去的妹妹，没有与我们一起回来，最终晚回国好久）<br>最终，大家都一起扛了过来，万物复苏，欣欣向荣，不过，最近又有复苏的迹象，为了不折腾，不惹事，我就选择对了不回家，留在北京过年了。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>正如去年年结时所说的那样，我从上家公司离职，然后在疫情如此严峻的情况下，也经由之前同事的帮助，加入了现在的公司。<br>由于入职第一年，并且恰逢新游上线；忙碌了一整年，但最终也有所收获，不负付出。<br>最大的收获，就是在行业五年，终于有一款说得上名的产品《少年三国志·零》，虽不说是从头跟到尾，但是后面也跟着经历了几次付费测试及定级测试乃至最终的正式上线。<br>所负责的功能，也从最开始的接手旧有功能的维护，到独立调研并设定新玩法的技术选型，到后面独自维护整个战斗系统。<br>虽说年会上在奖品上无所斩获，但经过这一年的努力也得到团队的认可，获得 最佳新人 的称号。</p><p><br><br><br></p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>这一年由于疫情原因加上项目上线，基本全身心投入工作中，所学所读也有限，尤其是身体上开始亮起了红灯。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>《设计模式之美》</li><li>《10x程序员工作法》</li><li>《技术领导力实战笔记》</li><li>《高效表达》</li></ul><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><ul><li>《穷爸爸富爸爸》</li><li>《能力陷阱》</li><li>《掌控习惯》</li><li>《激荡十年，水大鱼大：中国企业2008-2018》</li><li>《上帝掷骰子吗：量子物理史话》</li><li>《象与骑象人》</li><li>《笑场》</li><li>《恶魔法则》</li></ul><p><br><br><br><br><br></p><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>过去的一年，将自己霍霍的够呛，身体从前年黄灯变成了红灯，新的一年需要缓和一下了，健康才是革命的本钱。而且，过去的一年，也常因为工作，忽略了女友的感受，新的一年也要多稳固稳固女友，争取有进一步的发展。</p><p>工作上的事情，也渐入佳境，可以开始腾出手来做一些总结，扩展等事情，充分发挥主观能动性。</p><p>又到了立FLAG时间了。<br>去年立FLAG的时候，生怕完不成，悠着悠着写了仨，结果倒了俩，剩的那个也颤颤巍巍。<br>今年，我再恬不知耻的立几个吧，也得有个目标不是…</p><ul><li>减肥（这次一定）</li><li>1款小游戏</li><li>3次旅游</li><li>16场篮球</li></ul><p>新的一年，关键词依旧是 —— 乐观。</p><p>笑对工作，笑对生活，笑对世界，深呼吸，没有什么过不去的。</p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对过去2020年的总结，及未来2021年的展望。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="抽空写" scheme="http://yoursite.com/tags/%E6%8A%BD%E7%A9%BA%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>《象与骑象人》读记</title>
    <link href="http://yoursite.com/2021/01/23/%E3%80%8A%E8%B1%A1%E4%B8%8E%E9%AA%91%E8%B1%A1%E4%BA%BA%E3%80%8B%E8%AF%BB%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/01/23/%E3%80%8A%E8%B1%A1%E4%B8%8E%E9%AA%91%E8%B1%A1%E4%BA%BA%E3%80%8B%E8%AF%BB%E8%AE%B0/</id>
    <published>2021-01-23T13:00:00.000Z</published>
    <updated>2021-02-28T11:43:52.191Z</updated>
    
    <content type="html"><![CDATA[<p>人类的理性其实非常依赖于复杂的情感，只有当充满情绪的大脑运作顺畅时，理性才得以运转。</p><p>只有理性与情感携手合作，人类才会表现出聪慧的行为。</p><a id="more"></a><p><br></p><h1 id="读因"><a href="#读因" class="headerlink" title="读因"></a>读因</h1><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>《象与骑象人》是一本心理学的书，主要讲述在人的心中，有一半是桀骜不驯的感性大象，另一半则是理智的骑象人。我们常常陷于理性与非理性的战争中，这种征战不仅影响我们的生活、决策，也在不断削弱我们的幸福感。我们该如何积极地、理性地去寻找幸福。</p><p>这本书受到很多知名人士及重量级媒体推荐，是完善积极心理学领域的经典著作。</p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>作者乔纳森·海特是积极心理学的先锋派领袖之一，获得过很多奖项，也曾被《展望》杂志评为“世界顶级思想家”。</p><p>他在TED演讲过两次：</p><ul><li>宗教信仰,进化论以及自我超越的狂喜<ul><li><em>主要讲述人类下一阶段进化的可能性方向。目前是仅作为一个独立个体，以自己利益为目标进行社会活动；下一阶应是加入一个组织中，为组织的目标进行社会活动。这个组织可以是宗教，集团等等，但重要的是，是以组织的共同利益为目标而非个人。（此处仅仅是我个人理解，并不代表作者观点，也不代表我自己观点）</em></li></ul></li><li>为什么共同利益来自于共同威胁<ul><li><em>主要就是讲述为什么共同利益来自于共同威胁，若面临的威胁单方面的，就无法让另一方为了共同的利益而做出牺牲。</em></li></ul></li></ul><p><em>关于积极心理学：</em></p><ul><li><em>积极心理学是相对于之前的消极心理学。之前对于心里学问题是当疾病处理，根据病对症下药，在于修补，治疗；而积极心理学，是注重人的优点长处进行导向，在于建设，预防。</em></li><li><em>让我想起来《黄帝内经》中提出的 “上工治未病，中工治欲病，下工治已病。”</em></li></ul><p><br></p><p><br></p><p><br></p><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>这本书副标题叫做 追求幸福的假设，通过阐述象与骑象人两个角色的定位，关系来指引如何处理这两者的关系，从而追求幸福。象代表我们内心感觉、本能反应、情绪与直觉，大部分情况下都是不自主的进行，可以称作自动化处理系统；骑象人代表我们有意识的思考控制后的理性抉择，可以称作控制化处理系统。</p><p>这两者的关系是互补的，象充满活力但头脑简单，骑象人成熟睿智但精力有限，我们生活中的大部分简单的事情需要由象来完成，骑象人只需要负责处理一些少量复杂的逻辑。两者缺一不可，历史上也通过很多实验证明了这点。</p><p><strong>象与骑象人</strong>之间的冲突主要有三方面：</p><ol><li>无能的意志力<ul><li>单靠意志力，控制系统很难打败自动化系统。</li></ul></li><li>心理干扰<ul><li>反弹效应，越不让怎么样反而越不容易做到。</li></ul></li><li>冠冕堂皇的理由<ul><li>很多行为都是由大象来做，当需要解释时，骑象人会站在大象一方，拼命解释。</li></ul></li></ol><p>此外，象的自动化行为刻印在人的骨子里，它的力量非常强大，骑象人几乎不可能掌控象或代替象，只能去引导去建设；而象也不可能一直随心所欲，唯有协作，互惠共赢。</p><p><strong>什么是幸福</strong>？</p><ul><li>进展原则：朝着目标前进比达成目标要幸福</li><li>适应原则：人对现况的判断是以比自己现已适应的更好或更坏为基准</li></ul><p>幸福的方程式：</p><p>H(幸福持久度) = S(天生遗传的幸福范围) + C(生活条件) + V(自己可以控制的因素)</p><ul><li>H - 幸福持久度：</li><li>S - 天生遗传的幸福范围</li><li>C - 生活条件：指我们无法改变的事实，例如种族、性别、年龄及残障等</li><li>V - 自己可以控制的因素：指我们能改变的事实，例如财富、婚姻状况、居住地等</li></ul><p><em>积极心理学的挑战，就在于如何以科学的方法找出，到底是哪些C和V，可将H提升到我们的幸福可能范围的上限。</em></p><p><strong>追求正确的幸福</strong>：</p><ul><li>放纵感官的活动，例如吃冰淇淋<ul><li>效益并不持久，感官享乐当下感觉很强烈，但很快会消退，当事人事后不会因此而多长智慧或变得更强，反而会引诱人沉溺于其中，让人远离对自己更有益的活动。</li></ul></li><li>增强满足感的活动，例如听演讲、表达善意和感激（心流体验）<ul><li>满足感会不断鞭策我们，挑战我们的极限，逼迫我们使劲全力发挥潜能。</li></ul></li></ul><p><strong>怎样获得自我提升感</strong>：</p><ul><li>见证美德<ul><li>当我们从他人身上感受到勇敢、慈爱等美德时，就会放下防备心，并感受到幸福。</li></ul></li><li>寻求敬畏感<ul><li>当人类面对比自己宏大许多的事物时就会从心底产生敬畏。（景观景象，思想观念，社会地位等）</li><li>人类以分裂的自我在体验人生，往往被互相冲突的欲望搞得支离破碎，但敬畏感反而可以让人类产生完整、平和的感觉。</li><li><em>这也是作者认为的宗教产生的重要基础</em></li></ul></li><li>融入群体<ul><li>人类是群体性的社会动物，融入集体不但满足人类需要与他人建立联系的需求，也让我们可以脱离自我，融入集体，实现更高的目标。</li></ul></li></ul><p><br></p><p><br></p><p><br></p><h1 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h1><p>左脑的语言中枢非常擅长编出各种解释，但却不知道行为背后的真正原因。</p><p>道德判断也一样。两人对某事的意见相左时，其实是感觉在先，后来再来编理由反驳对方。就蒜你驳倒对方，难道对方就会改变心意，接受你的论调吗？当然不会，因为你驳倒的，并非对方真正的立场，他的立场是在他有了判断之后才临时编出来的。</p><p>发生在这个世界上的事情，只有通过我们自己对事件的诠释才能影响到我们，所以只要我们能控制自己对事件的诠释，就能控制自己的世界。</p><p>除非你觉得悲惨，否则没有什么是悲惨的；同理，除非你知足常乐，否则没有什么事能让你快乐。</p><p>以基因为导向、为了家族的生存愿意牺牲自我。动物愿意冒着生命危险来保护自己孩子的安全：在进化的生存竞赛中，唯一“制胜”之道就是让你身上的基因一代一代传递下去。</p><p>炫耀性消费是一种零和游戏：个人借由自己地位的提升来贬低别人。</p><p>选择的悖论：有了选择，反而让我们更不快乐，但是我们却很重视选择，而且处心积虑地要让自己有所选择。</p><p>如果你希望你的小孩健康成长、独立自主，那么你应该去拥抱、去搂、去哄、去爱他们。只要给他们一个安全堡垒，他们就能靠自己的力量去探索、征服这个世界。爱能克服恐惧，《圣经·新约》里有一段话描述的很好：“爱里没有惧怕，完全的爱可以驱除惧怕。”</p><p>英国哲学家边沁指出，所有立法的最后目标就是人的利益。所得利益越大，效果越好。边沁为功利主义之父，功利主义的教条就是，所有决策（包括立法及个人）的目标都是追求最大利益（效用），但由谁获益，功利主义者并不在意。</p><p>邪恶最大的成因是：自尊心太强及道德理想主义。</p><p>本手册目的不在教导孩子该做什么，不该做什么，以及为什么，而是要教孩子如何思考，好让他们自己决定该做什么，不该做什么，以及为什么。</p><p>对人和善，饮食不要太油腻，常看好书，多走路，要跟不同国籍及信仰的人和平共处。</p><p><br></p><p><br></p><p><br></p><hr><p>关联：</p><ul><li><a href="https://v.youku.com/v_show/id_XMjA5NDM2NzM0NA==" target="_blank" rel="noopener">乔纳森·海特: 宗教信仰,进化论以及自我超越的狂喜</a></li><li><a href="https://v.youku.com/v_show/id_XODAxNDk3NDg0.html?from=s1.8-2-1.1" target="_blank" rel="noopener">乔纳森·海特: 为什么共同利益来自于共同威胁</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人类的理性其实非常依赖于复杂的情感，只有当充满情绪的大脑运作顺畅时，理性才得以运转。&lt;/p&gt;
&lt;p&gt;只有理性与情感携手合作，人类才会表现出聪慧的行为。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="看着读" scheme="http://yoursite.com/tags/%E7%9C%8B%E7%9D%80%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《设计模式之美》学习笔记</title>
    <link href="http://yoursite.com/2020/09/20/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/09/20/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-20T13:00:00.000Z</published>
    <updated>2020-09-20T15:06:47.910Z</updated>
    
    <content type="html"><![CDATA[<p>时光不语，静等花开。</p><p>当你的能力撑不起你的野心的时候，当你感到怀才不遇的时候，当你迷茫找不着方向的时候，你只需要努力、坚持，再努力、再坚持，慢慢地，你就会变得越来越强大，方向就会变得越来越清晰，机会就会越来越青睐你。</p><a id="more"></a><p><br></p><p><br></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文是在 <strong>极客时间</strong> APP 学习 <strong>王争</strong> 老师专栏 《设计模式之美》的学习笔记。</p><p><br></p><p><br></p><h1 id="1-开篇词-amp-设计模式导读"><a href="#1-开篇词-amp-设计模式导读" class="headerlink" title="1. 开篇词 &amp; 设计模式导读"></a>1. 开篇词 &amp; 设计模式导读</h1><h2 id="为什么要学设计模式？"><a href="#为什么要学设计模式？" class="headerlink" title="为什么要学设计模式？"></a>为什么要学设计模式？</h2><ul><li>数据结构与算法是为了写出高效的代码；设计模式为了写出高质量的代码</li><li>写代码是程序员的看家本领，要做更优秀的人，要写出“好用”的代码，而不仅仅是“能用”的代码</li><li>当熟练掌握编写高质量代码的技巧、方法和理论后，写烂代码和好代码的时间基本相同</li><li>项目的代码质量可能因为各种原因有所妥协，但起码要了解高质量代码的样子，具备写出高质量代码的能力</li><li>让读源码、学框架事半功倍</li><li>应对面试，职级进阶、招聘人员、带领新手</li></ul><h2 id="如何评价代码质量的高低？"><a href="#如何评价代码质量的高低？" class="headerlink" title="如何评价代码质量的高低？"></a>如何评价代码质量的高低？</h2><ul><li><strong>可维护性</strong><ul><li>是否能够在 不破坏原有代码设计、不引入新BUG的情况下，快速的修改或添加代码</li></ul></li><li><strong>可读性</strong><ul><li>“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”  —— Martin Fowler</li><li>代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否高内聚低耦合等</li></ul></li><li><strong>可扩展性</strong><ul><li>在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码</li></ul></li><li>灵活性<ul><li>一段代码是否易扩展、易复用 或者 易使用</li></ul></li><li>简洁性<ul><li>尽量保持代码简单、逻辑清晰。是否易读、易维护</li><li>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。</li></ul></li><li>可复用性<ul><li>尽量减少重复代码的编写，复用已有的代码</li></ul></li><li>可测试性<ul><li>是否易写单元测试</li></ul></li></ul><h2 id="面向对象、设计原则、设计模式、编程规范、重构-这五者之间的关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构-这五者之间的关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构 这五者之间的关系？"></a>面向对象、设计原则、设计模式、编程规范、重构 这五者之间的关系？</h2><p>这五者都是保持或提高代码质量的方法论，本质上都是服务于编写高质量的代码。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>主流的编程范式或编程风格有三种：</p><ul><li>面向过程</li><li>面向对象</li><li>函数式编程</li></ul><p>其中，面向对象是目前最主流的；大部分流行的编程语言都是面向对象编程语言，大部分项目都是基于面向对象风格开发。</p><p>通过 面向对象的四大特性：封装、抽象、继承、多态，可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>设计原则是指导我们代码设计的一些经验总结。</p><p>这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，不能单纯地去死记硬背，要掌握每一种设计原则的初衷，了解设计原则用于解决哪些问题，应用于哪些场景，从而在实际项目中灵活恰当的使用这些原则。</p><p>常用的设计原则：</p><ul><li><strong>SOLID原则</strong><ul><li>SRP 单一职责原则</li><li>OCP 开闭原则</li><li>LSP 里氏替换原则</li><li>ISP 接口隔离原则</li><li>DIP 依赖倒置原则</li></ul></li><li>DRY原则</li><li>KISS原则</li><li>YAGNI原则</li><li>LOD原则</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。</p><p>经典的设计模式有23种。随着编程语言的演进，一些设计模式也随之过时，甚至成了反模式，一些则被内置在编程语言中，另外还有一些新的设计模式诞生。</p><p>经典的23种设计模式，可以分为三大类：</p><ul><li>创建型<ul><li>常用：<ul><li>单例模式</li><li>工厂模式</li><li>建造者模式</li></ul></li><li>不常用：<ul><li>原型模式</li></ul></li></ul></li><li>结构型<ul><li>常用：<ul><li>代理模式</li><li>桥接模式</li><li>装饰者模式</li><li>适配器模式</li></ul></li><li>不常用：<ul><li>门面模式</li><li>组合模式</li><li>享元模式</li></ul></li></ul></li><li>行为型<ul><li>常用：<ul><li>观察者模式</li><li>模板模式</li><li>策略模式</li><li>职责链模式</li><li>迭代器模式</li><li>状态模式</li></ul></li><li>不常用：<ul><li>访问者模式</li><li>备忘录模式</li><li>命令模式</li><li>解释器模式</li><li>中介模式</li></ul></li></ul></li></ul><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p>编程规范主要解决的是代码的可读性问题。相对于其他的更注重于代码的细节。基本的编程规范有 如何给变量、类、函数命名，如何写代码注释，如何写函数 等等。</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>只要软件在不停的迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在各种问题。针对这些问题，就有必要进行代码的重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p><p>重构的工具就是前面讲到的 面向对象设计思想、设计原则、设计模式、编码规范。</p><p>对于重构，要了解：</p><ul><li>重构的目的、对象、时机、方法</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性</li><li>两种不同规模的重构<ul><li>大重构，大规模高层次</li><li>小重构，小规模低层次</li></ul></li></ul><p><br></p><p><br></p><p><br></p><h1 id="2-设计原则与思想：面向对象"><a href="#2-设计原则与思想：面向对象" class="headerlink" title="2. 设计原则与思想：面向对象"></a>2. 设计原则与思想：面向对象</h1><h2 id="封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>封装、抽象、继承、多态分别可以解决哪些编程问题？</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装特性，也叫做信息隐藏或者数据访问保护。</p><p>类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持。</p><p>通过封装特性，一方面保护数据不被随意修改，提高代码的可维护性；另一方面仅暴露有限的必要接口，提高类的易用性。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象可以通过接口类或者抽象类来实现，并不需要特殊的语法机制来支持。</p><p>通过抽象特性，一方面提高代码的可扩展性、可维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承特性需要编程语言提供特殊的语法机制来支持。</p><p>主要解决代码复用的问题，但过度使用继承，继承层次过深过复杂，会导致代码可读性，可维护性变差。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多条特性需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。</p><p>多态特性能提高代码的可扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h2 id="面向对象相比面向过程有哪些优势？"><a href="#面向对象相比面向过程有哪些优势？" class="headerlink" title="面向对象相比面向过程有哪些优势？"></a>面向对象相比面向过程有哪些优势？</h2><h3 id="什么是面向过程编程与面向过程编程语言"><a href="#什么是面向过程编程与面向过程编程语言" class="headerlink" title="什么是面向过程编程与面向过程编程语言"></a>什么是面向过程编程与面向过程编程语言</h3><p>面向对象：</p><ul><li><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</p></li><li><p>面向对象编程语言是支持类或对象的语法机制，并有线程的语法机制，能方便地实现面向对象编程四大特性的编程语言。</p></li></ul><p>面向过程：</p><ul><li>面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</li><li>面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程的特性，仅支持面向过程编程。</li></ul><h3 id="面向对象编程相比面向过程编程的优势"><a href="#面向对象编程相比面向过程编程的优势" class="headerlink" title="面向对象编程相比面向过程编程的优势"></a>面向对象编程相比面向过程编程的优势</h3><ol><li>面向对象编程更加能够应对大规模复杂程序的开发</li><li>面向对象编程风格的代码更易复用、易扩展、易维护</li><li>面向对象编程语言更加人性化、更加高级、更加智能</li></ol><h2 id="看似面向对象的代码，实际上是面向过程？"><a href="#看似面向对象的代码，实际上是面向过程？" class="headerlink" title="看似面向对象的代码，实际上是面向过程？"></a>看似面向对象的代码，实际上是面向过程？</h2><h3 id="什么样的代码设计是面向过程的？"><a href="#什么样的代码设计是面向过程的？" class="headerlink" title="什么样的代码设计是面向过程的？"></a>什么样的代码设计是面向过程的？</h3><ol><li>滥用 getter、setter 方法，所有成员变量都设置getter、setter方法。</li><li>滥用全局变量和全局方法</li><li>定义数据和方法分离的类</li></ol><h3 id="为什么容易写出面向过程风格代码？"><a href="#为什么容易写出面向过程风格代码？" class="headerlink" title="为什么容易写出面向过程风格代码？"></a>为什么容易写出面向过程风格代码？</h3><ul><li><p>面向过程风格，符合人类思考习惯：先做什么，后做什么，一步步顺序执行一系列操作。</p></li><li><p>面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计需要技巧及经验。</p></li></ul><h3 id="面向过程编程已无用武之地？"><a href="#面向过程编程已无用武之地？" class="headerlink" title="面向过程编程已无用武之地？"></a>面向过程编程已无用武之地？</h3><ul><li>如果开发的是微小程序 或 以算法为主、数据为辅的数据处理相关代码，脚本式的面向过程编程风格更适合。</li><li>面向过程实际上是面向对象编程的基础，先做好面向过程，再去做好面向对象。</li><li>无论使用哪种风格代码，最终目的是写出 易维护、易读、易复用、易扩展的高质量代码；只要能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，就无须避讳在面向对象编程中写面向过程风格的代码。</li></ul><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>在面向对象编程中，抽象类和接口时两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式，设计思想，设计原则编程实现的基础。例如，可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p><h3 id="定义（what）"><a href="#定义（what）" class="headerlink" title="定义（what）"></a>定义（what）</h3><p>抽象类：</p><ul><li>不允许被实例化，只能被继承。</li><li>可以包含属性和方法。其中方法可以包含代码实现也可不包含，不包含代码实现的方法叫抽象方法。</li><li>子类继承抽象类，必须实现抽象类种所有抽象方法。</li></ul><p>接口：</p><ul><li>接口不能包含属性</li><li>接口只能声明方法，方法不能包含代码实现。</li><li>类实现接口的时候，必须实现接口中声明的所有方法。</li></ul><p>区别：</p><ul><li>抽象类表示 is-a 关系，接口表示 has-a 关系</li></ul><h3 id="解决什么问题（why）"><a href="#解决什么问题（why）" class="headerlink" title="解决什么问题（why）"></a>解决什么问题（why）</h3><p>抽象类主要解决代码复用问题，而且在实现面向对象的多态特性时更加优雅便捷。</p><p>接口主要解决设计中的解耦，它是对行为的一种抽象，调用者只需要关注接口而非具体实现。</p><h3 id="如何区分使用（how）"><a href="#如何区分使用（how）" class="headerlink" title="如何区分使用（how）"></a>如何区分使用（how）</h3><p>同定义种的区别，如果要实现 is-a 关系的设计，使用抽象类；如果要实现 has-a 关系的设计，使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类；接口正好相反，是一种自上而下的设计思路，一般先设计接口，再去考虑具体的实现。</p><h3 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h3><p>原因？</p><ul><li>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</li></ul><p>如何做？</p><ul><li>函数的命名不能暴露任何实现细节。</li><li>封装具体的实现细节。</li><li>为实现类定义抽象的接口。</li></ul><h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>为什么不推荐使用继承？</p><ul><li>继承可以解决代码复用问题。但是继承层次过深、过复杂，会影响到代码的可读性和可维护性。</li></ul><p>为什么不用组合完全替换继承？</p><ul><li>继承改写组合要做更细粒度的类的拆分，因此要定义更多的类和接口，更复杂且维护成本更高。</li></ul><p>组合如何代替继承？</p><ul><li>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。</li><li>使用 组合、接口、委托 三种技术手段来代替继承，并且避免它产生的问题。<ul><li>通过组合和接口的 has-a 关系，可以替代继承的 is-a 关系。</li><li>通过接口可以替代继承的多态特性。</li><li>通过组合和委托可以实现代码复用。</li></ul></li></ul><p>如何合理使用组合与继承？</p><ul><li>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（最多有两层继承关系），继承关系不复杂，就可以大胆的使用继承。反之，系统越不稳定，继承层次越深，继承关系越复杂，就尽量使用组合来替代继承。</li><li>某些设计模式会固定使用继承或者组合。</li></ul><h2 id="实战：-MVC-amp-DDD"><a href="#实战：-MVC-amp-DDD" class="headerlink" title="实战： MVC &amp; DDD"></a>实战： MVC &amp; DDD</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>什么是MVC？什么是DDD？</p><ul><li><p>MVC架构将整个项目分为三层：展示层（View）、逻辑层（Controller）、数据层（Model）。</p><p>它是一种软件设计典范，三层分离的方法组织代码，将业务逻辑聚集到一起，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p></li><li><p>DDD，即领域驱动设计，主要用来指导如何解耦业务系统，划分业务模块，定义业务领域及其交互。</p></li></ul><p>什么是贫血模型？什么是充血模型？</p><ul><li>贫血模型；存在只包含数据，不包含业务逻辑的类。贫血模型将数据与操作分离，破坏了面向对象的封装特性，是典型的面向过程的编程风格。</li><li>充血模型；相对于贫血模型，所有的类都包含数据和对应的业务逻辑。</li></ul><p>基于贫血模型的传统开发模式既然违反OOP，那又为什么流行？</p><ol><li>充血模型的设计相对于贫血模型更有难度。大部分情况下系统业务比较简单，用贫血模型就足以应付；即使设计好充血模型，由于业务逻辑不多，表现出的样子和贫血模型差不多，没有太大意义。</li><li>思维固化，转型有成本。基于贫血模型的传统开发模式经历了很多年，已经深入人心，并且没有出过大的差错，在这种情况下进行转型，没有太大收益，成本却很大。</li></ol><p>什么情况下我们应该考虑使用基于充血模型的DDD开发模式？</p><ul><li>业务复杂的系统开发适合使用DDD开发模式。越复杂的系统，对代码的复用性、易维护性要求越高，就应该花费更多的时间和精力在前期设计上。基于充血模型的DDD开发模式，需要前期做大量的业务调研、领域模型设计，因此更加适合复杂系统的开发。</li></ul><h2 id="实战：面向对象开发"><a href="#实战：面向对象开发" class="headerlink" title="实战：面向对象开发"></a>实战：面向对象开发</h2><p>面向对象开发的三个环节：</p><ol><li>面向对象分析（OOA）</li><li>面向对象设计（OOD）</li><li>面向对象编程（OOP）</li></ol><h3 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h3><p>需求分析的整个过程，从最粗糙、最模糊的需求开始，通过“提出问题-解决问题”的方式，循序渐进的优化，最后得到一个足够清晰、可落地的需求描述。</p><p>明确需求：</p><p>将笼统的需求细化到足够清晰、可执行。通过 沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。</p><p>具体分析：</p><ol><li>基础分析<ul><li>从最简单的方案想起，再去优化。（先实现，再优化）</li></ul></li><li>分析优化（有多轮）<ul><li>不断探寻优化点，判断优化的成本收益比而是否要做。</li></ul></li><li>最终确定需求<ul><li>确定需求，可用文本或者时序图、流程图等描述。</li></ul></li></ol><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>面向对象分析的产物是详细的需求描述。面向对象设计的产出是类。</p><p>在这一环节，将描述转化为具体的类的设计，可以分为下面几部分：</p><ol><li>划分职责进而识别出有哪些类</li><li>定义类及其属性和方法</li><li>定义类与类之间的交互关系</li><li>将类组装起来并提供执行入口</li></ol><p><br></p><p><br></p><p><br></p><h1 id="3-设计原则与思想：设计原则"><a href="#3-设计原则与思想：设计原则" class="headerlink" title="3. 设计原则与思想：设计原则"></a>3. 设计原则与思想：设计原则</h1><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>SOLID 原则：</p><ul><li>S，Single Responsibility Principle（SRP），单一职责原则</li><li>O，Open Closed Principle（OCP），开闭原则</li><li>L，Liskov Substitution Principle（LSP），里氏替换原则</li><li>I，Interface Segregation Principle（ISP），接口隔离原则</li><li>D，Dependency Inversion Principle（DIP），依赖反转原则</li></ul><h3 id="单一职责原则（SRP，Single-Responsibility-Principle）"><a href="#单一职责原则（SRP，Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SRP，Single Responsibility Principle）"></a>单一职责原则（SRP，Single Responsibility Principle）</h3><p>描述：</p><ul><li>A class or moudle should have a single reponsibility.</li></ul><p>重点：</p><ul><li>类或模块的职责是否单一<ul><li>判定标准：<ul><li>类中代码行数、函数或属性过多</li><li>类依赖的其他类过多，或依赖类的其他类过多</li><li>私有方法过多</li><li>难以给类起合适的名字</li><li>类中大量的方法都是集中操作类中的某几个属性</li></ul></li></ul></li></ul><p>应用：</p><ul><li>先实现一个粗粒度的类，满足业务需求。随着业务发展，粗粒度的类越来越庞大，代码越来越多时，对粗粒度类进行重构，拆分成几个更细粒度的类，进行持续重构。</li></ul><h3 id="开闭原则（OCP，Open-Closed-Principle）"><a href="#开闭原则（OCP，Open-Closed-Principle）" class="headerlink" title="开闭原则（OCP，Open Closed Principle）"></a>开闭原则（OCP，Open Closed Principle）</h3><p>描述：</p><ul><li>Software entities(modules, classes, functions, etc.) should be open for extension, but closed for modification.</li></ul><p>重点：</p><ul><li>对扩展开放，对修改关闭<ul><li>认识：添加一个新的功能，应该是通过在已有代码基础上扩展代码，而非修改已有代码的方式来完成。但并不代表完全杜绝修改，而是以最小的代价来完成新功能的开发。同样的代码改动，在粗粒度中可能认定为“修改”，在细粒度中，可能认定为“扩展”。</li></ul></li></ul><p>应用：</p><ul><li>在编写代码时，时刻具备扩展意识、抽象意识、封装意识。充分理解需求的原因及变更方向，事先留好扩展点。</li></ul><h3 id="里氏替换原则（LSP，Liskov-Substitution-Principle）"><a href="#里氏替换原则（LSP，Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（LSP，Liskov Substitution Principle）"></a>里氏替换原则（LSP，Liskov Substitution Principle）</h3><p>描述：</p><ul><li>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program. (1986, Barbara Liskov 提出)</li><li>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.(1996, Robert Martin 重述)</li></ul><p>重点：</p><ul><li>子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性<ul><li>三种典型违背情况<ul><li>子类违背父类声明要实现的功能</li><li>子类违背父类对输入、输出、异常的约定</li><li>子类违背父类注释中所罗列的任何特殊说明</li></ul></li><li>与多态的区别<ul><li>多态是面向对象编程中的一大特性，也是面向对象编程语言的一种语法，是一种代码实现思路。</li><li>里氏替换是一种设计原则，用来指导继承关系中子类的设计方法：子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li></ul></li></ul></li></ul><p>应用：</p><ul><li>父类定义了函数的的“约定”，子类可以变函数的内部实现逻辑，但不能改变函数原有的“约定”。<ul><li>这里的“约定”包括：<ul><li>函数声明要实现的功能</li><li>对输入、输出、异常的约定</li><li>注释中所罗列的任何特殊说明</li><li>等</li></ul></li></ul></li></ul><h3 id="接口隔离原则（ISP，Interface-Segregation-Principle）"><a href="#接口隔离原则（ISP，Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（ISP，Interface Segregation Principle）"></a>接口隔离原则（ISP，Interface Segregation Principle）</h3><p>描述：</p><ul><li>Clients should not be forced to depend upon interfaces that they do not use.</li></ul><p>重点：</p><ul><li>对接口的三种理解<ul><li>一组接口集合：如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li><li>单个API接口或函数：如果部分调用者只需要函数中的部分功能，就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的细粒度函数。</li><li>OOP中的接口：需要将接口的设计单一化，不要让接口的实现类和调用者依赖不需要的接口函数。</li></ul></li><li>与单一职责原则的区别<ul><li>单一职责原则是对模块、类、接口的设计。</li><li>接口隔离原则一方面更侧重于接口的设计，另一方面提供了一种判断接口的职责是否单一的标准。<ul><li>标准：通过调用者如何使用接口来间接地判定，如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</li></ul></li></ul></li></ul><p>应用：</p><ul><li>根据对接口的不同理解，进行不同的设计。</li></ul><h3 id="依赖反转原则（DIP，Dependency-Inversion-Principle）"><a href="#依赖反转原则（DIP，Dependency-Inversion-Principle）" class="headerlink" title="依赖反转原则（DIP，Dependency Inversion Principle）"></a>依赖反转原则（DIP，Dependency Inversion Principle）</h3><p>描述：</p><ul><li>High-level modules shouldn’t depend on low-level modules.Both modules should depend on abstractions.In addition, abstractions shouldn’t depend on details.Details depend on abstractions.</li></ul><p>重点：</p><ul><li>控制反转：一种指导框架层面设计的思想。从程序员自己控制整个程序执行的流程，通过使用框架，实现框架来控制整个程序执行流程。（控制权从程序员“反转”给了框架）</li><li>依赖注入：一种编程技巧。不通过new的方式在类内创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</li><li>依赖注入框架：通过依赖注入框架提供的扩展点，简单配置所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</li></ul><p>应用：</p><ul><li>Tomcat</li></ul><p><br></p><h2 id="KISS原则-与-YAGNI原则"><a href="#KISS原则-与-YAGNI原则" class="headerlink" title="KISS原则 与 YAGNI原则"></a>KISS原则 与 YAGNI原则</h2><h3 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h3><p>KISS原则：(几个版本）</p><ul><li>Keep It Simple and Stupid</li><li>Keep It Short and Simple</li><li>Keep It Simple and Straightforward</li></ul><p>大概都可以翻译为：尽量保持简单。</p><p>KISS原则是保持代码可读性和可维护性的重要手段。</p><p>如何写出满足KISS原则的代码？</p><ul><li>不要使用同事可能不懂的技术来实现代码。比如正则表达式，一些语言中的高级语法等</li><li>不要重复造轮子，要善于使用已经有的工具类库。</li><li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算数运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li><li>KISS原则要综合考虑 逻辑复杂度、实现难度、代码可读性、代码行数等；本身复杂的问题，用复杂的方法解决，并不违背KISS原则。同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。</li></ul><h3 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h3><p>YAGNI原则：</p><ul><li>You Ain’t Gonna Need It</li></ul><p>核心思想：不要做过度设计</p><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>KISS &amp; YAGNI：</p><ul><li>KISS原则是保持代码可读性与可维护性的重要手段。主要讲 “如何做” 的问题（尽量保持简单）。</li><li>YAGNI原则核心思想是不要做过度设计。主要讲 “要不要做” 的问题（当前不需要的就不要做）。</li></ul><p><br></p><h2 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h2><p>DRY原则</p><ul><li>Don’t Repeat Yourself</li></ul><p>三种代码重复：</p><ul><li>实现逻辑重复</li><li>功能语义重复</li><li>代码执行重复</li></ul><p>违反原则情况：</p><ul><li>实现逻辑重复、功能语义不重复；不违反DRY原则</li><li>实现逻辑不重复、功能语义重复；违反DRY原则</li><li>代码执行重复；违反DRY原则</li></ul><p>代码复用性（Code Reusability） &amp; 代码复用（Code Resue） &amp; DRY原则</p><ul><li>定义：<ul><li>代码复用性：一种特性或能力，在编写代码的时候，尽量保证代码可被复用。</li><li>代码复用：一种行为，在开发新功能的时候，尽量复用已经存在的代码。</li><li>DRY原则：一条原则，不要写重复的代码</li></ul></li><li>区别：<ul><li>“不重复” 并不代表 “可复用”</li><li>“复用” 和 “可复用性” 关注的角度不同</li></ul></li></ul><p>如何提高代码复用性：</p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><p>Rule of Three 原则：</p><ul><li>第一次编写代码的时候，不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。</li></ul><p><br></p><h2 id="迪米特法则（LOD-Law-of-Demeter）"><a href="#迪米特法则（LOD-Law-of-Demeter）" class="headerlink" title="迪米特法则（LOD, Law of Demeter）"></a>迪米特法则（LOD, Law of Demeter）</h2><p>迪米特法则（Law of Demeter，The Least Knowledge Principle）</p><ul><li>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.Or: Each unit should only talk to its friends; Don’t talk to strangers.</li></ul><p>迪米特法则可以帮助实现代码 “高内聚、松耦合”，从而有效的提高代码的可读性与可维护性，缩小功能改动导致的代码改动范围。</p><p>高内聚、松耦合：</p><ul><li>一个设计思想，能够有效的提高代码可读性与可维护性。“高内聚” 用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</li><li>高内聚，指相近的功能应该放在同一个类中，不想近的功能不要放在同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</li><li>松耦合，指类与类之间的依赖关系简单清晰。两个类有依赖关系，一个类的代码改动也不会或很少导致依赖类的代码改动。</li></ul><p>如何理解 迪米特法则：</p><ul><li>不该有直接依赖关系的类之间，不要有依赖</li><li>有依赖关系的类之间，尽量只依赖必要的接口</li><li>迪米特法则是希望减少类之间的耦合，让类越独立越好</li></ul><p><br></p><p><br></p><p><br></p><h1 id="4-设计原则与思想：规范与重构"><a href="#4-设计原则与思想：规范与重构" class="headerlink" title="4. 设计原则与思想：规范与重构"></a>4. 设计原则与思想：规范与重构</h1><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p><strong>很多技术问题本身就不是单纯靠技术来解决的，更重要的是要有这种认知和意识。</strong></p><h3 id="Why-重构的目的"><a href="#Why-重构的目的" class="headerlink" title="Why - 重构的目的"></a>Why - 重构的目的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</span><br><span class="line"></span><br><span class="line">—— Martin Fowler</span><br></pre></td></tr></table></figure><p>重点：</p><ul><li><strong>重构不改变外部的可见行为</strong></li></ul><p>进一步理解：</p><ul><li>在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。</li><li>重构对工程师本身的技术成长有重要意义。<ul><li>初级工程师在维护代码</li><li>中级工程师在设计代码</li><li>高级工程师在重构代码</li></ul></li></ul><p><br></p><h3 id="What-重构的对象"><a href="#What-重构的对象" class="headerlink" title="What - 重构的对象"></a>What - 重构的对象</h3><p>根据重构的规模，可以分为：</p><ul><li>大型重构：大规模、高层次的重构<ul><li>对象：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系</li><li>手段：更多的利用 设计思想、原则、模式；比如：分层、模块化、解耦、抽象可复用组件</li><li>影响：涉及代码改动多，影响面大，难度大，耗时长，风险大</li></ul></li><li>小型重构：小规模、低层次的重构<ul><li>对象：对代码细节的重构，包括：类、函数、变量等</li><li>手段：更多的利用编码规范；比如：规范命名、规范注释、消除超大类或函数、提取重复代码</li><li>影响：修改集中，比较简单，可操作性强，耗时短，风险小</li></ul></li></ul><p><br></p><h3 id="When-重构的时机"><a href="#When-重构的时机" class="headerlink" title="When - 重构的时机"></a>When - 重构的时机</h3><p>两个不要：</p><ul><li>不要等到代码烂到一定程度，再去重构</li><li>不要花尽心思去构思完美设计，避免以后的重构</li></ul><p>要有 <strong>持续重构意识</strong></p><ul><li>正确的看待代码质量和重构</li><li>代码质量总会因各种原因下降，代码总会存在不完美，避免开发初期的过度设计</li></ul><p><br></p><h3 id="How-重构的方法"><a href="#How-重构的方法" class="headerlink" title="How - 重构的方法"></a>How - 重构的方法</h3><p>针对大型重构</p><ul><li>有组织、有计划的进行，分阶段地小步快跑，时刻让代码处于可运行的状态</li></ul><p>针对小型重构</p><ul><li>看个人意愿，随时随地都可以去做</li></ul><h4 id="重构技巧之-代码的可测试性"><a href="#重构技巧之-代码的可测试性" class="headerlink" title="重构技巧之 代码的可测试性"></a>重构技巧之 代码的可测试性</h4><p>代码的可测试性就是针对代码编写单元测试的难易程度。</p><p>依赖注入是编写可测试性代码的最有效手段。</p><p>常见的测试不友好的代码类型：（Anti-Patterns）</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h4 id="重构技巧之-单元测试"><a href="#重构技巧之-单元测试" class="headerlink" title="重构技巧之 单元测试"></a>重构技巧之 单元测试</h4><p>单元测试是保证代码质量最有效的两个手段之一（单元测试 &amp; Code Review）</p><p>为什么要写单元测试：</p><ol><li>能有效地帮助发现代码中的bug</li><li>能帮助发现代码设计上的问题</li><li>是对集成测试的有力补充</li><li>写单元测试的过程本身就是代码重构的过程</li><li>阅读单元测试能帮助快速熟悉代码</li><li>单元测试是TDD(Test-Driven Development 测试驱动开发)可落地执行的改进方案</li></ol><p>树立编写单元测试的正确认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时</li><li>可以稍微放低对单元测试代码质量的要求</li><li>覆盖率作为衡量单元测试质量的唯一标准是不合理的</li><li>单元测试不要依赖被测试代码的具体实现逻辑</li><li>单元测试框架无法测试，多半是因为代码的可测试性不够好</li></ul><p>为何一般难以落地执行：</p><ul><li>写单元测试比较繁琐，技术挑战不大，程序员意愿低</li><li>很多研发偏向：快、糙、猛，容易因为开发进度紧，导致单元测试的执行虎头蛇尾</li><li>团队没有建立对单元测试正确的认知</li></ul><h4 id="重构技巧之-解耦"><a href="#重构技巧之-解耦" class="headerlink" title="重构技巧之 解耦"></a>重构技巧之 解耦</h4><p>大型重构最有效的一个手段</p><p>解耦的重要性</p><ul><li>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。</li></ul><p>判断是否需要解耦：</p><ul><li>看修改代码是否要牵一发而动全身</li><li>根据模块之间、类之间的依赖关系图的复杂度</li></ul><p>如何解耦：</p><ul><li>封装与抽象</li><li>添加中间层</li><li>模块化</li><li>设计思想与原则<ul><li>单一职责</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>多用组合少用继承</li><li>迪米特法则</li></ul></li><li>设计模式<ul><li>观察者模式</li></ul></li></ul><h4 id="20条编码规范"><a href="#20条编码规范" class="headerlink" title="20条编码规范"></a>20条编码规范</h4><p><strong>最重要的的一点：统一编码规范！！</strong></p><h5 id="命名与注释（Naming-and-Comments）"><a href="#命名与注释（Naming-and-Comments）" class="headerlink" title="命名与注释（Naming and Comments）"></a>命名与注释（Naming and Comments）</h5><ul><li><strong>命名的长度</strong>：命名的关键是能准确达意。对于不同作用域的命名，可以适当地选择不同长度。作用域小的变量（比如临时变量），可以适当地短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li><li><strong>简化命名</strong>：可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li><strong>命名需可读、可搜索</strong>：不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范。</li><li><strong>接口与抽象类的命名</strong>：<ul><li>接口有两种方式命名，一种是在接口中带前缀“I”，另一种是在接口的实现类中带后缀“Impl”。</li><li>抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，另一种是不带前缀。</li><li>无论采用哪种，关键是要在项目中统一</li></ul></li><li><strong>注释的目的</strong>：注释目的是让代码更容易看懂。只要符合这个要求，就可以将它写到注释里。注释的内容主要包含三个方面：做什么、为什么、怎么做。对于一些复杂的类与接口，可能还需要写明 如何用。</li><li><strong>注释的数量</strong>：注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li></ul><h5 id="代码风格（Code-Style）"><a href="#代码风格（Code-Style）" class="headerlink" title="代码风格（Code Style）"></a>代码风格（Code Style）</h5><ul><li><strong>函数、类的大小</strong>：函数的代码尽量不要超过一屏幕的大小，例如50行。</li><li><strong>一行代码长度</strong>：一行代码尽量不要超过IDE显示的宽度，也不要太小。</li><li><strong>善用空行分割单元块</strong>：对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li><li><strong>缩进大小</strong>：四格缩进与两格缩进，尽量使用两格缩进，可以节省空间，特别是在代码嵌套层次比较深的情况下。尽量不要使用tab键缩进。</li><li><strong>大括号是否另起一行</strong>：推荐大括号放到跟上一条语句同行的风格，可以节省代码行数。</li><li><strong>类中成员的排列顺序</strong>：依赖类按照字母序从小到大排列。类中先写成员变量，后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</li></ul><h5 id="编程技巧（Coding-Tips）"><a href="#编程技巧（Coding-Tips）" class="headerlink" title="编程技巧（Coding Tips）"></a>编程技巧（Coding Tips）</h5><ul><li>将复杂的逻辑提炼拆分成函数和类</li><li>通过拆分多个函数或将参数封装为对象的方式，来处理参数过多的情况</li><li>函数中不要使用参数来做代码执行逻辑的控制</li><li>函数涉及要职责单一</li><li>移除过深的嵌套层次，方法包括：<ul><li>去除多余的 if 或 else 语句</li><li>使用 continue、break、return 关键字，提前退出嵌套</li><li>调整执行顺序来减少嵌套</li><li>将部分嵌套逻辑抽象成函数</li></ul></li><li>用字面常量取代魔法数</li><li>用解释性变量来解释复杂表达式，以此提高代码可读性</li></ul><p><br></p><p><br></p><p><br></p><h1 id="5-设计模式与范式"><a href="#5-设计模式与范式" class="headerlink" title="5. 设计模式与范式"></a>5. 设计模式与范式</h1><p>设计模式主要做的事情就是解耦：</p><ul><li>创建型模式<ul><li>解决：<ul><li>对象的创建问题，封装复杂的创建过程</li></ul></li><li>方式：<ul><li>将 创建代码 和 使用代码 解耦</li></ul></li><li>包含：<ul><li>单例模式</li><li>工厂模式</li><li>建造者模式</li><li>原型模式</li></ul></li></ul></li><li>结构型模式，<ul><li>解决：<ul><li>类或对象的组合问题</li></ul></li><li>方式：<ul><li>将 不同功能的代码 解耦</li></ul></li><li>包含：<ul><li>代理模式</li><li>桥接模式</li><li>装饰器模式</li><li>适配器模式</li><li>门面模式</li><li>组合模式</li><li>享元模式</li></ul></li></ul></li><li>行为型模式，<ul><li>解决：<ul><li>类或对象之间的交互问题</li></ul></li><li>方式：<ul><li>将 不同的行为代码 解耦</li></ul></li><li>包含：<ul><li>观察者模式</li><li>模板模式</li><li>策略模式</li><li>职责链模式</li><li>迭代器模式</li><li>状态模式</li><li>访问者模式</li><li>备忘录模式</li><li>命令模式</li><li>解释器模式</li><li>中介模式</li></ul></li></ul></li></ul><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><ul><li>单例模式用来创建全局唯一的对象</li><li>工厂模式用来创建不同但相关类型的对象（继承同一父类或接口的一组子类），由给定的参数来决定创建哪种类型对象</li><li>建造者模式用来创建复杂对象，可通过设置不同的可选参数，“定制化”地创建不同的对象</li><li>原型模式针对创建成本比较大的对象，利用已有对象进行复制的方式创建，以达到节省创建时间的目的</li></ul><p><br></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>概念：</p><ul><li>一个类只允许创建一个对象（或实例）</li></ul><p>应用场景：</p><ul><li>处理资源访问冲突<ul><li>主要解决多线程时的冲突</li><li>其他解决方法还有：分布式锁、并发队列等</li><li>相对来说，单例模式方案更加简单</li></ul></li><li>表示全局唯一类</li></ul><p>实现重点：</p><ul><li>构造函数需要是private访问权限，避免外部通过new创建实例</li><li>考虑对象创建时的线程安全问题</li><li>考虑是否支持延迟加载</li><li>考虑 getInstance() 性能是否高（是否加锁）</li></ul><p>实现方案：</p><ol><li><p>饿汉式</p><ul><li><p>方式：在类加载的时候，instance 静态实例就已经创建并初始化好。</p></li><li><p>缺点：不支持延迟加载，若占用资源多或初始化时间长，提前初始化会浪费资源。</p></li></ul></li><li><p>懒汉式</p><ul><li><p>方式：在调用的时候，判断是否存在，并加锁创建实例</p></li><li><p>缺点：由于加锁，导致 getInstance() 性能低。若频繁使用，会导致性能瓶颈</p></li></ul></li><li><p>双重检测</p><ul><li>方式：在instanc被创建后，加类级别的锁，避免再次加锁</li><li>缺点：有可能因为指令重排序导致其他问题</li></ul></li><li><p>静态内部类</p></li><li><p>枚举</p></li></ol><p>存在的问题：</p><ul><li>单例对OOP特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>替代方案：</p><ul><li>用静态方法来实现</li><li>通过工厂模式、IOC容器来保证，由程序员来保证</li></ul><p>其他：</p><ul><li>如何理解单例模式的唯一性<ul><li>单例类中对象的唯一性的作用范围是“进程唯一”的。</li><li>“进程唯一”指的是进程为内唯一，进程间不唯一（即 线程内唯一，线程间也唯一）</li><li>“线程唯一”指的是线程内唯一，线程间不唯一</li><li>“集群唯一”指的是进程内唯一、进程间也唯一</li></ul></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>概念：</p><ul><li>可以分为 简单工厂、工厂方法、抽象工厂。（简单工厂模式可看作是工厂方法模式的一种特例）</li><li>解耦对象的创建与使用</li></ul><p>应用场景：</p><ul><li>当创建逻辑比较复杂，是个”大工程“的时候，可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用分离。</li><li>第一种情况：类似规则配置解析，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。将这一大坨 if-else 创建对象的代码分离出来，放到工厂类中。</li><li>第二种情况：尽管不需要根据不同的类型创建不同的对象，但是单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类的对象，做各种初始化操作。此时，也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</li></ul><p>实现重点：</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>DI容器：（依赖注入容器  Dependency Injection COntainer）</p><ul><li>DI容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。</li><li>实现逻辑主要包括：<ul><li>配置文件解析</li><li>对象创建</li><li>对象的生命周期管理</li></ul></li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>概念：</p><ul><li>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，可以通过构造函数配合set的方法解决。但是若存在下面情况任意一种，需考虑使用建造者模式：<ul><li>必填属性很多，通过set方法设置，但是校验必填属性的逻辑无处安放</li><li>类的属性之间有一定的依赖关系或约束条件。依赖关系或约束条件的校验逻辑无处安放</li><li>创建不可变对象，不能暴露set方法，无法通过set方法赋值</li></ul></li></ul><p>与工厂模式的区别：</p><ul><li>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），有给定的参数来决定创建哪种类型的对象。</li><li>建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”的创建不同的对象。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>概念:</p><ul><li>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大时，可以利用对已有对象（原型）进行复制（或叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。</li></ul><p>实现方法：</p><ul><li>深拷贝。深拷贝得到的是一份完完全全独立的对象。</li><li>浅拷贝。浅拷贝指挥复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的对象</li><li>深拷贝更加耗时，耗空间。</li></ul><p><br></p><p><br></p><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><p>结构型模式主要总结一些类或对象组合在一起的经典结构；这些结构可以解决特定应用场景的问题。</p><p><br></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>概念：</p><ul><li>在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能</li></ul><p>应用场景：</p><ul><li>业务系统的非功能性需求开发。如：监控、统计、鉴权、限流、事务、幂等、日志。将附加功能与业务功能解耦，放到代理类中统一处理，程序员只需要关注业务方面开发。</li><li>在RPC、缓存中的应用。</li></ul><p>实现方式：</p><ul><li>静态代理类，针对每个类都创建一个代理类。但每个代理类中的代码都存在像模板式的“重复”代码，增加了维护成本和开发成本。</li><li>动态代理类，不事先为每个原始类编写代理类，而是在运行时动态地创建原始类对应的代理类，然后在系统中用给代理类替换掉原始类。</li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>概念：</p><ul><li>将抽象与实现解耦，让它们可以独立变化<ul><li>此处“抽象”并非“抽象类”或“接口”，而是被“抽象”出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起</li></ul></li><li>一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展</li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>概念：</p><ul><li>解决继承关系过于复杂的问题，通过组合替代继承。主要作用是给原始类添加增强功能。</li></ul><p>其他：</p><ul><li>装饰器类和原始类继承同样的父类，这样可以对原始类“嵌套”多个装饰器类</li><li>装饰器类是对功能的增强，这也是装饰器模式应用场景的重要特点</li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>概念：</p><ul><li>将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作</li></ul><p>应用场景：</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ul><p>代理、桥接、装饰器、适配器 四种模式的区别：</p><ul><li>共性：代理、桥接、装饰器、适配器，这四种模式都是比较常用的结构型设计模式。代码结构非常相似，都可以成为Wrapper模式，也就是通过Wrapper类二次封装原始类</li><li>不同：<ul><li>代理模式，在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是与装饰器模式的最大不同</li><li>桥接模式，目的是将接口部分和实现部分分离，从而让它们较为容易且相对独立的改变</li><li>装饰器模式，在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</li><li>适配器模式，是一种事后的补救策略，适配器提供跟原始类不同的接口，而代理模式、装饰器模式都提供相同的接口</li></ul></li></ul><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>概念：</p><ul><li>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用</li></ul><p>应用场景：</p><ul><li>解决易用性的问题</li><li>解决性能问题</li><li>解决分布式事务问题</li></ul><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>概念：</p><ul><li>将一组对象组织成树形结构，以表示一种“部分-整体”的层次结构。组合让代码使用者可以统一单个对象和组合对象的处理逻辑。</li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>概念：</p><ul><li>享元模式意图是复用对象，节省内存，前提是享元对象是不可变对象</li><li>当一个系统中存在大量重复对象的时候，如果这些重复对象是不可变对象，可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多出代码引用。这样可减少内存中对象的数量，起到节省内存的目的。</li><li>不可变对象是指，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或属性）就不会再被修改</li></ul><p>实现：</p><ul><li>通过工厂模式，在工厂类中，通过一个Map或者List来缓存已经创建好的享元对象，以达到复用的目的。</li></ul><p>享元模式与单例模式的区别：</p><ul><li>单例模式中一个类只能创建一个对象。单例模式的设计意图是限制对象个数。</li><li>享元模式中，一个类可以创建多个对象，每个对象被多出代码引用共享（实际上，有些类似于多例）。享元模式的设计意图是对象复用，节省内存。</li></ul><p>享元模式与缓存的区别：</p><ul><li>享元模式的实现中，通过工厂类来“缓存”已创建好的对象。此处缓存即为存储。</li><li>平时所说的缓存，主要是为了提高访问效率，而非复用。</li></ul><p>享元模式与对象池的区别：</p><ul><li>池化技术的复用可以理解为“重复使用”，主要目的是节省时间。</li><li>享元模式中的复用可以理解为“共享使用”，主要目的是节省空间。</li></ul><p><br></p><p><br></p><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>概念：</p><ul><li>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</li><li>通常来说，被依赖的对象叫做 被观察者（Obserable），依赖的对象叫做 观察者（Observer）</li><li>解耦观察者与被观察者</li></ul><p>实现：</p><ul><li>同步阻塞是最经典的实现方式，主要为了代码解耦</li><li>异步非阻塞，除了能实现代码解耦，还可以提高代码的执行效率</li><li>进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现</li></ul><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>概念：</p><ul><li>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</li><li>此处的“算法”，可以理解为广义上的 “业务逻辑”，并不是特指数据结构与算法中的“算法”</li></ul><p>作用：</p><ul><li>复用<ul><li>所有的子类可以复用父类中提供的模板方法的代码</li></ul></li><li>扩展<ul><li>并非代码的扩展性，而是指框架的扩展性</li><li>框架通过模板模式提供功能扩展点，让框架用户在不修改框架源码情况下，基于扩展点定制化框架的功能</li></ul></li></ul><p>模板模式 与 回调：</p><ul><li>回调简介<ul><li>概念：相对于普通的函数来说，回调是一种双向调用关系。A类事先注册某个函数1到B类，A类在调用B类函数2的时候，B类反过来调用A类注册给它的函数1。这里的函数1叫做 回调函数。A调用B，B反过来又调用A，这种调用机制叫做 回调。</li><li>分类：回调可以分为同步回调与异步回调（或叫做延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指函数返回之后执行回调函数。</li></ul></li><li>区别：<ul><li>从应用场景上来看，同步回调与模板模式几乎一致，都是在一个大的算法骨架中，自由替换其中某个步骤，起到代码复用与扩展的目的；而异步回调跟模板模式有较大的区别，更像是观察者模式</li><li>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</li></ul></li><li>组合优于继承，回调相对于模板模式会更加灵活<ul><li>对于只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不在具有继承能力</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类</li><li>如果某个类中定义了多个模板方法，每个方法都有相对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法；而回调就更加灵活，只需要往用到的模板方法中注入回调对象即可。</li></ul></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>概念：</p><ul><li>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端代码（调用者）。</li><li>策略模式用于解耦策略类的定义、创建、使用<ul><li>策略类的定义，包含一个策略接口和一组实现这个接口的类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</li><li>策略类的创建，在使用的时候，一般会通过类型来判断创建哪个策略类使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节，可以把根据类型创建策略的逻辑抽离出来，放到工厂类中。</li><li>策略类的使用，策略模式可以包含一组可选策略，客户端代码可以在运行时动态确定使用哪组策略。</li></ul></li></ul><p>应用：</p><ul><li>移出 if-else 分支判断<ul><li>实际上是使用策略工厂类，借助 查表法，根据类型查表替代根据类型分支判断</li></ul></li></ul><p>策略模式与工厂模式区别</p><ul><li>工厂模式<ul><li>目的是创建不同且相关的对象</li><li>侧重于 创建对象</li><li>实现方式上通过父类或者接口</li><li>一般创建对象应该是现实世界中某种事物的映射，有它自己的属性与方法</li></ul></li><li>策略模式<ul><li>目的是实现方便地替换不同的算法类</li><li>侧重于算法（行为）实现</li><li>实现方式上通过接口</li><li>创建对象对行为的抽象而非对对象的抽象，一般没有属于自己的属性</li></ul></li></ul><p>其他：</p><ul><li>一提到策略模式，有人就认为它的作用是避免if-else分支判断逻辑。实际上这是很片面的。策略模式的主要作用是解耦策略的定义、创建与使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂的代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化集中化代码改动，减少引入bug的风险。</li><li>实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式。</li></ul><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>概念：</p><ul><li>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</li><li>标准的职责链模式，依次执行，有可处理的或异常就终止；变体职责链模式，顺序执行，不终止。</li><li>实现上可通过链表或者数组</li></ul><p>应用：</p><ul><li>应对代码的复杂性。将大块代码逻辑拆分成函数，将大类拆分成小类。</li><li>让代码满足开闭原则，提高可扩展性。</li><li>具体应用场景：开发框架的过滤器与拦截器功能</li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>有限状态机（Finite State Machine  FSM）：</p><ul><li>概念：状态机由三部分组成 状态（State）、事件（Event）/ 转移条件（Transition Condition）、动作（Action）。事件触发状态的转移及动作的执行，不过动作不是必须的，也可能只转移状态，不执行动作。</li><li>实现方式：<ul><li>分支逻辑法，参照状态转移图，将每一个状态转移，原模原样的直译成代码。这样编写会有大量的 if-else 或 switch-case 分支判断逻辑。局限在于可维护性差，无法实现复杂的状态机。</li><li>查表法，参照状态转移图，构建二维表。一般以第一维度表示当前状态，第二维度表示事件，值表示当前状态经过事件之后，转移到的新状态及要执行的动作。相对于分支逻辑法，查表法更清晰，可读性与可维护性更好。局限在于只能实现执行简单的动作逻辑。</li><li>状态模式，将事件触发的状态转移和动作执行，拆分到不同状态类中。局限在于引入非常多的状态类，若状态比较多，维护复杂度高。</li></ul></li></ul><p>应用：</p><ul><li>像游戏这种比较复杂的状态机，优先推荐查表法，状态模式会引入非常多的状态类，会导致代码比较难以维护。像电商下单、外卖下单这种类型状态机，状态并不多，状态转移也简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，更推荐使用状态模式来实现。</li></ul><h3 id="迭代器模式-游标模式"><a href="#迭代器模式-游标模式" class="headerlink" title="迭代器模式/游标模式"></a>迭代器模式/游标模式</h3><p>概念：</p><ul><li>用来遍历集合对象（/容器/聚合对象），实际上就是包含一组对象的对象，例如 数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更单一。</li><li>一个完整的迭代器涉及 容器 和 容器迭代器 两部分。为了基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含 迭代器接口、迭代器实现类。</li></ul><p>实现方式：</p><ul><li>迭代器中需要定义 hasNext 、currentItem 、next 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中，容器通过 iterator 方法来创建迭代器。</li></ul><p>优势/作用：</p><ul><li>封装集合内部复杂的数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。</li><li>将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更单一。</li><li>让添加新的遍历算法更加容易，更符合开闭原则。</li><li>因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器类也更加容易。</li></ul><p>其他：</p><ul><li>在通过迭代器来遍历集合元素的同时，增删集合中的元素，有可能会导致某个元素被重复遍历或遍历不到，也有可能正常遍历，这种行为称为 结果不可预期行为 或者 未决行为。<strong>未决行为比出错更加可怕，很难debug</strong> 。为了避免这种行为发生，一般会在遍历时不允许增删元素，或者在遍历后让遍历报错，通知尽快修改（fail-fast 解决方式）。</li><li>如何实现“快照”功能的迭代器<ul><li>快照：指为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后增删容器中的元素，快照中的元素并不会做相应的改动，而迭代器遍历的对象是快照而非容器，避免在使用迭代器遍历的过程中，增删容器中的元素导致的不可预期的结果或报错。</li><li>方案一：在迭代器类中定义一个成员变量来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。<ul><li>缺点是内存消耗很高，如果一个容器中同时有多个迭代器，就会存在多个重复的快照，但对于浅拷贝类型的语言，相对还好一些。</li></ul></li><li>方案二：在容器中，为每个元素保存两个时间戳，一个是添加时间戳，一个是删除时间戳。在删除的时候通过设置删除时间戳为最大值的方式标记删除而非真正删除。同时，每个迭代器也保存一个迭代器创建时间戳。当使用迭代器来遍历容器的时候，只有容器内元素满足 元素添加时间戳 &lt; 迭代器创建时间戳 &lt; 元素删除时间戳，才属于这个迭代器的快照。<ul><li>缺点是底层依赖数组的数据结构，原本可以支持快速的随机访问，现在由于删除并非真正的删除，导致不支持快速的随机访问。（可以存两个数组，一个支持标记删除，来实现快照遍历功能；一个不支持标记删除，用来支持随机访问）</li></ul></li></ul></li></ul><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>概念：</p><ul><li>允许一个或多个操作应用到一组对象上，解耦操作和对象本身</li></ul><p>应用：</p><ul><li>访问者模式针对一组类型不同的对象。尽管这组对象类型不同但它们继承相同的父类或者实现相同的接口。在不同的应用场景下，需要对这组对象进行一系列不相关的业务操作，为了避免不断添加功能导致类不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致频繁代码修改，因此使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类中。</li></ul><p>其他：</p><ul><li>访问者模式，主要难点在代码实现。代码实现复杂的原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</li><li>项目中应用这种模式，会导致代码的可读性比较差。除非不得已，不要使用。</li><li>关于 Single Dispatch 与 Double Dispatch<ul><li>Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。</li><li>Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定</li><li>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言都只支持 Single Dispatch，不支持 Double Dispatch。</li></ul></li></ul><h3 id="备忘录模式-快照模式"><a href="#备忘录模式-快照模式" class="headerlink" title="备忘录模式/快照模式"></a>备忘录模式/快照模式</h3><p>概念：</p><ul><li>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</li><li>两部分内容：一是在存储副本以便后期恢复；另一部分是在不违背封装原则的前提下，进行对象的备份和恢复。</li></ul><p>应用：</p><ul><li>用来防丢失、撤销、恢复等。相对于备份来说，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>概念：</p><ul><li>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖植入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</li><li>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。在大部分编程语言中，函数是没办法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，将函数封装成对象，可以实现把函数像对象一样使用。</li></ul><p>应用：</p><ul><li>把函数封装成对象，对象就可以存储下来，方便控制执行。用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等。</li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>概念：</p><ul><li>解释器模式为某个语言定义它的用法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</li><li>这里的“语言”不仅仅指平时所说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，都可以称为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</li></ul><p>应用：</p><ul><li>解释器模式代码实现比较灵活，没有固定的模板。代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</li></ul><h3 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h3><p>概念：</p><ul><li>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</li><li>中介模式的设计思想类似于中间层，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。最小化对象之间的交互关系，降低代码复杂度，提高代码可读性和可维护性。</li></ul><p>中介模式 VS 观察者模式：</p><ul><li><p>简介：</p><ul><li>观察者模式有多种实现方式，观察者需要被注册到被观察者中，被观察者状态更新需要调用观察者update方法。但是，在跨进程的实现方式中，可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</li><li>中介模式也是解耦对象之间的交互，所有参与者都只与中介进行交互。</li></ul></li><li><p>区别：</p><ul><li>在观察者模式中，尽管一个参与者既是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有调理。</li><li>中介模式中，只有当参与者之间的交互关系错综复杂，维护成本很高的时候才考虑使用中介模式。因为中介模式的应用汇带来一定的副作用，它有可能产生大而复杂的“上帝类”。</li></ul></li><li><p>应用：</p><ul><li>参与者之间交互比较有条例，一般是单向，要么观察者，要么被观察者，使用观察者模式。</li><li>如果一个参与者状态改变，其他参与者执行的操作有一定先后顺序要求，此时使用中介类。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时光不语，静等花开。&lt;/p&gt;
&lt;p&gt;当你的能力撑不起你的野心的时候，当你感到怀才不遇的时候，当你迷茫找不着方向的时候，你只需要努力、坚持，再努力、再坚持，慢慢地，你就会变得越来越强大，方向就会变得越来越清晰，机会就会越来越青睐你。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="看着读" scheme="http://yoursite.com/tags/%E7%9C%8B%E7%9D%80%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《10x程序员工作法》学习笔记</title>
    <link href="http://yoursite.com/2020/09/13/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/09/13/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-13T13:00:00.000Z</published>
    <updated>2020-09-20T15:05:08.785Z</updated>
    
    <content type="html"><![CDATA[<p>程序员的三大美德：懒惰、急躁、傲慢</p><ul><li>懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。</li><li>急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。</li><li>傲慢，极度自信，写出（或维护）别人挑不出毛病的程序。</li></ul><a id="more"></a><p><br></p><p><br></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文是在 <strong>极客时间</strong> APP 学习 <strong>郑晔</strong> 老师专栏 《10x程序员工作法》的学习笔记。</p><p><br></p><p><br></p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>概念：</p><ul><li>本质复杂度 &amp; 偶然复杂度</li><li>本质复杂度就是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。</li></ul><p>现象</p><ul><li>大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。</li></ul><p>目的</p><ul><li>如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行。</li></ul><p>实践</p><ul><li>以终为始</li><li>任务分解</li><li>沟通反馈</li><li>自动化</li></ul><p><em>明确现状</em></p><ul><li><em>我现在在哪（或者说技术水平）？以此确定现状！</em></li><li><em>我要到哪去（或者说技术水平）？以此确定目标！</em></li><li><em>我如何到那（或者说技术水平）？以此确定实现路径！</em></li></ul><p><br></p><p><br></p><h2 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h2><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>DoD，确定好完成的定义，减少团队内部的理解不一致</li><li>用户故事，细化出有价值的需求</li><li>持续集成，通过尽早集成，减少改动量，降低集成的难度</li><li>精益创业，减少过度开发不确定性产品带来的浪费</li><li>迭代0，在项目开始之前，做好一些基础准备</li><li>任何事物都要经过两次创造：<ul><li>第一次是在头脑中创造，也就是智力上的。</li><li>第二次是付诸实践，也就是实际的构建。</li></ul></li></ul><h3 id="实战指南"><a href="#实战指南" class="headerlink" title="实战指南"></a>实战指南</h3><p>遇到需求或任务，倒着想，先推演，明确“终”</p><ul><li>明确完成的标准</li><li>明确验收的标准</li><li>弄清楚所有待做的需求的原因</li><li>扩展自己的角色，不仅限于“程序员”</li><li>尽量用可度量的数字衡量所做的工作</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>作为程序员，可以管理上级<ul><li>管理上级的预期，把看到的问题暴露出来</li><li>帮助上级丰富知识，细化分支</li><li>说出自己的想法，而非压抑</li></ul></li><li>拿老板说事，可以到老板面前澄清<ul><li>一般来说老板要求的是方向，而不是细节；要排除产品经理畏于老板而强迫下游无脑实现的需求。</li></ul></li><li>对抄袭的需求，先明确要抄什么，而不是无脑照抄</li><li>分清楚需求和技术，各自做好各自的事情</li></ul><p><br></p><p><br></p><h2 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h2><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>艾森豪威尔矩阵（Eisenhower Matrix）<ul><li>将事情按照 重要 和 紧急 程度进行划分，成四个象限</li><li>重要且紧急的事情要立即做；重要但不紧急的事情应该是重点投入精力的地方；紧急但不重要的事情，可以委托别人做；不重要且不紧急的事情，尽量少做</li></ul></li><li>最小可行产品<ul><li>“刚刚好”满足客户需求的产品</li><li>在实践中，用最小的代价找到一条可行的路径</li></ul></li></ul><h3 id="实战指南-1"><a href="#实战指南-1" class="headerlink" title="实战指南"></a>实战指南</h3><ul><li>分而治之，是人类解决问题的基本手段</li><li>任务分解，分解到可以进行的微操作<ul><li>事前思考，减少遗漏</li><li>事中被打断，可迅速恢复</li></ul></li><li>应该编写可测试的代码</li></ul><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><ul><li>对不了解技术的任务，先要去了解技术，然后再做任务分解</li><li>通过一次技术Spike，学习新技术<ul><li>Spike，指轻轻的刺，程度弱于调研</li><li>Spike的作用在于消除不确定性，让需求方知道这里要用到一项团队内没有人懂的技术，需要花时间弄清楚</li><li>Spike，针对使用新技术所关注的点进行快速调试、验证</li><li>Spike用的原型代码，应该抛弃，不可作为实际应用的代码</li></ul></li><li>分清目标与现状，用目标作为方向，指导现状的改变</li></ul><p><br></p><p><br></p><h2 id="沟通反馈"><a href="#沟通反馈" class="headerlink" title="沟通反馈"></a>沟通反馈</h2><h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>看板<ul><li>可视化的任务</li><li>明确任务大纲及进程</li></ul></li><li>持续集成<ul><li>做好持续集成的关键是 快速反馈</li><li>本地检查过后再提交</li></ul></li><li>回顾&amp;复盘<ul><li>枚举关注点</li><li>选出重点</li><li>深入讨论</li><li>列出行动项</li><li>找到负责人</li></ul></li><li>编写代码的进阶路径（非底层）<ol><li>编写可以运行的代码</li><li>编写符合代码规范的代码</li><li>编写人可以理解的代码</li><li>用业务语言写代码<ul><li>贴近实际应用现场，例如起名字贴近实际应用业务而非代码中面向实现的名字</li><li>DDD 领域驱动设计</li></ul></li></ol></li><li>会议是一种 <strong>重量级</strong> 的沟通方式<ul><li>若非必要，不要开会</li><li>减少参会人数</li><li>尽量采用 <strong>轻量级</strong> 的沟通方式 —— 面对面沟通</li></ul></li><li>聆听用户声音<ul><li>能做自己用户，做自己用户</li><li>能接近用户，接近用户</li><li>没有用户，创造用户</li></ul></li><li>Fail Fast<ul><li>尽早暴露出错误，不要隐瞒，容错</li></ul></li></ul><h3 id="实战指南-2"><a href="#实战指南-2" class="headerlink" title="实战指南"></a>实战指南</h3><ul><li>回顾会议是一个常见的复盘实践，是一个团队自我改善的前提。<ul><li>分类方式<ul><li>主题分类1<ul><li>做得好的</li><li>做的欠佳的</li><li>问题或建议</li></ul></li><li>主题分类2（海星图）<ul><li>继续保持</li><li>开始做</li><li>停止做</li><li>多做一些</li><li>少做一些</li></ul></li></ul></li><li>会议重点：<ul><li>写事实，不要写感受<ul><li>事实就是明摆在那里的东西，而感受无法衡量</li></ul></li><li>重点关注可改进的部分，按照优先级讨论（一般只挑出最重要的几个）</li><li>通过多个为什么，一步步找到根因</li><li>尝试着找出解决方案，一系列行动项；所有的行动项都是可检查的，可验证实现的内容</li><li>验证行动项的完成情况</li></ul></li></ul></li><li>多输出，让知识更有结构<ul><li>金字塔原理，从中心论点到分论点再到论据<ul><li>结论先行（一次表达只支持一个思想，且出现在开头）</li><li>以上统下（任一层次上的思想都必须是下一层思想的总结概括）</li><li>归类分组（每组中的思想都必须属于同一范畴）</li><li>逻辑递进（每组中的思想都必须按照逻辑顺序排列）</li></ul></li></ul></li></ul><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul><li>安全性检查，是回顾会议的前提条件<ul><li>暴露问题，是改进的前提条件</li><li>营造畅所欲言的环境，让“领导”暂时回避</li></ul></li><li>在信息获取上，国内外程序员差别不大，开拓视野，改善工作习惯，是国内程序员亟需提高的</li></ul><p><br></p><p><br></p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><h3 id="最佳实践-3"><a href="#最佳实践-3" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>持续交付</p><ul><li>将生产部署纳入开发的考量</li><li>持续交付的基础设施通常包含持续集成环境、测试环境、预生产环境和生产环境</li><li>构建流水线保证到了下游的交付物一定是通过上游验证的</li><li>随着Docker的诞生，交付由发布包变成了Docker镜像</li></ul></li><li><p>微服务</p><ul><li>做好微服务的前提是划分好限界上下文</li><li>微服务的第一步，不要划分微服务</li></ul></li><li><p>程序员的三大美德：懒惰、急躁、傲慢</p><ul><li>懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。</li><li>急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。</li><li>傲慢，极度自信，写出（或维护）别人挑不出毛病的程序。</li></ul></li></ul><h3 id="实战指南-3"><a href="#实战指南-3" class="headerlink" title="实战指南"></a>实战指南</h3><ul><li>谨慎地将工作自动化，将工作过程自动化</li><li>采用简单的技术解决问题，直到问题变复杂</li><li>软件设计最基础的原则是 高内聚、低耦合</li><li>小心NIH综合症（Not Invented Here Syndrome）<ul><li>因为那个东西不是我做的，可能存在各种问题，非要自己做出一套新的</li></ul></li></ul><h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><ul><li>AB测试，用一个软件的多个版本验证想法</li><li>熟练使用快捷键</li><li>有价值的事情不局限于事情本身。做自动化很重要，写代码很重要。但根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解，权衡跟设计是一件很艺术的事情。</li><li>分而治之是解决复杂问题的一大利器。持续交互就像重构中小步快走，都能保证大工程的稳步前进。同时由于单元小了，所以也灵活了，持续交付可以结合最小产品的理念，以小成本做test，收集数据后，及时调整产品发展方向。</li></ul><p><br></p><p><br></p><h2 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h2><h3 id="实战指南-4"><a href="#实战指南-4" class="headerlink" title="实战指南"></a>实战指南</h3><ul><li>“学习区”学习模型<ul><li>舒适区，舒适而缺乏成长</li><li>恐慌区，超出能力范围</li><li>学习区，有难度而可以达成</li><li>在学习区练习才能得到足够的成长</li></ul></li><li>T型人才，一专多能<ul><li>知识的广度</li><li>专业技能的深度</li></ul></li><li>面对新工作，从全面了解了解开始<ul><li>业务：做什么</li><li>技术：怎么做</li><li>团队运作：怎么与人协作</li><li>由大到小，由内及外地了解工作</li></ul></li><li>面对遗留系统，稳扎稳打，小步前行<ul><li>基础理念<ul><li>烂代码只是现象，要了解根因</li><li>能重构，先重构，大规模改造是迫不得已的选择</li><li>小步前行</li></ul></li><li>实际操作<ul><li>构建测试防护网</li><li>将大系统分解成小模块，逐步替换</li><li>新旧模块并存，由分发模块调度</li><li>建立好领域模型</li><li>寻找行业对于系统构建的最新理解</li></ul></li></ul></li><li>程序员的职业发展<ul><li>程序员的焦虑来自于对未来的不确定性，这种不确定性是一个特定时代加上特定行业的产物<ul><li>快速发展的中国经济</li><li>程序员在中国是一个新兴职业</li></ul></li><li>成为行业专家，制定高目标</li><li>向大师学习，开拓视野</li><li>找到好的问题，和高水平的人一起工作</li></ul></li></ul><h3 id="扩展-4"><a href="#扩展-4" class="headerlink" title="扩展"></a>扩展</h3><ul><li>Lead by Example</li><li>外部系统应该用接口隔离，这种做法体现了接口隔离原则，也是防腐层概念的体现</li></ul><p><br></p><p><br></p><p><br></p><hr><p>参考：</p><ul><li>极客时间 《10x程序员工作法》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序员的三大美德：懒惰、急躁、傲慢&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。&lt;/li&gt;
&lt;li&gt;急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。&lt;/li&gt;
&lt;li&gt;傲慢，极度自信，写出（或维护）别人挑不出毛病的程序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="看着读" scheme="http://yoursite.com/tags/%E7%9C%8B%E7%9D%80%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《掌控习惯》 读记</title>
    <link href="http://yoursite.com/2020/06/26/%E3%80%8A%E6%8E%8C%E6%8E%A7%E4%B9%A0%E6%83%AF%E3%80%8B%E8%AF%BB%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/26/%E3%80%8A%E6%8E%8C%E6%8E%A7%E4%B9%A0%E6%83%AF%E3%80%8B%E8%AF%BB%E8%AE%B0/</id>
    <published>2020-06-26T12:40:00.000Z</published>
    <updated>2020-06-26T15:10:41.676Z</updated>
    
    <content type="html"><![CDATA[<p>欲望负责点火，快乐保持烈火持续燃烧。想要和喜欢是行为的两大驱动力。</p><a id="more"></a><p><br></p><p><br></p><p><br></p><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>习惯的力量是很大的，这本书介绍如何掌控这个力量。</p><p>首先，培养习惯的四步模型： 提示 -&gt; 渴求 -&gt; 反应 -&gt; 奖励。</p><p>提示触发渴求，渴求激发反应，而反应则提供满足渴求的奖励，并最终与提示相关联。这四个步骤一起形成了一个神经反馈回路，并最终养成自然而然的习惯，由此构成完整的习惯循环。</p><p>培养习惯，不仅是定制一个目标，更应该专注于落实行动。拆解行动为很小的可行单元，保证频率而非时长，不断练习。</p><p>培养习惯的简单法则：</p><ul><li>让它显而易见<ul><li>让想养成习惯的提示显而易见，让想戒除习惯的坏处提示显而易见</li></ul></li><li>让它有吸引力<ul><li>人脑进化为优先考虑即时奖励而不是延迟奖励</li></ul></li><li>让它简便易行<ul><li>两分钟原则：开始培养一种新习惯时，它所用时间不应超过两分钟</li><li>注重环境培养</li></ul></li><li>让它令人愉悦<ul><li>无论是针对想养成的习惯还是想戒除的习惯，都可以从好处与坏处两方面下手</li></ul></li></ul><p><br></p><p><br></p><p><br></p><h1 id="读记"><a href="#读记" class="headerlink" title="读记"></a>读记</h1><p>习惯是一种固定程序或定期实施的行为，且在许多情况下，是自动执行的</p><p>培养习惯的四步模型：</p><ul><li>提示</li><li>渴求</li><li>反应</li><li>奖励</li></ul><h2 id="微习惯的惊人力量"><a href="#微习惯的惊人力量" class="headerlink" title="微习惯的惊人力量"></a>微习惯的惊人力量</h2><ul><li>“边际收益的聚合”战略，其基本理念就是在所做的每一件事上寻求哪怕是极细微的进步</li><li>习惯是自我提高的复利</li><li>得到的结果是衡量习惯的滞后指标；净资产是衡量财务习惯的滞后指标；体重是衡量饮食习惯的滞后指标；生活环境的杂乱是衡量整理内务习惯的滞后指标。所得到的就是日复一日、年复一年积行成习的结果</li><li>忘记目标，专注于体系<ul><li>不代表目标完全无用。目标的意义在于确定大方向，但体系会促进你的进步。加入你为目标绞尽脑汁，却对体系设计关注不足的话，就会出现一些问题</li><li>当爱上过程而不是结果时，不必等待容许自己享受快乐的那一刻的到来。只要创建的体系在正常运行，就会在整个过程中感受到快乐。一个体系取得成功的方式有多种，而不仅仅是最初想象的那一种</li></ul></li><li><strong>如果想要更好的结果，就不要再追求设定或拔高目标，转而全力落实体系</strong></li></ul><h2 id="习惯如何塑造身份（反之亦然）"><a href="#习惯如何塑造身份（反之亦然）" class="headerlink" title="习惯如何塑造身份（反之亦然）"></a>习惯如何塑造身份（反之亦然）</h2><ul><li>改变习惯之举颇具挑战性，在于：<ul><li>没有找对试图改变的东西</li><li>试图以错误的方式改变习惯</li></ul></li><li>内在激励的终极形式是习惯与身份融为一体。说我是想要这样的那种人是一回事，而说我本身就是这种人则是另外一回事</li><li>改变身份的两步进程：<ol><li>决定想成为哪类人</li><li>用小赢证明给自己看</li></ol></li><li>变化有三个层次：结果变化、过程变化、身份变化<ul><li>改变习惯的最有效方法不是关注想要达到的目标，而是想要成为谁</li><li>身份来自习惯，每个行动都是在投票给想成为人</li><li>想要做到最好，需要持续编辑信念，升级和扩展身份</li><li>习惯至关重要的真正原因不是因为它们能带来更好的结果（尽管它们能做到这一点），而是因为它们能改变对自己抱有的信念</li></ul></li></ul><h2 id="培养良好习惯的方法"><a href="#培养良好习惯的方法" class="headerlink" title="培养良好习惯的方法"></a>培养良好习惯的方法</h2><ul><li>动物的学习过程：<strong>导致结果满意的行为往往会得以重复，而产生不愉快结果的行为得以重复的概率较低</strong></li><li>只有让生活的基本要素变得更容易，才能创造自由思考和创造力所需的精神空间</li><li>总的来说，提示触发渴求，渴求激发反应，而反应则提供满足渴求的奖励，并最终与提示相关联。这四个步骤一起形成了一个神经反馈回路，并最终养成自然而然的习惯，由此构成完整的习惯循环</li><li>如果设定的每个目标都违背人性，那注定会失败</li><li>习惯是一种行为，因为重复的次数已经足够多，便可以自然而然的出现</li><li>习惯的最终目的是用尽可能少的精力和努力来解决生活中的问题</li><li><strong>培养良好习惯的简单规则</strong><ul><li><strong>让它显而易见</strong></li><li><strong>让它有吸引力</strong></li><li><strong>让它简便易行</strong></li><li><strong>让它令人愉悦</strong></li></ul></li></ul><h2 id="看着不对劲儿的那个人"><a href="#看着不对劲儿的那个人" class="headerlink" title="看着不对劲儿的那个人"></a>看着不对劲儿的那个人</h2><ul><li>有了足够的联系，你的大脑会不假思索地拾取预测特定结果的提示</li><li>改掉不良习惯的第一步是对它们保持警觉</li><li>习惯叠加是一种策略，可以用来将新习惯与当前习惯整合</li><li>习惯叠加的公式是：继[当前习惯]之后，我将进行[新习惯]</li></ul><h2 id="原动力被高估，环境往往更重要"><a href="#原动力被高估，环境往往更重要" class="headerlink" title="原动力被高估，环境往往更重要"></a>原动力被高估，环境往往更重要</h2><ul><li>环境是塑造人类行为的无形之手。尽管我们有独特的个性，但在特定环境条件下，某些行为往往会反复出现</li><li>我们喜欢认为一切尽在自己掌控之中。事实上，<strong>每天采取的许多行动并不是由有目的的驱动和选择决定的，而是因为最得心应手</strong></li><li>每个习惯都是由提示引发的，我们更有可能注意到显眼的提示</li><li>如果想让习惯成为生活中的重要组成部分，就让提示成为生活环境中的重要组成部分</li><li>让习惯不再与单一的触发因素相关联，而是与这种行为周围的整个环境相关联。情境变成了提示</li><li>在新的环境中培养新的习惯更容易，因为不会受到旧习惯相关联的提示的干扰</li></ul><h2 id="自我控制的秘密"><a href="#自我控制的秘密" class="headerlink" title="自我控制的秘密"></a>自我控制的秘密</h2><ul><li>自我控制能力强的人通常最不需要它。加入不需要经常自我克制的话，做起来就会更容易。所以，毅力、勇气和意志力是取得成功的要素，但是增强这些品质的途径不是期望成为一个自律的人，而是创造一个有纪律的环境</li><li>更可靠的方法是从源头上改掉坏习惯。消除坏习惯最实用的方法之一是避免接触引起它的提示</li><li>自我控制只是权宜之计，而非长远良策。也许能抵抗一两次诱惑，但是不可能每次都能铆足了劲儿，克服强烈的欲望。与其每当想正确行事时要诉诸新的意志力，不如把精力花在优化所处的环境上。这就是自我控制的奥秘，<strong>让良好习惯的提示显而易见，让不良习惯的提示脱离视线</strong></li></ul><h2 id="让习惯不可抗拒"><a href="#让习惯不可抗拒" class="headerlink" title="让习惯不可抗拒"></a>让习惯不可抗拒</h2><ul><li>所有习惯共有的生物特征指标：多巴胺浓度</li><li>机会越有吸引力，养成习惯的可能性就越大</li><li>正是对奖励的期待，而不是奖励本身，促使我们采取行动。预期越高，多巴胺峰值越大</li><li>喜好绑定是让习惯更具吸引力的一种方式。具体做法就是将你喜欢的高频动作与需要的低频动作搭配在一起</li></ul><h2 id="习惯形成中亲友所起的作用"><a href="#习惯形成中亲友所起的作用" class="headerlink" title="习惯形成中亲友所起的作用"></a>习惯形成中亲友所起的作用</h2><ul><li>我们尤其注重模仿三个群体的习惯：<ul><li>亲近的人</li><li>群体中的多数人</li><li>有权势的人</li></ul></li><li>培养好习惯最有效的方式之一是加入一种文化，在这种文化中，所偏爱的行为被认定为是正常行为。当看到别人每天都这样做时，会觉得培养新习惯似乎不难。</li><li>每个群体都对其成员施加巨大压力，要求他们服从集体规范。与在争论中占上风、显得自己很聪明或凡事都追根究底相比，个体被集体接受的好处肯定更多。<strong>大多数时候，我们宁愿跟众人一起犯错，也不愿特立独行坚持真理</strong></li></ul><h2 id="渴望来自哪里"><a href="#渴望来自哪里" class="headerlink" title="渴望来自哪里"></a>渴望来自哪里</h2><ul><li>有许多不同的方法来满足相同的潜在动机。一个人可能会通过吸烟来缓解情绪。另一个人通过跑步减轻焦虑。你目前的习惯不一定是解决面临问题的最佳方式；它们只是掌握的方法。一旦把一个解决方案和所需要解决的问题联系起来，就会不断地反复加以应用</li><li>每种行为都有表层的渴求和更深层的动机</li><li>习惯的原因实际上是之前的预测，这种预测会产生一种感觉</li><li>强调避免坏习惯所带来的好处，让坏习惯不再有吸引力</li><li>将习惯与积极的感受相关联，习惯就有了吸引力；反之，则没有吸引力。在开始培养难度较大的习惯之前，先做些喜欢的事情来创造一种激励仪式</li></ul><h2 id="慢步前行，但绝不后退"><a href="#慢步前行，但绝不后退" class="headerlink" title="慢步前行，但绝不后退"></a>慢步前行，但绝不后退</h2><ul><li>酝酿与行动的区别。酝酿意味着在计划、策划和学习；这些都是好东西，但它们不会产生结果</li><li>如果想要掌握一种习惯，关键是从重复开始，无须力求完美，不必描画出新习惯的每一个特征，只需要不断练习，只需要关注次数</li><li><strong>习惯是基于频率而不是时长形成的</strong></li></ul><h2 id="最省力法则"><a href="#最省力法则" class="headerlink" title="最省力法则"></a>最省力法则</h2><ul><li><strong>传统智慧认为动机是习惯转变的关键。也许真是这样，就是说假如真的想要，就真的会去做。但事实是，我们真正的动机是贪图安逸，怎么省事就怎么做</strong></li><li>图省事才是一个聪明而非愚蠢的策略</li><li>习惯坚持起来越难——你和你想要的的最终状态之间的阻力就越大。这就是为什么要让习惯变得简单至极，只有这样才能让你即使不喜欢它，也会坚持做。如果能让好习惯简便易行，就越有可能坚持下去</li><li>简便易行的说法不仅仅是做容易的事，主旨是尽可能确保可以毫不费力地去做具有长期回报的事</li></ul><h2 id="怎样利用两分钟规则停止拖延"><a href="#怎样利用两分钟规则停止拖延" class="headerlink" title="怎样利用两分钟规则停止拖延"></a>怎样利用两分钟规则停止拖延</h2><ul><li>不要指望从一开始就培养一种完美的习惯，要脚踏实地，连续不断地做些简单的事。必须先标准化，然后才能优化</li><li>习惯可以在几秒钟内完成，但会持续影响接下来几分钟或几个小时的行为</li><li>许多习惯发生在决定性时刻，每时每刻的选择就像岔路口，你的选择最终会导致卓有成效或一事无成的一天</li><li><strong>两分钟规则制定：当你开始培养一种新习惯时，它所用时间不应超过两分钟</strong></li></ul><h2 id="行为转变的基本准则"><a href="#行为转变的基本准则" class="headerlink" title="行为转变的基本准则"></a>行为转变的基本准则</h2><ul><li>在训练延迟满足的过程中，凡是长远地看能带给你回报的事，你可以给它添加一点即时快乐；凡是不能的，可以添加一点即时痛苦</li><li><strong>人脑进化为优先考虑即时奖励而不是延迟奖励</strong></li><li>行为转变的基本准则：重复有即时回报的行为，避免受即时惩罚的动作</li></ul><h2 id="怎样保持你的习惯"><a href="#怎样保持你的习惯" class="headerlink" title="怎样保持你的习惯"></a>怎样保持你的习惯</h2><ul><li>习惯追踪具有三方面的功效：<ul><li>创建视觉提示，提醒你采取行动</li><li>内在激励机制，因为你清楚地看到了你的进步轨迹，并且不想失去它</li><li>当记录下又一项成功的习惯实例时，你都会享受到满足感</li></ul></li><li><strong>只要有可能，测量应该自动化</strong></li><li>习惯叠加+习惯追踪的方式是：在[当前习惯之后]，我将[追踪我的习惯]</li><li><strong>绝不错过习惯两次</strong>。如果错过了一天，试着尽快恢复固有的做事节奏</li></ul><h2 id="揭秘天才"><a href="#揭秘天才" class="headerlink" title="揭秘天才"></a>揭秘天才</h2><ul><li>最大化成功概率的秘诀是选择合适的经济领域，这适用于体育和商业，同样也适用于习惯的转变。如果习惯与天性和能力一致，它更容易培养，你也更乐意保持</li><li>接受并承认一个事实：<strong>人天生具有不同的能力</strong></li><li>基因不容易改变，这意味着它们在有利的环境中提供了强大的优势，但在不利的环境中又暴露出严重的劣势</li><li>你是否适合一项任务的标志不在于你是否喜欢它，而在于你是否能比大多数人更容易承受这项任务带来的痛苦。当别人觉得痛苦不堪时，你却能自得其乐？伤害别人多于伤害你的事，就是你生来就适合做的事</li><li>习惯选择正确，进步易如反掌；习惯选择错误，生活步步维艰</li></ul><h2 id="金发女孩准则：如何在生活和工作中保持充沛动力"><a href="#金发女孩准则：如何在生活和工作中保持充沛动力" class="headerlink" title="金发女孩准则：如何在生活和工作中保持充沛动力"></a>金发女孩准则：如何在生活和工作中保持充沛动力</h2><ul><li>大家公认保持动力和达到欲望的途径之一，就是去做：难易程度刚刚好的事</li><li><strong>人们在处理其能力可及的事务时积极性最高</strong></li></ul><h2 id="培养好习惯的负面影响"><a href="#培养好习惯的负面影响" class="headerlink" title="培养好习惯的负面影响"></a>培养好习惯的负面影响</h2><ul><li>习惯动作 + 刻意练习 = 精通</li><li>反思和回顾有助于长期改善所有习惯，因为它让你认清自己的不足，并帮助你考虑可能的改善途径。没有反思，我们会为自己的行为寻找理由、借口，进行自我欺骗。我们会因缺乏这样一种程序而无法确定与以往相比表现的更好还是更差</li><li>缺乏自我意识是毒药，反思和回顾是解药</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>致力于微小、可持续、不懈的改进</li><li>好奇心总比头脑灵活好。积极性和好奇心比头脑灵活更重要，因为前者会导致行动。头脑灵活永远不会独自产生结果，因为它不会让你采取行动。促使行为的是欲望，而不是智力。<strong>做任何事情的诀窍是首先培养对它的渴望</strong></li><li>满意 = 喜欢 - 想要</li><li>欲望负责点火，快乐保持烈火持续燃烧。想要和喜欢是行为的两大驱动力。</li></ul><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欲望负责点火，快乐保持烈火持续燃烧。想要和喜欢是行为的两大驱动力。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="看着读" scheme="http://yoursite.com/tags/%E7%9C%8B%E7%9D%80%E8%AF%BB/"/>
    
  </entry>
  
</feed>
