<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tree House</title>
  
  <subtitle>不如自挂东南枝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-30T14:16:31.010Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ltree98</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊元宇宙</title>
    <link href="http://yoursite.com/2021/11/30/%E8%81%8A%E8%81%8A%E5%85%83%E5%AE%87%E5%AE%99/"/>
    <id>http://yoursite.com/2021/11/30/%E8%81%8A%E8%81%8A%E5%85%83%E5%AE%87%E5%AE%99/</id>
    <published>2021-11-30T13:11:16.000Z</published>
    <updated>2021-11-30T14:16:31.010Z</updated>
    
    <content type="html"><![CDATA[<p>过去，互联网是人们逃避现实的地方；</p><p>现在，现实变成人们逃避互联网的地方。</p><a id="more"></a><p><br></p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><h2 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h2><p>最近 元宇宙 各种刷屏，这到底是个什么东西呢？</p><p>国外：</p><p>2020年4月，美国歌手Travis Scott在《堡垒之夜》游戏中举办了一场线上虚拟演唱会，吸引超1200万玩家参加</p><p>2021年3月 “元宇宙第一股”Roblox上市，首日股价上涨超50%</p><p>2021年3月 纯VR社交游戏平台 Rec Room 完成新一轮融资，总额达1亿美元</p><p>2021年4月 Epic Games获得10亿美元投资，用来构建元宇宙</p><p>Facebook扎克伯格提出，在未来五年左右时间里，要将Facebook从一家社交媒体公司转变为一家元宇宙公司</p><p>英伟达（Nvidia）专门推出虚拟协作平台Omniverse，号称工程师的元宇宙</p><p>2021年11月 Facebook改名为Meta</p><p>国内：</p><p>2021年3月 移动沙盒平台开发商MetaApp完成1亿美元C轮融资，号称将打造全年龄段的元宇宙世界</p><p>2021年4月 游戏引擎开发商 代码乾坤（号称 中国Roblox）获近1亿人民币战略投资</p><p>2021年5月 云游戏技术服务商海马云完成2.8亿人民币融资</p><p>2021年9月 央视财经频道报到 “一条可能改变人们生活环境的内化道路在今年引爆科技圈，那就是‘元宇宙’。”</p><p>中手游公布“仙剑元宇宙”规划</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>最初来源于一篇赛博朋克的小说《雪崩》，小说中的元宇宙是指一个平行于现实世界的虚拟世界，通过耳机、头显等设备，人类可以通过终端连接进入计算机模拟出的三维世界。</p><p>简单来说就是现实社会中所有人和事都被数字化投射到云端世界里，可以在云端世界做任何现实世界可以做的事情，也可以在云端世界做很多现实世界做不了的事情。类似于电影《头号玩家》的“绿洲”。</p><p>Roblox提出的元宇宙要素</p><ul><li>Identity（身份）</li><li>Friends（伙伴）</li><li>Immersive（沉浸式）</li><li>Anywhere（随地）</li><li>Low Friction（低门槛）</li><li>Variety of Content（多样化）</li><li>Economy（经济系统）</li><li>Safety（安全性）</li></ul><p>需要的技术</p><ul><li>算力（芯片）</li><li>无线通信网络技术（5G/6G）</li><li>VR/AR/MR/XR</li><li>AI</li><li>区块链技术</li></ul><p>价值链</p><ul><li>Experience（体验）</li><li>Discovery（发现）</li><li>Creator Economy（创作经济）</li><li>Spatial Computing（空间计算）</li><li>Decentralizition（去中心化）</li><li>Human Interface（人机交互）</li><li>Infrastructure（基础设施）</li></ul><p><br></p><p><br></p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><h2 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h2><p>那么，元宇宙到底是一个什么东西呢？</p><p>我的理解来说，</p><ul><li>首先，是一个与现实世界平行的虚拟世界<ul><li>在这个世界，可以旅游、游戏、购物 等满足各种精神上的需求</li><li>世界的展现形式，可能是游戏，但不仅限于打怪升级等</li></ul></li><li>其次，有去中心化的经济系统，并且可与现实经济系统挂钩<ul><li>在这个世界，不光可以用现实货币来买这个世界物品，也可以打工来赚现实的货币</li></ul></li><li>然后，这个世界是一个UGC为主体的，少量PGC存在。</li><li>再然后，这个世界所需要的技术很多，要求也很高，不是简单实现即可；随之，就是目前技术还有的发展。</li><li>最后，这个世界并不属于某个公司或团队，至少是很多组织共同支撑的<ul><li>现在所有公司的发展，也只是在做它的某部分的支撑体系</li></ul></li></ul><p>最最后，大家都在蹭，并没有啥参考价值。</p><h3 id="PGC-与-UGC"><a href="#PGC-与-UGC" class="headerlink" title="PGC 与 UGC"></a>PGC 与 UGC</h3><p>PGC，Professional Generated Content；专业团队生产内容，如原神、NBA 2K系列、以前电视剧。</p><p>UGC，User Generated Content；用户生产内容，如短视频、淘宝、微博等。</p><p>PGC质量高，但成本高、投入高、产能不足。</p><p>UGC质量低，但内容丰富。</p><h2 id="元宇宙-与-游戏"><a href="#元宇宙-与-游戏" class="headerlink" title="元宇宙 与 游戏"></a>元宇宙 与 游戏</h2><p>听完元宇宙的概念，大部分都能和游戏扯上关系，</p><p>但是这个东西，和以前，包括现在我们玩的MMO类型游戏，是不是很像呢，区别可能在于 现在的MMO类型游戏并没有VR/AR/MR/XR技术，但如果现在的MMO游戏加上VR这些技术，是不是就是元宇宙了呢？</p><p>或者说，如果以前看过网游小说，就会发现，这种形式其实早就烂大街了，戴个头盔到另一个世界，进入营养仓到另一个世界，注射营养液可以好几天甚至几个月不需要进食，这种桥段在网游类小说里司空见惯，并不是什么新奇的东西。</p><p>所以说，元宇宙和游戏到底是什么关系呢？</p><p>我个人理解是，游戏可能是元宇宙最靠谱最便捷最易理解的落地方向之一。</p><p>这个感觉，就像以前在大学学习很多东西，最后，要做一个成品出来，很多方向需要额外学习支持的东西都太多了，所以，一般都会让做一个简单的小游戏出来，比如扫雷、比如走迷宫等等。</p><p>包括，之前的各种人工智能，比如 围棋 Alpha Go、DOTA2 OpenAI机器人、星际争霸 Alpha Star等等，要解释一个人工智能，很难，那就让它处理看起来只有“人类”才能进行的游戏，然后打败人类，做一个简要落地，让大家理解发现它的强大，再慢慢挖掘，发展到其他领域中。</p><h2 id="爆发？"><a href="#爆发？" class="headerlink" title="爆发？"></a>爆发？</h2><p>为什么突然这个概念火起来了？</p><p>个人认为有以下几个元素</p><ul><li>疫情</li><li>资本</li><li>技术</li><li>期望</li></ul><p>其一，疫情的肆虐，加速了人们线上化、虚拟化的认知与进程。特别是在 堡垒之夜演唱会的效果，更加提升且突破了大家对这种形式的认知。比如，有1200万名玩家参加的演唱会。</p><p><a href="https://www.bilibili.com/video/BV1jV411d7Nb?from=search&amp;seid=12727033100687480368&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">Travis Scott x 堡垒之夜演唱会 官方视角</a></p><p>其二，资本的炒作；从上述描述可知，元宇宙是需要一个经济系统的，这种经济系统，显然不能是中心化的，那么去中心化的经济系统，没错区块链技术的又一未来落地方向；区块链技术资本是非常狂热的，这个毋庸赘述，可自行查找。再加上客观上，没有更好的流向。</p><p>其三，技术发展的需要；元宇宙所需要的技术不仅仅是区块链，相应的是未来很多爆点技术的综合，它需要每个技术的支持来共创宇宙，因此，理论上来说，是每个技术都可落地的选择之一，所以，各个技术圈，无论是处于自己的发展、还是对于人才的吸纳及资本的筹集，都不介意添上一把火；但是，物极必反，火不能烧的太旺，热钱的到来，如果把控不住，对整个行业是一个不小的灾难。</p><p>最后，就是人类的需求；</p><p>以时代来说</p><ul><li>蒸汽时代<ul><li><em>想见能见</em></li></ul></li><li>电气时代<ul><li><em>想见常见</em></li></ul></li><li>信息时代<ul><li><em>想见就见</em></li></ul></li></ul><p>信息时代中，也经历了</p><ul><li>PC互联网时代</li><li>移动互联网时代</li></ul><p>如今，移动互联网时代已经渐显尾声，即将踏入下一个时代，那对于下一个时代的方向的探索，元宇宙也是给出了一个答案，这个答案，起码看起来，还是很有吸引力，也确实是目之所及的答案。</p><h3 id="关于NFT（Non-Fungible-Token）"><a href="#关于NFT（Non-Fungible-Token）" class="headerlink" title="关于NFT（Non-Fungible Token）"></a>关于NFT（Non-Fungible Token）</h3><p>NFT，非同质化代币。</p><p>是由区块链技术验证的新型数字资产，与区块链技术的另一个产品比特币不同，主要区别在于，相同币值的两枚比特币，本质上没什么不同，是可以互换的，但非同质化代币，价值各不相同，不可互换，且不可分割。</p><p>简而言之，就是 数字产权的证明。</p><p>主要的目的，就是对于数字化的产品的所有权的认证。</p><p>比如，我照了一张相，我是无法证明这个东西是属于我的，那我就可以通过区块链技术，对这张照片生成一个NFT代币，我拥有这个代币，并且注册到链上后，可以防止篡改，且具有唯一性。如此一来，我可以去卖这张照片，也可以设置版税供他人使用。</p><h2 id="Roblox"><a href="#Roblox" class="headerlink" title="Roblox"></a>Roblox</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>为什么Roblox这么有名呢？</p><p>它被认为是，元宇宙游戏第一股（首次把元宇宙概念写入招股书中），并且市值极高。（以 2021.11.28日收盘为例，总市值 709.9亿美元；EA 总市值 356.3 亿美元；动视暴雪 总市值 472.2亿美元）</p><p>值得一提的是，以2020年第四季度的数据来说，平均日活用户 3710万，其中 56%用户都没满13岁，25岁以上的占比 15%。所以说，它是外国的4399平台，不是浪得虚名的。</p><p>它所提供的内容很简单，首先它是一个平台，其次，玩家可以在它上面开发各种自定义游戏（就是各种MOD编辑器，比如我的世界、魔兽争霸、），开发者可以开发游戏，做成买断制或者免费玩内购付费的形式；平台内通用交易货币为 Robux，开发者积攒一定货币，就可以兑换成美元。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>最后，来聊聊Roblox的技术架构。</p><p>Roblox的定位是 以“交互式3D虚拟世界”为媒体的社交网络。（社交网络，是不是发现了个华点；Facebook为什么要叫Meta呢？）</p><p>但是，它依然是一个虚拟世界。</p><p>核心设计思想：Everything is Dynamic</p><ul><li>所有对象默认都是支持物理模拟</li><li>99.9%的对象属性是可以通过脚本动态修改</li></ul><p>具体来说</p><ol><li>每个虚拟世界都是一个单独的数据模型描述。<ul><li>整体是一个树结构，类似于HTML DOM，内部称之为 RBXL数据格式</li><li>脚本使用 <a href="https://luau-lang.org/" target="_blank" rel="noopener">Luau</a></li><li>有很多根节点，如<ul><li>WorkSpace<ul><li>Camera</li><li>Terrain</li><li>Billboards</li><li>Buildings<ul><li>Barracks</li><li>Bridge<ul><li>Arch</li><li>Side<ul><li>Part</li><li>Part</li></ul></li></ul></li></ul></li><li>Foliage</li><li>Walls</li></ul></li><li>Lighting</li><li>ServerStorage</li></ul></li></ul></li><li>数据模型是原生的 Client/Server 结构，Luau脚本默认运作在服务端，运行时对象的属性等数据的修改会复制到客户端，也有些对象不需要同步过去。<ul><li>完整的数据模型只保存在服务端，客户端并不掌握整个数据模型<ul><li>主要考虑到数据安全，客户端无法下载完整世界的源码，无法注入脚本</li></ul></li><li>服务端按需把客户端索要的对象数据streamming下来<ul><li>相同世界中，不同客户端可能收到不同版本数据（根据设备渲染能力不同，选择不同对象或属性）</li></ul></li></ul></li><li>Client + Servers + Cloud Services<ul><li>除了上面的 Client/Server 结构，还有大量云服务，包括 Analytics、Data Store、Marketplace等</li><li>云服务相较Server，延迟更高，但算力可以灵活扩展</li><li>比如 在处理 UGC Content Pipeline的 Assets时，可以等用户上传这些对象后，将后续的 贴图压缩、模型LOD生成交给云服务完成</li></ul></li><li>可快速上手的开发工具：Roblox Studio<ul><li>Unity Editor 和 Unreal Editor的思路<ul><li>基于反射信息（Unity使用 .Net反射系统，而Unreal基于自定义的一套C++反射系统）编辑场景中对象的各种属性</li><li>针对引擎中提供的各种算法，要求开发者配置、调节这些算法的各种参数</li></ul></li><li>Roblox Editor 核心策略是 Everything is Tech-Agnostic<ul><li>用户使用高层的概念来构建虚拟世界，而不是技术角度的元素</li><li>不需要用户进行优化方面的设置</li><li>不需要用户进行技术参数的设置</li></ul></li></ul></li></ol><p>关于Roblox渲染引擎架构面临的问题</p><ol><li><p>所有东西都是动态的，所有传统引擎常用预处理都不能使用了</p></li><li><p>整个世界有数量很大的Parts组成，且是动态的，需要特殊的运行时的渲染优化机制</p></li><li><p>Tech-Agnostic，不需要开发者进行场景优化设计、技术参数调节等；在不同平台上的效果匹配，就需要渲染引擎来处理</p></li><li><p>可以运行在多个平台，包括PC和收集，如何发挥高端平台优势，如何保障低端平台体验，挑战很大</p></li><li><p>Client + Servers + Cloud Services 的复杂性</p></li></ol><p>关于Roblox渲染引擎架构解决方案</p><ul><li>针对 1、2、3，采用 Clusters机制优化；对于一些特殊模块（如 粒子系统、GUI）也可以直接调用 DC<ul><li>基本思路，就是按照一定算法，将世界中一些Parts对象合批渲染</li><li>设计目标，Data Model中对象的个数与Draw Call比例为 100:1</li><li>基础假设，虽然场景是完全动态的，但是对于某一帧来说，只有少量对象是变化了的</li><li>方案<ul><li>FastCluster</li><li>InstanceCluster</li><li>SmoothCluster</li><li>OtherCluster</li></ul></li></ul></li><li>针对4，采用策略是 侧重系统的可缩放性 与 Time-slice everything<ul><li>缩放性，就是针对用户不同的设备能力，提供不同细节程度、渲染效果的LOD</li><li>Time-slice everything，针对每个计算来说，在每帧基于固定时间片做预算，进行多帧增量式计算，直至最终完成</li></ul></li></ul><p><br></p><p><br></p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><h2 id="元宇宙-1"><a href="#元宇宙-1" class="headerlink" title="元宇宙"></a>元宇宙</h2><p>正如之前所说，它的愿景很美好，但是目前大家都是在蹭，并没有什么实质的东西。</p><p>待解决的问题</p><ul><li>技术的支持</li><li><p>UGC带来的监管的压力</p><ul><li>任天堂的动物森友会</li></ul></li><li><p>去中心化经济系统的落地</p><ul><li>无法管制、无法追溯</li><li>无监管的坏处；马斯特与比特币</li><li>虚拟经济催生的压榨，不创造任何社会价值</li></ul></li><li>UGC的未来就是PGC</li></ul><p>无产者在元宇宙中得到的只是数据，失去的却是整个世界。</p><p>那，这就一无是处了吗？</p><p>也并不是。</p><p>从爆发的原因来看，起码最后一点，人类的需求，这是实实在在存在，且待解决的。</p><p>元宇宙，是一个方向，它面临很多问题，但我们根据需要可以部分实现，或发展，逐步来适应人类的需求。</p><p>就如同，很多元宇宙的问题，并不仅仅是元宇宙的问题，是它所需要的技术本身自带的一些问题，但这些技术（没错，就是区块链），并没有销声匿迹，不管是什么形式，也实实在在的发展，并且，在被不断的适应，更好更贴合现实的落地，虽然不能充分利用它的优势，但是也没有完全禁止，而是适度使用，最终便捷我们。元宇宙，亦可如此。</p><p><br></p><p><br></p><p><br></p><hr><p>相关资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1C64y1Y7ar?from=search&amp;seid=6272706743672471644&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">正点财经-“元宇宙”科技产业观察</a></li><li><a href="https://www.bilibili.com/video/BV1kL411b7ua?from=search&amp;seid=5027513211823866961&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">《堡垒之夜》CEO Tim Sweeney 谈元宇宙经济</a></li><li><a href="https://mp.weixin.qq.com/s/ks3byv2-QaxM9wVe9P6lZA" target="_blank" rel="noopener">我怎么看元宇宙和游戏行业的未来（1/2）_许怡然</a></li><li><a href="https://zhuanlan.zhihu.com/p/392257538" target="_blank" rel="noopener">什么是元宇宙_DeFi七点钟社区</a></li><li><a href="https://www.699h5.com/890682.html" target="_blank" rel="noopener">《Roblox》的成功能否复制？</a></li><li><a href="https://neil3d.github.io/metaverse/roblox.html" target="_blank" rel="noopener">元宇宙技术架构案例分析：Roblox</a></li><li><a href="https://mp.weixin.qq.com/s/_5Ji-P8D3dwHSm2z5Bmz-g" target="_blank" rel="noopener">清华大学：2021元宇宙研究报告！</a></li><li><a href="https://github.com/shadowcz007/awesome-metaverse" target="_blank" rel="noopener">github_awesome-metaverse(Useful resources for creating Meta-verse)</a></li><li><a href="https://www.bilibili.com/video/BV1aU4y1M7h4?from=search&amp;seid=15280117859291449599&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">元宇宙到底是什么_小宁子</a></li><li><a href="https://www.bilibili.com/video/BV1RP4y157PC?from=search&amp;seid=14571014384879345793&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">【游戏之外】超硬核！深度拆解元宇宙！我们能否迎来全新的时代与机遇？</a></li></ul><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去，互联网是人们逃避现实的地方；&lt;/p&gt;
&lt;p&gt;现在，现实变成人们逃避互联网的地方。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多思考" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d实战之消灭星星</title>
    <link href="http://yoursite.com/2021/11/23/Cocos2d%E5%AE%9E%E6%88%98%E4%B9%8B%E6%B6%88%E7%81%AD%E6%98%9F%E6%98%9F/"/>
    <id>http://yoursite.com/2021/11/23/Cocos2d%E5%AE%9E%E6%88%98%E4%B9%8B%E6%B6%88%E7%81%AD%E6%98%9F%E6%98%9F/</id>
    <published>2021-11-23T13:00:00.000Z</published>
    <updated>2021-11-23T15:10:23.445Z</updated>
    
    <content type="html"><![CDATA[<p>Cocos2d-x 消灭星星</p><a id="more"></a><p><br></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将很久以前写的教程梳理梳理</p><p><br></p><p><br></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>环境：</p><ul><li>Cocos2d-x 3.4</li><li>VS2012</li></ul><h2 id="一、游戏场景-amp-选中星星"><a href="#一、游戏场景-amp-选中星星" class="headerlink" title="一、游戏场景 &amp; 选中星星"></a>一、游戏场景 &amp; 选中星星</h2><p>星星类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/*           初始化           */</span></span><br><span class="line">Star();</span><br><span class="line"><span class="function"><span class="keyword">static</span> Star* <span class="title">create</span><span class="params">( <span class="keyword">int</span> row , <span class="keyword">int</span> col )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定星星显示状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisplayMode</span><span class="params">(DisplayMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*           设定函数           */</span></span><br><span class="line">CC_SYNTHESIZE(<span class="keyword">int</span>, m_row, Row);</span><br><span class="line">       CC_SYNTHESIZE(<span class="keyword">int</span>, m_col, Col);</span><br><span class="line">CC_SYNTHESIZE(<span class="keyword">int</span>, m_imgIndex, ImgIndex);</span><br><span class="line">       CC_SYNTHESIZE_READONLY(DisplayMode, m_displayMode, DisplayMode);</span><br></pre></td></tr></table></figure><p>GameDefine文件，存储游戏内的一些常量设定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义屏幕宽高，这与所做的图片有关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GAME_SCREEN_WIDTH 480</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GAME_SCREEN_HEIGHT 800</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义每个精灵大小与边框大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STAR_WIDTH 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOADER_WIDTH 0.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 行列值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS 10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 关于这些星星</span></span><br><span class="line"><span class="comment">// 星星的模式，NORMAL 普通状态，HEART 高亮状态</span></span><br><span class="line"><span class="keyword">enum</span> DisplayMode&#123;</span><br><span class="line">    DISPLAY_MODE_NORMAL = <span class="number">0</span>,</span><br><span class="line">    DISPLAY_MODE_HEART</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 星星总数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOTAL_STAR 5</span></span><br><span class="line"><span class="comment">// 普通状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *starNormal[TOTAL_STAR] = &#123;</span><br><span class="line"><span class="string">"red.png"</span>,</span><br><span class="line"><span class="string">"blue.png"</span>,</span><br><span class="line"><span class="string">"green.png"</span>,</span><br><span class="line"><span class="string">"purple.png"</span>,</span><br><span class="line"><span class="string">"yellow.png"</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 高亮状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *starHeart[TOTAL_STAR] = &#123;</span><br><span class="line"><span class="string">"red_heart.png"</span>,</span><br><span class="line"><span class="string">"blue_heart.png"</span>,</span><br><span class="line"><span class="string">"green_heart.png"</span>,</span><br><span class="line"><span class="string">"purple_heart.png"</span>,</span><br><span class="line"><span class="string">"yellow_heart.png"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>游戏场景，用一个二维数组来存储星星个体，通过plist文件加载图集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载plist和png</span></span><br><span class="line">SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile(<span class="string">"stars.plist"</span>);</span><br><span class="line">starSheet = Sprite::create();</span><br><span class="line">starSheet-&gt;setAnchorPoint(Vec2::ZERO);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(starSheet,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 初始化坐标值</span></span><br><span class="line">mapLBX = (GAME_SCREEN_WIDTH - STAR_WIDTH * COLS - (COLS - <span class="number">1</span>) * BOADER_WIDTH) / <span class="number">2</span>;</span><br><span class="line">mapLBY = (GAME_SCREEN_HEIGHT - STAR_WIDTH * ROWS - (ROWS - <span class="number">1</span>) * BOADER_WIDTH) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"bg_mainscene.jpg"</span>);</span><br><span class="line">sprite-&gt;setPosition(Vec2(GAME_SCREEN_WIDTH/<span class="number">2</span>,GAME_SCREEN_HEIGHT/<span class="number">2</span>));</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(sprite, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">initMap();</span><br></pre></td></tr></table></figure><p>初始化地图方法 &amp; 创建星星方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化地图</span></span><br><span class="line"><span class="keyword">void</span> GameScene::initMap( )&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> r = <span class="number">0</span> ; r &lt; ROWS ; ++r )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> c = <span class="number">0</span> ; c &lt; COLS ; ++c )&#123;</span><br><span class="line">createStar(r,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建星星</span></span><br><span class="line"><span class="keyword">void</span> GameScene::createStar( <span class="keyword">int</span> row , <span class="keyword">int</span> col )</span><br><span class="line">&#123;</span><br><span class="line">Star* spr = Star::create(row, col);</span><br><span class="line"></span><br><span class="line">Point pos = positionOfItem(row, col);</span><br><span class="line">    spr-&gt;setPosition(pos);</span><br><span class="line">    starSheet -&gt; addChild(spr);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 填充数组相应位置</span></span><br><span class="line">    <span class="built_in">map</span>[row][col] = spr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下，场景显示完毕</p><p><img src="01.png" alt=""></p><p>接下来，处理选中星星，先是触摸事件的添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GameScene.cpp  init函数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 触摸事件处理</span></span><br><span class="line"><span class="keyword">auto</span> touchListener = EventListenerTouchOneByOne::create();</span><br><span class="line">touchListener-&gt;onTouchBegan = CC_CALLBACK_2(GameScene::onTouchBegan, <span class="keyword">this</span>);</span><br><span class="line">_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>当触摸的时候，逻辑如下：当选中一个星星时，要让它和四个方向上同色的星星都处于高亮状态。</p><p>可以使用一个搜索算法实现</p><ol><li>让当前星星处于高亮状态</li><li>将当前星星分别与和四个方向上星星进行颜色比较<ul><li>若相同，将该星星坐标扔进函数</li><li>若不同，则跳过</li></ul></li></ol><p>当然，要记得设置标记数组，避免遍历过的星星再次遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触摸事件</span></span><br><span class="line"><span class="keyword">bool</span> GameScene::onTouchBegan(Touch *touch, Event *unused)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> location = touch-&gt;getLocation();</span><br><span class="line">Star* sta;</span><br><span class="line">sta = starOfPoint(&amp;location);</span><br><span class="line"><span class="keyword">if</span>( sta )&#123;</span><br><span class="line"><span class="comment">// 初始化记忆地图mapR+恢复普通状态</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ROWS ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;COLS ; j++ )&#123;</span><br><span class="line">mapR[i][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">map</span>[i][j]-&gt;setDisplayMode(DISPLAY_MODE_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只有当前一个星星这个颜色，不要让它处于高亮状态</span></span><br><span class="line"><span class="keyword">if</span>( waitPop(sta-&gt;getRow(),sta-&gt;getCol()) == <span class="number">1</span> )</span><br><span class="line">sta-&gt;setDisplayMode(DISPLAY_MODE_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面mapR数组就是标记数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> GameScene::waitPop(<span class="keyword">int</span> row , <span class="keyword">int</span> col)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,r,c,tol;</span><br><span class="line"><span class="comment">// 四个方向 </span></span><br><span class="line"><span class="keyword">int</span> search[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">tol = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">map</span>[row][col]-&gt;setDisplayMode(DISPLAY_MODE_HEART);</span><br><span class="line">mapR[row][col] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 四个方向遍历</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line">r = row + search[i][<span class="number">0</span>];</span><br><span class="line">c = col + search[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>( r &gt;= <span class="number">0</span> &amp;&amp; r &lt; ROWS &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; COLS )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[row][col]-&gt;getImgIndex() == <span class="built_in">map</span>[r][c]-&gt;getImgIndex() &amp;&amp; !mapR[r][c] )&#123;</span><br><span class="line">mapR[r][c] = <span class="literal">true</span>;</span><br><span class="line">tol += waitPop(r,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> tol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取设置一些工具函数，方便处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据行列，获取坐标值</span></span><br><span class="line">Point GameScene::positionOfItem(<span class="keyword">int</span> row , <span class="keyword">int</span> col)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> x = mapLBX + (STAR_WIDTH + BOADER_WIDTH) * col + STAR_WIDTH / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> y = mapLBY + (STAR_WIDTH + BOADER_WIDTH) * row + STAR_WIDTH / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Point(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据触摸点，判断地图上的星星位置</span></span><br><span class="line">Star* GameScene::starOfPoint(Point *point)</span><br><span class="line">&#123;</span><br><span class="line">    Star *sta = <span class="literal">NULL</span>;</span><br><span class="line">    Rect rect = Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Size sz;</span><br><span class="line">sz.height=STAR_WIDTH;</span><br><span class="line">sz.width=STAR_WIDTH;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> r = <span class="number">0</span> ; r &lt; ROWS ; ++r )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> c = <span class="number">0</span> ; c &lt; COLS ; ++c )&#123;</span><br><span class="line">sta = <span class="built_in">map</span>[r][c];</span><br><span class="line"><span class="keyword">if</span>( sta )&#123;</span><br><span class="line">rect.origin.x = sta-&gt;getPositionX() - ( STAR_WIDTH / <span class="number">2</span>);</span><br><span class="line">rect.origin.y = sta-&gt;getPositionY() - ( STAR_WIDTH / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">rect.size = sz;</span><br><span class="line"><span class="keyword">if</span> (rect.containsPoint(*point)) &#123;</span><br><span class="line"><span class="keyword">return</span> sta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="02.png" alt=""></p><p><br></p><h2 id="二、消除逻辑"><a href="#二、消除逻辑" class="headerlink" title="二、消除逻辑"></a>二、消除逻辑</h2><p>处于高亮状态下的星星，再次被点击时的消除逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触摸事件</span></span><br><span class="line"><span class="keyword">bool</span> GameScene::onTouchBegan(Touch *touch, Event *unused)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> location = touch-&gt;getLocation();</span><br><span class="line">Star* sta;</span><br><span class="line">sta = starOfPoint(&amp;location);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前对象不为空</span></span><br><span class="line"><span class="keyword">if</span>( sta )&#123;</span><br><span class="line"><span class="comment">// 看该 星星 处于什么状态</span></span><br><span class="line"><span class="keyword">if</span>( sta-&gt;getDisplayMode() == DISPLAY_MODE_NORMAL )&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化记忆地图mapR+恢复普通状态</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ROWS ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;COLS ; j++ )&#123;</span><br><span class="line">mapR[i][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[i][j]!=<span class="literal">NULL</span> )</span><br><span class="line"><span class="built_in">map</span>[i][j]-&gt;setDisplayMode(DISPLAY_MODE_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果只有当前一个星星这个颜色，不要让它处于高亮状态</span></span><br><span class="line"><span class="keyword">if</span>( waitPop(sta-&gt;getRow(),sta-&gt;getCol()) == <span class="number">1</span> )&#123;</span><br><span class="line">mapR[sta-&gt;getRow()][sta-&gt;getCol()]=<span class="literal">false</span>;</span><br><span class="line">sta-&gt;setDisplayMode(DISPLAY_MODE_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">deleteStar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所点击的星星非空时，判断星星是否为高亮状态，若不是，则初始化标记数组，将所有星星显示状态恢复为普通。</p><p>注意，此处所有星星的显示状态中，要把消除掉的过滤掉。</p><p>然后，是消除星星的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameScene::deleteStar( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r,c;</span><br><span class="line"><span class="keyword">for</span>( r = <span class="number">0</span> ; r &lt; ROWS ; r++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( c = <span class="number">0</span> ;c &lt; COLS ; c++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( mapR[r][c] == <span class="literal">true</span> )&#123;</span><br><span class="line"><span class="comment">// popStar(map[i][j]);</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>[r][c]-&gt;removeFromParent();</span><br><span class="line"><span class="built_in">map</span>[r][c]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化标记数组，可用memset函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GameScene::GameScene()</span><br><span class="line">: starSheet(<span class="literal">NULL</span>)</span><br><span class="line">,mapLBX ( (GAME_SCREEN_WIDTH - STAR_WIDTH * COLS - (COLS - <span class="number">1</span>) * BOADER_WIDTH) / <span class="number">2</span> )</span><br><span class="line">,mapLBY ( (GAME_SCREEN_HEIGHT - STAR_WIDTH * ROWS - (ROWS - <span class="number">1</span>) * BOADER_WIDTH) / <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 mapR 数组(string.h 头文件)</span></span><br><span class="line"><span class="built_in">memset</span>(mapR,<span class="literal">false</span>,<span class="keyword">sizeof</span>(mapR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下消除后的效果（本来想用GIF，但是工具出了点问题，简单看个图片吧）</p><p><img src="03.png" alt=""></p><p>星星已经消除成功，接下来是消除后的整合处理。</p><p>思路：</p><ol><li>向下归拢，按列为单位，每列中从下往上遍历</li><li>遍历到第一个为空对象，将该对象上方第一个不为空对象，落下来，不断向上遍历到最后</li><li>向左归拢，依旧按列为单位，先判断每列第一行是否为空</li><li>遍历到第一个为空对象，将该对象右方第一个不为空对象，移过来，不断向右遍历到最后</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameScene::adjustStar( )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r,c;</span><br><span class="line"><span class="comment">// 向下归拢</span></span><br><span class="line"><span class="keyword">for</span>( c = <span class="number">0</span> ; c &lt; COLS ; c++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( r = <span class="number">0</span> ; r &lt; ROWS<span class="number">-1</span> ; r++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[r][c] == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> newR = r+<span class="number">1</span> ; newR &lt; ROWS ; newR++ )&#123;</span><br><span class="line">Star* sta = <span class="built_in">map</span>[newR][c];</span><br><span class="line"><span class="keyword">if</span>( sta != <span class="literal">NULL</span> )&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>[r][c] = sta;</span><br><span class="line"><span class="built_in">map</span>[newR][c] = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">Point startPosition = sta-&gt;getPosition();</span><br><span class="line">Point endPosition = positionOfItem(r, c);</span><br><span class="line"><span class="keyword">float</span> speed = (startPosition.y - endPosition.y) / GAME_SCREEN_HEIGHT*<span class="number">2</span>;</span><br><span class="line">sta-&gt;stopAllActions();</span><br><span class="line">sta-&gt;runAction(MoveTo::create(speed, endPosition));</span><br><span class="line">sta-&gt;setRow(r);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向左归拢</span></span><br><span class="line"><span class="keyword">for</span>( c = <span class="number">0</span> ; c &lt; COLS<span class="number">-1</span> ; c++ )</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[<span class="number">0</span>][c] == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> newC=c+<span class="number">1</span>; newC &lt; COLS ; newC++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[<span class="number">0</span>][newC] != <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> moveR = <span class="number">0</span> ; moveR &lt; ROWS ; moveR++ )&#123;</span><br><span class="line">Star* sta = <span class="built_in">map</span>[moveR][newC];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( sta!=<span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">map</span>[moveR][c] = sta;</span><br><span class="line"><span class="built_in">map</span>[moveR][newC] = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">Point startPosition = sta-&gt;getPosition();</span><br><span class="line">Point endPosition = positionOfItem(moveR,c);</span><br><span class="line"><span class="keyword">float</span> speed = (startPosition.x - endPosition.x) / GAME_SCREEN_WIDTH*<span class="number">2</span>;</span><br><span class="line">sta-&gt;stopAllActions();</span><br><span class="line">sta-&gt;runAction(MoveTo::create(speed, endPosition));</span><br><span class="line">sta-&gt;setCol(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示</p><p><img src="04.png" alt=""></p><p>最后，判断游戏是否结束</p><p>思路：</p><ul><li>由于数组不大，直接遍历即可</li><li>将本对象与上下左右四个方向上对象比较<ul><li>如果有同颜色，直接返回false（表示 未结束）</li><li>如果无同颜色，返回true（表示 结束）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GameScene::isFinish( )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,r,c;</span><br><span class="line"><span class="comment">// 四个方向 </span></span><br><span class="line"><span class="keyword">int</span> search[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>( r = <span class="number">0</span> ; r &lt; ROWS ; r++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( c = <span class="number">0</span> ; c &lt; COLS ; c++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( !<span class="built_in">map</span>[r][c] )<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++ )&#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + search[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> nc = c + search[i][<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( nr&gt;=<span class="number">0</span> &amp;&amp; nr&lt;ROWS &amp;&amp; nc&gt;=<span class="number">0</span> &amp;&amp; nc&lt;COLS )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[nr][nc]!=<span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>[r][c]-&gt;getImgIndex() == <span class="built_in">map</span>[nr][nc]-&gt;getImgIndex() )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后效果</p><p><img src="05.png" alt=""></p><p><br></p><h2 id="三、特效"><a href="#三、特效" class="headerlink" title="三、特效"></a>三、特效</h2><h3 id="爆炸特效"><a href="#爆炸特效" class="headerlink" title="爆炸特效"></a>爆炸特效</h3><p>在星星消除后，加一些爆炸的粒子特效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starSpecialEffect</span><span class="params">(Star* sta,Point position,Node* node,<span class="keyword">int</span> staNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建爆炸粒子效果，粒子数量为 staNum 个</span></span><br><span class="line">ParticleExplosion* effect = ParticleExplosion::createWithTotalParticles(staNum);</span><br><span class="line"><span class="comment">// 设置此粒子特效的纹理图片</span></span><br><span class="line">    effect-&gt;setTexture(Director::getInstance()-&gt;getTextureCache()-&gt;addImage(<span class="string">"star.png"</span>));</span><br><span class="line"><span class="comment">// 设置开始时候的粒子颜色</span></span><br><span class="line">effect-&gt;setStartColor(getColor4F(sta-&gt;getImgIndex()));</span><br><span class="line">effect-&gt;setStartColorVar(Color4F(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    effect-&gt;setEndColor(getColor4F(sta-&gt;getImgIndex()));</span><br><span class="line">    effect-&gt;setEndColorVar(Color4F(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 设置开始时的粒子大小</span></span><br><span class="line">    effect-&gt;setStartSize(<span class="number">20.0f</span>);</span><br><span class="line">    effect-&gt;setGravity(Point(<span class="number">0</span>,<span class="number">-300</span>));</span><br><span class="line"><span class="comment">// 设置粒子生命周期</span></span><br><span class="line">    effect-&gt;setLife(<span class="number">2.0f</span>);</span><br><span class="line"><span class="comment">// 设置粒子速度</span></span><br><span class="line">    effect-&gt;setSpeed(<span class="number">200</span>);</span><br><span class="line">    effect-&gt;setSpeedVar(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 设置粒子位置</span></span><br><span class="line">    effect-&gt;setPosition(position);</span><br><span class="line">    node-&gt;addChild(effect,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Color4F <span class="title">getColor4F</span><span class="params">(<span class="keyword">int</span> imgIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(imgIndex)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">//red</span></span><br><span class="line"><span class="keyword">return</span> Color4F::RED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">//blue</span></span><br><span class="line"><span class="keyword">return</span> Color4F::BLUE;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//green</span></span><br><span class="line"><span class="keyword">return</span> Color4F::GREEN;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//purple</span></span><br><span class="line"><span class="keyword">return</span> Color4F(<span class="number">128.0f</span>,<span class="number">0</span>,<span class="number">128.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="comment">//yellow</span></span><br><span class="line"><span class="keyword">return</span> Color4F::YELLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Color4F(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="06.png" alt=""></p><h3 id="音乐音效"><a href="#音乐音效" class="headerlink" title="音乐音效"></a>音乐音效</h3><p>此处用UserDefault存储开关，此处并没有分开处理，而是一个开关控制。</p><p>背景音乐，需要重载虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景加载完成后进行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onEnterTransitionDidFinish</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 场景被消除时执行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>添加方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WelcomeScene::onEnterTransitionDidFinish()</span><br><span class="line">&#123;</span><br><span class="line">Layer::onEnterTransitionDidFinish();  </span><br><span class="line"><span class="keyword">if</span> ( userDefault-&gt;getBoolForKey(<span class="string">"MusicKey"</span>) ) &#123;                      </span><br><span class="line">        SimpleAudioEngine::getInstance()-&gt;playBackgroundMusic(<span class="string">"Music/music.ogg"</span>, <span class="literal">true</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> WelcomeScene::cleanup()</span><br><span class="line">&#123;</span><br><span class="line">Layer::cleanup();</span><br><span class="line">SimpleAudioEngine::getInstance()-&gt;stopBackgroundMusic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漂浮文字"><a href="#漂浮文字" class="headerlink" title="漂浮文字"></a>漂浮文字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FloatWord* FloatWord::create( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word,<span class="keyword">const</span> <span class="keyword">int</span> fontSize,Vec2 begin )</span><br><span class="line">&#123;</span><br><span class="line">FloatWord* fw = <span class="keyword">new</span> FloatWord();</span><br><span class="line"><span class="keyword">if</span>( !fw-&gt;init(word,fontSize,begin) )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fw-&gt;autorelease();</span><br><span class="line"><span class="keyword">return</span> fw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FloatWord::floatInOut(<span class="keyword">const</span> <span class="keyword">float</span> speed,<span class="keyword">const</span> <span class="keyword">float</span> delayTime,<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; callback)&#123;</span><br><span class="line"></span><br><span class="line">MoveTo* moveIn = MoveTo::create(speed,Vec2(GAME_SCREEN_WIDTH/<span class="number">2</span>,fw_begin.y));</span><br><span class="line">MoveTo* moveOut = MoveTo::create(speed,Vec2(-fw_label-&gt;getContentSize().width,fw_begin.y));</span><br><span class="line"> </span><br><span class="line">CallFunc* call = CallFunc::create(callback);</span><br><span class="line"> </span><br><span class="line">Sequence* action = Sequence::create(moveIn,DelayTime::create(delayTime),moveOut,call,<span class="literal">NULL</span>);</span><br><span class="line">fw_label-&gt;runAction(action);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> FloatWord::floatIn(<span class="keyword">const</span> <span class="keyword">float</span> speed)&#123;</span><br><span class="line"></span><br><span class="line">MoveTo* moveIn = MoveTo::create(speed,Vec2(GAME_SCREEN_WIDTH/<span class="number">2</span>,fw_begin.y));</span><br><span class="line"> </span><br><span class="line">Sequence* action = Sequence::create(moveIn,<span class="literal">NULL</span>);</span><br><span class="line">fw_label-&gt;runAction(action);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> FloatWord::floatOut(<span class="keyword">const</span> <span class="keyword">float</span> speed,<span class="keyword">const</span> <span class="keyword">float</span> delayTime)&#123;</span><br><span class="line"></span><br><span class="line">MoveTo* moveOut = MoveTo::create(speed,Vec2(-fw_label-&gt;getContentSize().width,fw_begin.y));</span><br><span class="line"> </span><br><span class="line">Sequence* action = Sequence::create(DelayTime::create(delayTime),moveOut,<span class="literal">NULL</span>);</span><br><span class="line">fw_label-&gt;runAction(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加后效果：</p><p><img src="07.png" alt=""></p><h3 id="Combo特效-amp-最终星星消除"><a href="#Combo特效-amp-最终星星消除" class="headerlink" title="Combo特效 &amp; 最终星星消除"></a>Combo特效 &amp; 最终星星消除</h3><p>首先是combo特效，每次消除的时候，判断消除的个数是否满足combo条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comboEffect</span><span class="params">(<span class="keyword">int</span> num,Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( num &lt; <span class="number">5</span> )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">Sprite* comboSprite;</span><br><span class="line"><span class="keyword">if</span>( num &gt;= <span class="number">10</span> )&#123;</span><br><span class="line">comboSprite = Sprite::create(<span class="string">"combo_3.png"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( num &gt;= <span class="number">7</span> )&#123;</span><br><span class="line">comboSprite = Sprite::create(<span class="string">"combo_2.png"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">comboSprite = Sprite::create(<span class="string">"combo_1.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">comboSprite-&gt;setPosition(Vec2(GAME_SCREEN_WIDTH/<span class="number">2</span>,GAME_SCREEN_HEIGHT/<span class="number">2</span>));</span><br><span class="line">node-&gt;addChild(comboSprite,<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">Blink* blink = Blink::create(<span class="number">1.0f</span>,<span class="number">5</span>);</span><br><span class="line">CallFunc* remove = CallFunc::create([=]()&#123;comboSprite-&gt;removeFromParentAndCleanup(<span class="literal">true</span>);&#125;);</span><br><span class="line">Sequence* action = Sequence::create(blink,remove,<span class="literal">nullptr</span>);</span><br><span class="line">comboSprite-&gt;runAction(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后星星消除，流程如下</p><ol><li>判断此关卡结束（没有可以消除的星星），然后将全局的关卡结束变量设置为true，获得剩余星星的数量，如果剩余星星数量大于10则设置为10个（因为一个个消除的效果，最多10个）</li><li>在update函数中（每一帧都会调用），会判断关卡是否结束；若结束，调用消除函数，10个以内，每消除一个都会返回，不会继续消除，而且记录消除时间，消除一次后一定时间间隔再进行下一次消除</li><li>消除完10个（或者小于10个）以后，不会再返回，会一次性将剩余星星消除完毕，将关卡结束变量设置为false</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( isFinish() )&#123;</span><br><span class="line">    isLevelFinish = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = totalStarNum();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( temp &lt;= <span class="number">10</span> )&#123;</span><br><span class="line">        needDelOneByOne = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    needDelOneByOne = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameScene::update( <span class="keyword">float</span> dt )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 分数变化</span></span><br><span class="line">Label *labelScore = (Label *)<span class="keyword">this</span> -&gt; getChildByTag(<span class="number">6</span>);</span><br><span class="line">labelScore -&gt; setString( StringUtils::format(<span class="string">"Score: %d "</span>,_score));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果当前关卡结束  星星一个个消除的实现</span></span><br><span class="line"><span class="keyword">if</span>( isLevelFinish )&#123;</span><br><span class="line"> </span><br><span class="line">deleteTime += dt;</span><br><span class="line"><span class="keyword">if</span>( deleteTime &gt; DELSTAR_ONEBYONE_TIME )&#123;</span><br><span class="line">popFinishStar(needDelOneByOne);</span><br><span class="line">needDelOneByOne--;</span><br><span class="line">deleteTime = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消除最终星星函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameScene::popFinishStar( <span class="keyword">int</span> n )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r,c;</span><br><span class="line">Star* sta;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>( r = ROWS<span class="number">-1</span> ; r &gt;= <span class="number">0</span> ; r-- )&#123;</span><br><span class="line"><span class="keyword">for</span>( c = <span class="number">0</span> ; c &lt; COLS ; c++ )&#123;</span><br><span class="line">sta = <span class="built_in">map</span>[r][c];</span><br><span class="line"><span class="keyword">if</span>( sta )&#123;</span><br><span class="line">starSpecialEffect(sta,sta-&gt;getPosition(),<span class="keyword">this</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">map</span>[r][c]=<span class="literal">NULL</span>;</span><br><span class="line">sta-&gt;removeFromParentAndCleanup(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">starSpecialEffect(sta,sta-&gt;getPosition(),<span class="keyword">this</span>,totalStarNum()*<span class="number">4</span>);</span><br><span class="line"><span class="built_in">map</span>[r][c]=<span class="literal">NULL</span>;</span><br><span class="line">sta-&gt;removeFromParentAndCleanup(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">isLevelFinish = <span class="literal">false</span>;</span><br><span class="line">scheduleOnce(schedule_selector(GameScene::levelOver),<span class="number">2.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种combo效果</p><p><img src="08.png" alt=""></p><p><img src="09.png" alt=""></p><p><img src="10.png" alt=""></p><h3 id="最高分记录"><a href="#最高分记录" class="headerlink" title="最高分记录"></a>最高分记录</h3><p>依旧用UserDefault存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( userDefault-&gt;getIntegerForKey(<span class="string">"HightScore"</span>) &lt; _score )</span><br><span class="line">userDefault-&gt;setIntegerForKey(<span class="string">"HightScore"</span>,_score);</span><br></pre></td></tr></table></figure><p>场景的存储用了push和pop，</p><p>在主界面定义一个变量，来判断是否可以继续，</p><p>刚进入主界面时，场景栈是没有场景存储的，此时点击继续游戏就会退出游戏，所以要在场景栈没有场景时，不允许点击继续游戏按钮，</p><p>这个变量，在从游戏界面跳转到主界面（通过返回函数跳转）时，会设置为true，就是可以点击。</p><h3 id="消除星星Hint"><a href="#消除星星Hint" class="headerlink" title="消除星星Hint"></a>消除星星Hint</h3><p>当消除几个星星，都要有提示，加了多少分。</p><p>游戏结束，如果剩余星星数小于10个，还会有额外加分。</p><p>星星消除逻辑</p><ul><li><p>一个等差数列，第一个星星5分，第二个15分，第三个25分（首项为5，公差为10）</p></li><li><p>当消除n个星星</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n*5 + n*(n-1) * 10 / 2</span><br></pre></td></tr></table></figure></li></ul><p>剩余星星数量，所获得的额外分数，则通过数组，放在GameDefine头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余星星所奖励的分数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> rewardScore[<span class="number">11</span>] = &#123;</span><br><span class="line"><span class="number">2000</span>,</span><br><span class="line"><span class="number">1980</span>,</span><br><span class="line"><span class="number">1920</span>,</span><br><span class="line"><span class="number">1820</span>,</span><br><span class="line"><span class="number">1680</span>,</span><br><span class="line"><span class="number">1500</span>,</span><br><span class="line"><span class="number">1280</span>,</span><br><span class="line"><span class="number">1020</span>,</span><br><span class="line"><span class="number">720</span>,</span><br><span class="line"><span class="number">380</span>,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="11.png" alt=""></p><p><img src="12.png" alt=""></p><p><br></p><p><br></p><hr><p>资料</p><ul><li><a href="https://pan.baidu.com/s/1c01zfsW" target="_blank" rel="noopener">源码</a></li><li><a href="https://pan.baidu.com/s/1kTlBPm3" target="_blank" rel="noopener">APK</a></li></ul><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cocos2d-x 消灭星星&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多实践" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d实战之别踩白块</title>
    <link href="http://yoursite.com/2021/11/23/Cocos2d%E5%AE%9E%E6%88%98%E4%B9%8B%E5%88%AB%E8%B8%A9%E7%99%BD%E5%9D%97/"/>
    <id>http://yoursite.com/2021/11/23/Cocos2d%E5%AE%9E%E6%88%98%E4%B9%8B%E5%88%AB%E8%B8%A9%E7%99%BD%E5%9D%97/</id>
    <published>2021-11-23T13:00:00.000Z</published>
    <updated>2021-11-23T14:26:35.716Z</updated>
    
    <content type="html"><![CDATA[<p>Cocos2d-x 别踩白块</p><a id="more"></a><p><br></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将很久以前写的教程梳理梳理</p><p><br></p><p><br></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>环境：</p><ul><li>Cocos2d-x 3.2</li><li>VS2012</li></ul><h2 id="块，Block"><a href="#块，Block" class="headerlink" title="块，Block"></a>块，Block</h2><p>首先新建一个项目，</p><p>然后修改它的 AppDelegate.cpp ，将显示尺寸调整成竖屏分辨率。</p><p>最后在生成APK前，还要在android那设置，永远竖屏的属性。</p><p>最重要的类：块，Block</p><p>在游戏内，有很多不同颜色的块（黑色、白色、黄色等），这些块统一封装到一个类中，通过不同参数来控制呈现不同状态。</p><p>参数：</p><ul><li>颜色</li><li>大小</li><li>内容文本</li><li>内容字体大小</li><li>内容字体颜色</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> Block::init( Color3B color , Size size , <span class="built_in">std</span>::<span class="built_in">string</span> label , <span class="keyword">float</span> fontSize , Color4B textColor )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先执行Sprite的初始化</span></span><br><span class="line"><span class="keyword">if</span>( !Sprite::init() )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置Block的内容大小</span></span><br><span class="line">setContentSize(size);</span><br><span class="line"><span class="comment">//左下角对齐</span></span><br><span class="line">setAnchorPoint(Point::ZERO);</span><br><span class="line"><span class="comment">//文字显示位置</span></span><br><span class="line">setTextureRect(Rect(<span class="number">0</span>,<span class="number">0</span>,size.width,size.height));</span><br><span class="line"><span class="comment">//颜色</span></span><br><span class="line">setColor(color);</span><br><span class="line"><span class="comment">//添加一个文本</span></span><br><span class="line"><span class="keyword">auto</span> l = Label::create();</span><br><span class="line">l-&gt;setString(label);</span><br><span class="line">l-&gt;setSystemFontSize(fontSize);</span><br><span class="line">l-&gt;setTextColor(textColor);</span><br><span class="line"><span class="comment">//添加到当前场景中</span></span><br><span class="line">addChild(l);</span><br><span class="line">l-&gt;setPosition(size.width/<span class="number">2</span>,size.height/<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在Block类中，还需要支持增删方法及容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化Vector</span></span><br><span class="line">Vector&lt;Block*&gt; * Block::blocks = <span class="keyword">new</span> Vector&lt;Block*&gt;();</span><br><span class="line">Block* Block::createBlock( Color3B color , Size size , <span class="built_in">std</span>::<span class="built_in">string</span> label , <span class="keyword">float</span> fontSize , Color4B textColor )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> block = <span class="keyword">new</span> Block();</span><br><span class="line">block -&gt; init(color,size,label,fontSize,textColor);</span><br><span class="line">block -&gt; autorelease();</span><br><span class="line"> </span><br><span class="line">blocks -&gt; pushBack(block);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Block::removeBlock() </span><br><span class="line">&#123;</span><br><span class="line">removeFromParent();</span><br><span class="line">blocks-&gt;eraseObject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础的块类实现后，来贴合游戏业务，实现开始行和结束行。</p><p>此处，直接调整模板附带的HelloWorldScene</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> HelloWorld::addStartLine()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加一个方块</span></span><br><span class="line"><span class="keyword">auto</span> block = Block::createBlock(Color3B::YELLOW,Size(visibleSize.width,visibleSize.height/<span class="number">4</span>),<span class="string">""</span>,<span class="number">20</span>,Color4B::BLACK);</span><br><span class="line">addChild(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完开始行，看一下效果：</p><p><img src="01.png" alt=""></p><p>添加结束行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加结束行</span></span><br><span class="line"><span class="keyword">void</span> HelloWorld::addEndLine()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> block = Block::createBlock(Color3B::GREEN,visibleSize,<span class="string">"Game Over"</span>,<span class="number">32</span>,Color4B::BLACK);</span><br><span class="line">addChild(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完开始行和结束行，再将中间内容黑白块填充一下</p><p>首先，在Block类中添加一个变量 lineIndex，</p><p>然后，添加与它相关的get和set函数</p><p>这个变量用处是 来知道该块放在哪一行，</p><p>比如开始行就应该放在第0行（在addStartLine相应位置修改一下）</p><p>结束行就该放在 第4行（同上，也在相应位置修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加黑白块</span></span><br><span class="line"><span class="keyword">void</span> HelloWorld::addNormalLine( <span class="keyword">int</span> lineIndex )</span><br><span class="line">&#123;</span><br><span class="line">Block* block;</span><br><span class="line"><span class="comment">//rand()是伪随机数</span></span><br><span class="line"><span class="keyword">int</span> blackIndex = rand()%<span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">block=Block::createBlock(blackIndex==i?Color3B::BLACK:Color3B::WHITE,</span><br><span class="line">Size(visibleSize.width/<span class="number">4</span><span class="number">-2</span>,visibleSize.height/<span class="number">4</span><span class="number">-2</span>),<span class="string">""</span>,<span class="number">20</span>,Color4B::BLACK);</span><br><span class="line">addChild(block);</span><br><span class="line"> </span><br><span class="line">block-&gt;setPosition(i*visibleSize.width/<span class="number">4</span>, lineIndex*visibleSize.height/<span class="number">4</span>);</span><br><span class="line">block-&gt;setLineIndex(lineIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要知道，整个界面被分成四行（0、1、2、3） 和 四列，</p><p>这里随机数随机生成 0~3 ，每行中只有一个会和 i 相同，这个就是黑色块，其余的就是白色块，</p><p>让场景初始化的时候调用自定义的开始函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> HelloWorld::startGame()</span><br><span class="line">&#123;</span><br><span class="line">addStartLine();</span><br><span class="line"> </span><br><span class="line">addNormalLine(<span class="number">1</span>);</span><br><span class="line">addNormalLine(<span class="number">2</span>);</span><br><span class="line">addNormalLine(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，基础的样子已经呈现出来了</p><p><img src="02.png" alt=""></p><p><br></p><h2 id="逻辑，Logic"><a href="#逻辑，Logic" class="headerlink" title="逻辑，Logic"></a>逻辑，Logic</h2><p>别踩白块游戏，主要逻辑是让玩家按照顺序，点击黑色的块，避免点击白色的块，所以要实践触摸事件。</p><p>首先，判断点击事件时，要遍历所有的块，所以需要获取所有块的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取所有的块</span></span><br><span class="line">Vector&lt;Block*&gt; * Block::getBlocks()&#123;</span><br><span class="line"><span class="keyword">return</span> Block::blocks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，添加监听器，监听触摸事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !Layer::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取屏幕大小</span></span><br><span class="line">visibleSize= Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line"><span class="comment">// 开始游戏</span></span><br><span class="line">startGame();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加监听器</span></span><br><span class="line"><span class="keyword">auto</span> listener = EventListenerTouchOneByOne::create();</span><br><span class="line">listener-&gt;onTouchBegan= [<span class="keyword">this</span>](Touch* t,Event* e)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bs = Block::getBlocks();</span><br><span class="line">Block *b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = bs-&gt;begin();it!=bs-&gt;end();it++)</span><br><span class="line">&#123;</span><br><span class="line">b = *it;</span><br><span class="line"><span class="comment">//游戏逻辑的实现</span></span><br><span class="line"><span class="comment">// 如果点击</span></span><br><span class="line"><span class="keyword">if</span>( b-&gt;getLineIndex()==<span class="number">1</span> &amp;&amp; b-&gt;getBoundingBox().containsPoint(t-&gt;getLocation()) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b-&gt;getColor()==Color3B::BLACK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 触摸到黑色块，就让它变成灰色</span></span><br><span class="line">b-&gt;setColor(Color3B::GRAY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 未触摸到该行黑色块，就提示 游戏失败</span></span><br><span class="line">MessageBox(<span class="string">"GameOver"</span>,<span class="string">"失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们实现了第一行的逻辑，只能点黑块，不能点白块。</p><p>接下来，要在点击正确后，将所有行整体下移一行，最上面产生一个新行，我们通过新的方法来实现该逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向下移动一行</span></span><br><span class="line"><span class="keyword">void</span> HelloWorld::moveDown()&#123;</span><br><span class="line"><span class="comment">// 产生新的一行</span></span><br><span class="line">addNormalLine(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> bs = Block::getBlocks();</span><br><span class="line"><span class="comment">//遍历所有方块，让方块向下移动，最下面的一行消除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = bs-&gt;begin();it!=bs-&gt;end();it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;moveDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block.cpp </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Block::moveDown()&#123;</span><br><span class="line">Size visibleSize = Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line"><span class="keyword">this</span>-&gt;lineIndex--;</span><br><span class="line"><span class="comment">//时间用0.1秒，移动到指定的位置（X方向不变，Y方向）</span></span><br><span class="line">runAction(Sequence::create(MoveTo::create(<span class="number">0.1f</span>,Point(getPositionX(),lineIndex*visibleSize.height/<span class="number">4</span>)),</span><br><span class="line">CallFunc::create([<span class="keyword">this</span>]()&#123;</span><br><span class="line"><span class="keyword">if</span> (lineIndex&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;removeBlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;),<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，处理游戏结束时的情况。</p><p>目前的玩法就是 走50行，然后计算花费的时间。</p><p>因此，需要记录已经实现的行数，然后在走到第50行的时候判断</p><ul><li>若已经显示最后一行（全绿），就无需动作</li><li>若还没有显示最后一行，需要执行新动作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向下移动一行</span></span><br><span class="line"><span class="keyword">void</span> HelloWorld::moveDown()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( lineCount &lt; <span class="number">50</span> )&#123;</span><br><span class="line"><span class="comment">// 产生新的一行</span></span><br><span class="line">addNormalLine(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( !isEnd )&#123;</span><br><span class="line">addEndLine();</span><br><span class="line">isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> bs = Block::getBlocks();</span><br><span class="line"><span class="comment">//遍历所有方块，让方块向下移动，最下面的一行消除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = bs-&gt;begin();it!=bs-&gt;end();it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it)-&gt;moveDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !Layer::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取屏幕大小</span></span><br><span class="line">visibleSize= Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line"><span class="comment">// 开始游戏</span></span><br><span class="line">startGame();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加监听器</span></span><br><span class="line"><span class="keyword">auto</span> listener = EventListenerTouchOneByOne::create();</span><br><span class="line">listener-&gt;onTouchBegan= [<span class="keyword">this</span>](Touch* t,Event* e)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bs = Block::getBlocks();</span><br><span class="line">Block *b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = bs-&gt;begin();it!=bs-&gt;end();it++)</span><br><span class="line">&#123;</span><br><span class="line">b = *it;</span><br><span class="line"><span class="comment">//游戏逻辑的实现</span></span><br><span class="line"><span class="comment">// 如果点击</span></span><br><span class="line"><span class="keyword">if</span>( b-&gt;getLineIndex()==<span class="number">1</span> &amp;&amp; b-&gt;getBoundingBox().containsPoint(t-&gt;getLocation()) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b-&gt;getColor()==Color3B::BLACK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 触摸到黑色块，就让它变成灰色</span></span><br><span class="line">b-&gt;setColor(Color3B::GRAY);</span><br><span class="line"><span class="keyword">this</span>-&gt;moveDown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( b-&gt;getColor()==Color3B::GREEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;moveDown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 未触摸到该行黑色块，就提示 游戏失败</span></span><br><span class="line">MessageBox(<span class="string">"GameOver"</span>,<span class="string">"失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以开始和结束了，游戏生命周期算完整了。</p><p>最后，再处理一下计时相关。</p><p>首先是显示，块是一行行在移动的，但是时间文本是固定不变的，因此可以分为两层，一层显示文本，一层处理块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp   init函数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加游戏层</span></span><br><span class="line">gameLayer = Node::create();</span><br><span class="line">addChild(gameLayer);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加时间</span></span><br><span class="line">timerLabel = Label::create();</span><br><span class="line">timerLabel -&gt;setTextColor(Color4B::BLUE);</span><br><span class="line">timerLabel-&gt;setSystemFontSize(<span class="number">48</span>);</span><br><span class="line">timerLabel-&gt;setPosition(visibleSize.width/<span class="number">2</span>,visibleSize.height<span class="number">-100</span>);</span><br><span class="line">addChild(timerLabel);</span><br></pre></td></tr></table></figure><p>然后处理时间的 开始、停止、更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HelloWorld::startTimer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!isTimerRunning)</span><br><span class="line">&#123;</span><br><span class="line">scheduleUpdate();</span><br><span class="line"><span class="comment">//获取到了clock的时间</span></span><br><span class="line">startTime = clock();</span><br><span class="line"> </span><br><span class="line">isTimerRunning = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> HelloWorld::stopTimer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isTimerRunning)</span><br><span class="line">&#123;</span><br><span class="line">unscheduleUpdate();</span><br><span class="line"> </span><br><span class="line">isTimerRunning = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> HelloWorld::update( <span class="keyword">float</span> dt )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//时间的偏差</span></span><br><span class="line"><span class="keyword">long</span> offset = clock()-startTime;</span><br><span class="line"><span class="comment">//强转offset为double类型</span></span><br><span class="line">timerLabel-&gt;setString(StringUtils::format(<span class="string">"%g"</span>,((<span class="keyword">double</span>)offset)/<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在触碰判断处，设定开始计时和停止计时的时机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldScene.cpp  init函数  监听器部分</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加监听器</span></span><br><span class="line"><span class="keyword">auto</span> listener = EventListenerTouchOneByOne::create();</span><br><span class="line">listener-&gt;onTouchBegan= [<span class="keyword">this</span>](Touch* t,Event* e)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bs = Block::getBlocks();</span><br><span class="line">Block *b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = bs-&gt;begin();it!=bs-&gt;end();it++)</span><br><span class="line">&#123;</span><br><span class="line">b = *it;</span><br><span class="line"><span class="comment">//游戏逻辑的实现</span></span><br><span class="line"><span class="comment">// 如果点击</span></span><br><span class="line"><span class="keyword">if</span>( b-&gt;getLineIndex()==<span class="number">1</span> &amp;&amp; b-&gt;getBoundingBox().containsPoint(t-&gt;getLocation()) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b-&gt;getColor()==Color3B::BLACK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!isTimerRunning)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;startTimer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触摸到黑色块，就让它变成灰色</span></span><br><span class="line">b-&gt;setColor(Color3B::GRAY);</span><br><span class="line"><span class="keyword">this</span>-&gt;moveDown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( b-&gt;getColor()==Color3B::GREEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;moveDown();</span><br><span class="line"><span class="keyword">this</span>-&gt;stopTimer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 未触摸到该行黑色块，就提示 游戏失败</span></span><br><span class="line">MessageBox(<span class="string">"GameOver"</span>,<span class="string">"失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="优化，Optimization"><a href="#优化，Optimization" class="headerlink" title="优化，Optimization"></a>优化，Optimization</h2><p>第一点，触摸屏蔽；即每次踩到白块后，屏蔽触摸，避免后续异常行为。</p><p>通过新建屏蔽层来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SwallowLayer.h  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cocos2d.h"</span></span></span><br><span class="line"> </span><br><span class="line">USING_NS_CC;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwallowLayer</span> :</span> <span class="keyword">public</span> Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/***** 初始化函数 *****/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;  </span><br><span class="line">CREATE_FUNC(SwallowLayer);</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SwallowLayer.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SwallowLayer.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> SwallowLayer::init( )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !Layer::init() )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加监听器</span></span><br><span class="line"><span class="keyword">auto</span> listener = EventListenerTouchOneByOne::create();</span><br><span class="line">listener-&gt;onTouchBegan= [<span class="keyword">this</span>](Touch* t,Event* e)&#123;</span><br><span class="line">CCLOG(<span class="string">"touch swallow layer"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">listener-&gt;setSwallowTouches(<span class="literal">true</span>);</span><br><span class="line">Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，记录最高分。</p><p>本游戏有两个模式：固定时间、固定函数。</p><p>每次游戏结束，都要向游戏结束界面传递对应数据，比如，在固定时间模式下显示花费的时间，在固定行数模式下显示完成行数。</p><p>通过对游戏结束层的函数重载来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受模式（Limit Block OR Limit Time ）,// true 为LimitBlocks，false为LimitTime</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createText</span><span class="params">( <span class="keyword">bool</span> mode , <span class="keyword">double</span> num )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createText</span><span class="params">( <span class="keyword">bool</span> mode )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameOver::createText( <span class="keyword">bool</span> mode , <span class="keyword">double</span> num )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( mode )&#123;</span><br><span class="line"><span class="comment">// 获取最高分</span></span><br><span class="line"><span class="keyword">double</span> highest = UserDefault::getInstance()-&gt;getDoubleForKey(<span class="string">"HIGHESTTIME"</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">CCLOG(<span class="string">"highest time %f"</span>,highest);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _highest = Label::create(StringUtils::format(<span class="string">"Highest: %.2f"</span>,highest),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">34</span>);</span><br><span class="line">_highest-&gt;setTextColor(Color4B::RED);</span><br><span class="line">_highest-&gt;setPosition(visibleSize.width/<span class="number">2</span>+<span class="number">100</span>,visibleSize.height/<span class="number">2</span>+<span class="number">100</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_highest);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _score = Label::create(StringUtils::format(<span class="string">"Yours: %.2f"</span>,num),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">60</span>);</span><br><span class="line">_score-&gt;setTextColor(Color4B::BLUE);</span><br><span class="line">_score-&gt;setPosition(visibleSize.width/<span class="number">2</span>,visibleSize.height/<span class="number">2</span><span class="number">-50</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_score);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( highest &gt; num || highest == <span class="number">0</span> )&#123;</span><br><span class="line">CCLOG(<span class="string">"this time %f"</span>,num);</span><br><span class="line">UserDefault::getInstance()-&gt;setDoubleForKey(<span class="string">"HIGHESTTIME"</span>,num);</span><br><span class="line">CCLOG(<span class="string">"this highest time %f"</span>,UserDefault::getInstance()-&gt;getDoubleForKey(<span class="string">"HIGHESTTIME"</span>,num));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取最高分</span></span><br><span class="line"><span class="keyword">int</span> highest = UserDefault::getInstance()-&gt;getIntegerForKey(<span class="string">"HIGHESTBLOCKS"</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _highest = Label::create(StringUtils::format(<span class="string">"Highest: %d"</span>,highest),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">34</span>);</span><br><span class="line">_highest-&gt;setTextColor(Color4B::RED);</span><br><span class="line">_highest-&gt;setPosition(visibleSize.width/<span class="number">2</span>+<span class="number">100</span>,visibleSize.height/<span class="number">2</span>+<span class="number">100</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_highest);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _score = Label::create(StringUtils::format(<span class="string">"Yours: %d"</span>,(<span class="keyword">int</span>)num),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">60</span>);</span><br><span class="line">_score-&gt;setTextColor(Color4B::BLUE);</span><br><span class="line">_score-&gt;setPosition(visibleSize.width/<span class="number">2</span>,visibleSize.height/<span class="number">2</span><span class="number">-50</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_score);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( highest &lt; num )&#123;</span><br><span class="line">UserDefault::getInstance()-&gt;setIntegerForKey(<span class="string">"HIGHESTBLOCKS"</span>,(<span class="keyword">int</span>)num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> GameOver::createText( <span class="keyword">bool</span> mode )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// mode——true:Limit Block,false:Limit Time</span></span><br><span class="line"><span class="keyword">if</span>( mode )&#123;</span><br><span class="line"><span class="comment">// 获取最高分</span></span><br><span class="line"><span class="keyword">double</span> highest = UserDefault::getInstance()-&gt;getDoubleForKey(<span class="string">"HIGHESTTIME"</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _highest = Label::create(StringUtils::format(<span class="string">"Highest: %.2f"</span>,highest),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">34</span>);</span><br><span class="line">_highest-&gt;setTextColor(Color4B::RED);</span><br><span class="line">_highest-&gt;setPosition(visibleSize.width/<span class="number">2</span>+<span class="number">100</span>,visibleSize.height/<span class="number">2</span>+<span class="number">100</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_highest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取最高分</span></span><br><span class="line"><span class="keyword">long</span> highest = UserDefault::getInstance()-&gt;getIntegerForKey(<span class="string">"HIGHESTBLOCKS"</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _highest = Label::create(StringUtils::format(<span class="string">"Highest: %d"</span>,highest),<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">34</span>);</span><br><span class="line">_highest-&gt;setTextColor(Color4B::RED);</span><br><span class="line">_highest-&gt;setPosition(visibleSize.width/<span class="number">2</span>+<span class="number">100</span>,visibleSize.height/<span class="number">2</span>+<span class="number">100</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_highest);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> _label = Label::create(<span class="string">"Fail!"</span>,<span class="string">"fonts/Marker Felt.ttf"</span>,<span class="number">60</span>);</span><br><span class="line">_label-&gt;setTextColor(Color4B::RED);</span><br><span class="line">_label-&gt;setPosition(visibleSize.width/<span class="number">2</span>,visibleSize.height/<span class="number">2</span><span class="number">-50</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(_label);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三点，时间显示的优化，就是做一个格式化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> modeLimitTime::getMillSecond()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    CCLOG(<span class="string">"CurrentTime MillSecond %f"</span>, (<span class="keyword">double</span>)tv.tv_sec * <span class="number">1000</span> + (<span class="keyword">double</span>)tv.tv_usec / <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)tv.tv_sec * <span class="number">1000</span> + (<span class="keyword">double</span>)tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间的偏差</span></span><br><span class="line">_time = (getMillSecond()-startTime)/<span class="number">1000.0</span>;</span><br><span class="line">CCLOG(<span class="string">"SubTime MillSecond %f"</span>, _time);</span><br><span class="line"><span class="comment">//强转offset为double类型，显示小数点后两位</span></span><br><span class="line">timerLabel-&gt;setString(StringUtils::format(<span class="string">"%.2f"</span>,_time));</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><p><br></p><hr><p>资料</p><ul><li><a href="https://pan.baidu.com/s/1bnjRGzd" target="_blank" rel="noopener">源码</a></li><li><a href="https://pan.baidu.com/s/1o6iPvlw" target="_blank" rel="noopener">APK</a></li></ul><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cocos2d-x 别踩白块&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多实践" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>聊聊DOTS</title>
    <link href="http://yoursite.com/2021/11/20/%E8%81%8A%E8%81%8ADOTS/"/>
    <id>http://yoursite.com/2021/11/20/%E8%81%8A%E8%81%8ADOTS/</id>
    <published>2021-11-20T13:00:00.000Z</published>
    <updated>2021-11-30T14:30:14.787Z</updated>
    
    <content type="html"><![CDATA[<p>Unity DOTS</p><p>DOTS - Data Oriented Tech Stack - 面向数据的技术栈</p><a id="more"></a><p><br></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司1024节日时，邀请人来介绍Unity DOTS，有点兴趣，自己也查阅了一番资料，简述一下我的理解。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>硬件发展瓶颈<ul><li>CPU发展，趋于平缓；后续发展由单核转向多核</li><li>内存发展，整体量级不足，无法满足CPU需求</li></ul></li><li>缺少能充分榨干多核CPU的引擎框架</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>Cache的充分利用<ul><li>减少碎片化内存</li><li>减少Cache Miss</li></ul></li><li>减少数据关联性，多核批量处理数据（解耦关联，可以不加锁）</li></ul><p><br></p><p><br></p><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul><li>Entity Component System(ECS)</li><li>Burst Compiler<ul><li>现在主流CPU都有专用浮点运算单元（尤其做 向量运算），过去的通用的编译器无法充分利用这块</li></ul></li><li>C# Job System<ul><li>面向多线程编程的方案</li><li>与ECS框架配合使用</li></ul></li><li>Native Containers<ul><li>配合ECS、C# Job System使用</li><li>ECS需要用大量数组、队列等容器，传统的容器被封装过，性能低</li></ul></li></ul><p><br></p><h2 id="ECS相关"><a href="#ECS相关" class="headerlink" title="ECS相关"></a>ECS相关</h2><p><img src="Archetype_Chunk.png" alt=""></p><p>结构类型:</p><ul><li>Entity, 唯一ID, 指向所属Component位置, 作为类似指针但并不是指针</li><li>Component, 保存对象的数据, 可当作struct, 不支持托管类型（例如引用）</li><li>Archetype, N种Compoent的组合, 每个Archetype的内存是连续排布, Archetype的变化，是通过内存拷贝来进行（由于是纯拷贝，速度很快）</li><li>Chunk, Component存储在Chunk中，多个Chunk隶属于同一个Archetype</li><li>System/Job System, 处理数据的方法，Job System负责多线程处理</li></ul><p>流程</p><ul><li>每个Entity有位置和速度两个属性，分别由 Component Velocity 和 Component Position 代表；</li><li>在计算坐标的update中，所有 Component Velocity 与 Component Position 传递给 system 计算出坐标，从而更新 Component Position。</li></ul><p>为什么性能高：</p><ul><li>正常模式下，在更新坐标的update中，遍历所有对象，获取对象的坐标及位置，计算出最终坐标，再更新位置</li><li>ECS中，获取所有速度及坐标组件，计算初最终坐标，更新坐标</li><li>内存存储中，正常模式的对象的对应字段不一定在一块，因此Cache Miss相对高一些</li><li>在DOTS中，提供内置容器及结构，进行更细致的内存管理；降低数据的耦合性后，可以执行多线程的操作</li></ul><p><br></p><p><br></p><h1 id="应用及发展"><a href="#应用及发展" class="headerlink" title="应用及发展"></a>应用及发展</h1><p>Physics<br>Hybrid Render(HDRP, URP)</p><p>Unity-ECS 渲染后端；相机culling、LOD计算，全用DOTS进行物理优化<br>未来 - GPU Driven渲染管线</p><p>我的理解：</p><p>对于当前的硬件趋势及问题的重要解决方案。<br>但是，要充分利用多核的无锁并行，就需要进行很大精力的数据解耦，这方面目前还是依赖开发者自行解决，因此，开发者的门槛其实很高。<br>所以，感觉并不是很适合在游戏开发内全部采用，更适合在一些关键模块中进行使用，也便于部分更专业的开发者维护。</p><p><br></p><p><br></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><em>以下是我在听介绍时的部分记录</em></p><p>解决性能问题，目标为真正的 AAA GAME</p><p>技术栈</p><ul><li>Entity Component System(ECS)</li><li>Burst compiler(High Performance C# - HPC#)<ul><li>编译器</li><li>现在主流CPU都有专用浮点运算单元（尤其做 向量运算），过去的通用的编译器无法充分利用这块</li></ul></li><li>C# Job System<ul><li>面向多线程编程的方案</li><li>与ECS框架配合使用</li></ul></li><li>Native Containers<ul><li>配合ECS、C# Job System使用</li><li>ECS需要用大量数组、队列等容器，传统的容器被封装过，性能低</li></ul></li></ul><p>内存满足不了CPU</p><ul><li>CPU开始开辟很多Cache，但是Cache有限</li><li>CPU从Cache读数据很快，没找到就产生一个Cache Miss，就要从RAM读取很慢</li><li>CPU读取Cache，一次读一行，每行基本 64字节</li></ul><p>目标</p><ul><li>性能，充分利用多核<ul><li>市面上还没有哪款引擎能充分利用多核（前提，硬件性能濒近极限）</li></ul></li><li>高度模块化，选配</li></ul><p>解决问题</p><ul><li>Cache Miss的优化</li><li>多线程的编程，批量处理数据，等比划分很多份，每个线程跑一部分（重点在于解耦，避免依赖性，因此访问内存可以不加锁）</li></ul><p>Entity</p><ul><li>唯一ID，指向位置</li><li>Entity有数组，删除的时候，与最后一位进行交换（不会进行整体位移）</li><li>不要通过EntityManager遍历数组查找entity，性能差；通过query访问</li></ul><p>Archetype</p><ul><li>n种component组合形式；每个archetype内存是连续排布，archetype发生变化，进行内存拷贝（仅仅拷贝，速度快，没有性能问题）</li><li>archetype太复杂，每个chunk存的entity有限，会剩余部分空间用不上</li></ul><p>Chunks </p><ul><li>存Entity多个component，存储的性能问题 </li><li>固定大小 16KB（性能优化的时候，要注意）</li><li>1个Archetype是chunk的数组</li><li>解决内存碎片化</li></ul><p>System</p><ul><li>处理数据，返回想要的内存数组</li></ul><p>Job System</p><ul><li>多线程处理数据</li></ul><p>Queries</p><ul><li>返回一组chunk，进行连续访问（先拿一个archetype，再筛想要的chunk返回）</li></ul><p>Component</p><ul><li>保存对象的数据，类似于C的struct，不支持托管类型（例如引用），必须是实型</li><li>希望每个component尽量小</li></ul><p>Special Component</p><ul><li>Tag Component，标记，不占内存</li><li>Shared Component，共享内存；Read Only；可以是托管类型（比如引用）</li><li>Chunk Component，Chunk内共享内存，可读可写，不可是托管类型</li><li>Class Component，让老结构更好转换到ECS框架；对引用类型数据存储；不推荐</li><li>System State Component，destroy的时候不被清空<ul><li>检测某个对象数据是否有改变，通过版本号是否变化</li></ul></li></ul><p>Dyncmic Buffers</p><ul><li>动态数组，无限扩充，默认128字节</li></ul><p>World</p><ul><li>隔离，Entity ID可重复了</li></ul><p>提供GameObject和ECS混用方式，编辑器用GameObject，会使用工具流自动转换为ECS</p><p><br></p><p><br></p><p><br></p><hr><p>参考资料</p><ul><li><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">Unity官方ECS Sample</a></li><li><a href="https://mp.weixin.qq.com/s/Sd_YieC1TPscub0Yx7mbsQ" target="_blank" rel="noopener">深入了解 Unity DOTS Sample！</a></li><li><a href="https://mp.weixin.qq.com/s/nKmUOLDg2MgBHYb63yehpA" target="_blank" rel="noopener">Unity新推出的DOTS技术如何？</a></li><li><a href="https://www.lfzxb.top/unity-dots-table-of-contents/" target="_blank" rel="noopener">Unity DOTS学习笔记_烟雨迷离半世殇</a></li></ul><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unity DOTS&lt;/p&gt;
&lt;p&gt;DOTS - Data Oriented Tech Stack - 面向数据的技术栈&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多思考" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>《乡土中国》读记</title>
    <link href="http://yoursite.com/2021/10/31/%E3%80%8A%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E3%80%8B%E8%AF%BB%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/10/31/%E3%80%8A%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E3%80%8B%E8%AF%BB%E8%AE%B0/</id>
    <published>2021-10-31T06:20:00.000Z</published>
    <updated>2021-11-03T14:29:48.477Z</updated>
    
    <content type="html"><![CDATA[<p>id 就是兽性</p><p>ego 是个两面派，即一面要克己复礼的作个社会所能接受的人，一面是又是满身难受地想越狱当逃犯</p><p>super-ego 就是顶在头上，不得不服从的社会规定的身份</p><a id="more"></a><p><br></p><h1 id="读因"><a href="#读因" class="headerlink" title="读因"></a>读因</h1><p>为什么想要读《乡土社会》这本书呢？</p><p>我个人对于故乡的概念不是很重，可能是因为从小搬家比较多相关吧，所以不是很理解，父母辈那种老了，就想回到老家生活的感觉。</p><p>如果说我是一个个例，但随着时代发展，越来越多的年轻人也对回老家，有些抵触或是形式化。</p><p>所以，想了解一下，这份乡土，这份社会，还有这份变迁。</p><p>这本书，真的值得细细品味，等待五年后，再来复读。</p><p><br></p><p><br></p><h1 id="读感"><a href="#读感" class="headerlink" title="读感"></a>读感</h1><p>乡土社会的本色与土相关，人类的生存所需都从土里索求，因此，人的品性，社会的基因，也大多有土的影子；但随着时代发展，生存所需的不仅仅由土提供，所以品行、社会的基因，也在不断的变革。</p><p>对于古早的乡土社会，大家的交流都是面对面的，都是务实且闭塞的，因此，形成了弱文化、差序格局与男女有别的状况；感触最深的就是差序格局；西洋的格局像是一捆捆扎清楚的柴，但我们的格局，是一块石头扔进塘中激起的那一轮轮涟漪。</p><p>随着时代发展，有个大的变化，是由传统礼治社会到法治社会的转变。其中，并没有绝对的对错，根据不同的现状，采取不同的措施，得到最大的效益，才是最终的目的。我更赞同的一点是，这是一个变化的过程，包括法治，可能也不是最终的终点，整个依旧在变化，根据遇到的问题，不断优化，优化的方向可能也有“回头”的状况，但是表象上的一致并不代表内因的一致。</p><p>是什么导致乡土社会的改变呢？</p><p>外因于交流，内因于人性。</p><p>人性在于，它有各种欲望，它需要被满足；满足了必要欲望后，不同的人有了不同非必要欲望。</p><p>交流在于，它提供了更多的途径，更多的方式；有了不同的选择。</p><p>时代的发展，让交流更充分；而交流又激发更多的欲望。</p><p><br></p><p><br></p><h1 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h1><h2 id="乡土本色"><a href="#乡土本色" class="headerlink" title="乡土本色"></a>乡土本色</h2><p>从土里长出过光荣的历史，自然也会受到土的束缚，现在很有些飞不上天的样子。</p><p>这是乡土社会的特性之一。我们很可以相信，以农为生的人，世代定居是常态，迁移是变态。大旱大水，连年兵乱，可以使一部分农民抛井离乡；即使像抗战这样大事件所引起基层人口的流动，我相信还是微乎其微的。</p><p>并不是说中国乡村人口是固定的。这是不可能的，因为人口在增加，一块地上只要几代的繁殖，人口就到了饱和点；过剩的人口自得宣泄出外，负起锄头去另辟新地。可是老根是不常动的。这些宣泄出外的人，像是从老树上被风吹出去的种子，找到土地的生存了，又形成一个小小的家族殖民地，找不到土地的也就在各式各样的运命下被淘汰了，或是“发迹了”。</p><p>乡土社会的信用并不是对契约的重视，而是发生于对一种行为的规矩熟悉到不加思索时的可靠性。</p><h2 id="文字下乡"><a href="#文字下乡" class="headerlink" title="文字下乡"></a>文字下乡</h2><p>“特殊语言”不过是亲密社群中所使用的象征体系的一部分，用声音来作象征的那一部分。在亲密社群中可用来作象征体系的原料比较多。表情、动作，在面对面的情景中，有时比声音更容易传情达意。</p><p>语言像是个社会定下的筛子，如果我们有一种情谊和这筛子的格子不同也就漏不过去。我想大家必然有过“无言胜似有言”的经验。其实这个筛子虽则有助于人和人间的了解，但同时却也使人和人间的情谊公式化了，使每一人、每一刻的实际情谊都走了一点样。我们永远在削足适履，使感觉敏锐的人怨恨语言的束缚。</p><h2 id="再论文字下乡"><a href="#再论文字下乡" class="headerlink" title="再论文字下乡"></a>再论文字下乡</h2><p>所谓学就是在出生之后以一套人为的行为方式作模型，把本能的那一套方式加以改造的过程。学的方法是“习”。习是指反复地做，靠时间中的磨练，使一个人惯于一种新的做法。</p><p>文化是依赖象征体系和个人的记忆而维护着的社会共同经验。这样说来，每个人的“当前”，不但包括他个人“过去”的投影，而且还是整个民族的“过去”的投影。历史对于个人并不是点缀的饰物，而是实用的、不可或缺的生活基础。人不能离开社会生活，就不能不学习文化。文化得靠记忆，不能靠本能，所以人在记忆力上不能不力求发展。</p><h2 id="差序格局"><a href="#差序格局" class="headerlink" title="差序格局"></a>差序格局</h2><p>为什么我们这个最基本的社会单位的名词会这样不清楚呢？在我看来却表示了我们的社会结构本身和西洋的格局是不相同的，我们的格局不是一捆一捆扎清楚的柴，而是好像把一块石头丢在水面上所发生的一圈圈推出去的波纹。每个人都是他社会影响所推出去的圈子的中心。被圈子的波纹所推及的就发生联系。每个人在某一时间某一地点所动用的圈子是不一定相同的</p><h2 id="维系着私人的道德"><a href="#维系着私人的道德" class="headerlink" title="维系着私人的道德"></a>维系着私人的道德</h2><p>这在差序社会里可以不觉得是矛盾；因为在这种社会中，一切普遍的标准并不发生作用，一定要问清了，对象是谁，和自己什么关系之后，才能决定拿出什么标准来。</p><h2 id="男女有别"><a href="#男女有别" class="headerlink" title="男女有别"></a>男女有别</h2><p>Oswald Spengler在“西方陆沈论”里曾说西洋曾有两种文化模式：一种他称作阿波罗式的Apollonian；一种他称作浮士德式的Faustian。阿波罗式的文化认定宇宙的安排有一个完善的秩序，这个秩序超于人力的创造，人不过是去接受它，安于其位，维持它；但是人连维持它的力量都没有，天堂遗失了，黄金时代过去了。这是西方古典的精神。现代的文化却是浮士德式的。他们把冲突看成存在的基础，生命是阻碍的克服；没有了阻碍，生命也就失去了意义。他们把前途看成无尽的创造过程，不断改变。</p><p>社会秩序范围着个性，为了秩序的维持，一切足以引起破坏秩序的要素都被遏制着。男女之间的鸿沟从此驻下。乡土社会是个男女有别的社会，也是个安稳的社会。</p><h2 id="礼治秩序"><a href="#礼治秩序" class="headerlink" title="礼治秩序"></a>礼治秩序</h2><p>礼是社会公认合式的行为规范。合于礼的就是说这些行为是做的对的，对是合式的意思。如果单从行为规范一点说，本和法律无异，法律也是一种行为规范。礼和法不相同的地方是维持规范的力量。法律是靠国家的权力来推行的。“国家”是指政治的权力，在现代国家没有形成前，部落也是政治权力。而礼却不需要这有形的权力机构来维持。维持礼这种规范的是传统。</p><p>礼治的可能必须以传统可以有效地应付生活问题为前提。乡土社会满足了这前提，因之它的秩序可以用礼来维持。在一个变迁很快的社会，传统的效力是无法保证的。</p><p>法治和礼治是发生在两种不同的社会情态中。这里所谓礼治也许就是普通所谓人治，但是礼治一词不会像人治一词那样容易引起误解，以致有人觉得社会秩序是可以由个人好恶来维持的了。礼治和这种个人好恶的统治相差甚远，因为礼是传统，是整个社会历史在维持这种秩序。礼治社会是并不能在变迁很快的时代中出现的，这是乡土社会的特色。</p><h2 id="无讼"><a href="#无讼" class="headerlink" title="无讼"></a>无讼</h2><p>现行的司法制度在乡间发生了很特殊的副作用，它破坏了原有的礼治秩序，但并不能有效地建立起法治秩序。法治秩序的建立不能单靠制定若干法律条文和设立若干法庭，重要的还得看人民怎样去应用这些设备。更进一步，在社会结构和思想观念上还得先有一番改革。如果在这些方面不加以改革，单把法律和法庭推行下乡，结果法治秩序的好处未得，而破坏礼治秩序的弊病却已先发生了。</p><h2 id="无为政治"><a href="#无为政治" class="headerlink" title="无为政治"></a>无为政治</h2><p>同意权力却有着一套经济条件的限制。依我在上面所说的，同意权力是分工体系的产物。分工体系发达，这种权力才能跟着扩大。乡土社会是个小农经济，在经济上每个农家，除了盐铁之外，必要时很可关门自给。于是我们很可以想象同意权力的范围也可以小到“关门”的程度。</p><h2 id="血缘和地缘"><a href="#血缘和地缘" class="headerlink" title="血缘和地缘"></a>血缘和地缘</h2><p>缺乏变动的文化里，长幼之间发生了社会的差次，年长的对年幼的具有强制的权力。这是血缘社会的基础。血缘的意思是人和人的权利和义务根据亲属关系来决定。亲属是由生育和婚姻所构成的关系。</p><p>地缘是从商业里发展出来的社会关系。血缘是身份社会的基础，而地缘却是契约社会的基础。</p><h2 id="名实的分离"><a href="#名实的分离" class="headerlink" title="名实的分离"></a>名实的分离</h2><p>在新旧交替之际，不免有一个惶惑、无所适从的时期，在这个时期，心理上充满着紧张、犹豫和不安。这里发生了“文化英雄”，他提得出办法，有能力组织新的试验，能获得别人的信任。这种人可以支配跟从他的群众，发生了一种权力。这种权力和横暴权力并不相同，因为它并不是建立在剥削关系之上的；和同意权力又不同，因为它并不是由社会所授权的；和长老权力更不同，因为它并不根据传统的。它是时势所造成的，无以名之，名之曰时势权力。</p><p>儒家所注重的“孝”道，其实是维持社会安定的手段，孝的解释是“无违”，那就是承人长老权力。长老代表传统，遵守传统也就可以无违于父之教。但是传统的代表是要死亡的，而且自己在时间过程中也会进入长老的地位。如果社会变迁的速率慢到可以和世代交替的速率相等，亲子之间，或是两代之间，不致发生冲突，传统自身慢慢变，还是可以保持长老的领导权。这种社会也就不需要“革命”了。</p><p>从整个社会看，一个领导的阶层如果能追得上社会变迁的速率，这社会也可以避免因社会变迁而发生的混乱。</p><h2 id="从欲望到需要"><a href="#从欲望到需要" class="headerlink" title="从欲望到需要"></a>从欲望到需要</h2><p>在乡土社会中人可以靠欲望去行事，但在现代社会中欲望并不能作为人们行为的指导，于是产生了“需要”，因之有了“计划”。</p><p>说人类行为是有动机的包含着两个意思：一是人类对于自己的行为是可以控制的。要这样做就这样做，不要这样做就不这样做，也就是所谓的意志。一是人类在取舍之间有所根据，这根据就是欲望。</p><p>爱情，好吃，是欲望，那是自觉的。直接决定我们行为的确是这些欲望。这些欲望所引导出来的行为是不是总和人类生存的条件相合的呢？这问题曾引起过很多学者的讨究。我们如果从上面这段话看去，不免觉得人类的欲望确乎有点微妙，他们尽管要这个要那个，结果却常常正合于他们生存的条件。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>对“社会”历来有两种基本上不同的看法。一是把社会看作众多个人集合生活的群体。严复翻译sociology作“群学”。众人为群，一个个人为了生活的需要而聚集在一起形成群体，通过分工合作来经营共同生活，满足个人的生活需要。另一种看法却认为群体固然是由一个个人聚合而成，没有一个个人也就没有群体，这是简单易明的。但是形成了群体的个人，已经不仅是一个个生物体，他们已超出了自然演化中的生物界，进入了另一个层次，这个层次就是社会界。</p><p>生物实体和社会实体是属于自然演化过程中的两个层次。人有两个属性：生物人和社会人。</p><p>社会就是人类的群体。更符合我的主观倾向的是社会所规定的一切成规和制度都是人造出来，满足人的生活需要的手段，如果不能满足就得改造，手段自应服从人的主观要求。中国人民在我这一生中正处在社会巨大变动之世。如果社会制度不是人类的手段，那就好像谈不上人为的改革了。</p><p>我想只有从每个社区根据它特有的具体条件而形成的社会结构出发，不同社区才能相互比较。在互相比较中才能看出同类社区的差别，而从各社区具体条件去找出差别的原因，进一步才能看到社区发展和变动的规律，进入理论的领域。</p><p>我越来越觉得一个人的思想总是离不开他本人的切身经历。我从解放后所逢到的我称之为不寻常的经历，必然会反映在我其后的学术思想上，以至于立身处世的现实生活上。我如果完全把这段时间作为学术经历中的空白是不够认真的。</p><p>埃尔顿·梅岳教授，曾在芝加哥的霍桑工厂里研究怎样提高劳动生产率的问题，做了一系列实验。起初他采取改变各种工作条件，如厂内的光线，休息的时间等，来测验工作效率是否有相应的提高，结果确实上升了。但梅岳认为并没有解决提高工作效率的关键问题。他接着再做实验倒过来一一取消了这些客观条件的改变，出乎大家意料之外，工作效率却依然上升。他从中得到一个重大发现，原来不是客观条件的改变促使了工作效率的上升，而是他的实验本身起了作用。因为工人参与了这个实验，自己觉得在进行一项有意义的科学工作，从而发现了自己不仅是一个普通拿工资干活的机器，而是一个能创造科学价值的实验者了。这个转变提高了他们的积极性。梅岳在这里发现了普通“工人身份”后面潜伏着一种“人的因素”，这个因素是工作效率的泉源。</p><p>所以我用了Freud所说的三层结构来说明人的心里构成：一是id（生物性的冲动），二是ego（自己），三是super-ego（超己）。id就是兽性，ego是个两面派，即一面要克己复礼的作个社会所能接受的人，一面是又是满身难受地想越狱当逃犯。super-ego就是顶在头上，不得不服从的社会规定的身份。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;id 就是兽性&lt;/p&gt;
&lt;p&gt;ego 是个两面派，即一面要克己复礼的作个社会所能接受的人，一面是又是满身难受地想越狱当逃犯&lt;/p&gt;
&lt;p&gt;super-ego 就是顶在头上，不得不服从的社会规定的身份&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多读书" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
